<section data-type="chapter" id="ch_mobile_stomp" xmlns="http://www.w3.org/1999/xhtml">
<h1>Mobile Messaging with STOMP</h1>

<p class="lead">In this chapter, we will write our first messaging client: a native application running on an iPhone.<a contenteditable="false" data-primary="mobile messaging with STOMP" data-type="indexterm" id="mobmessSTOMP">&nbsp;</a> We will use STOMP to send and receive messages using the Objective-C library StompKit.<a contenteditable="false" data-primary="STOMP" data-secondary="mobile messaging with" data-type="indexterm" id="STOMPmobmess">&nbsp;</a></p>

<p>In <a data-type="xref" href="#ch_introduction_stomp_example">#ch_introduction_stomp_example</a>, we described the Locations application. In this chapter, we will write the iOS application that broadcasts the device&rsquo;s position and receives text messages ().</p>

<figure id="img_mobile_stomp_1"><img alt="Diagram of the Locations iOS application" src="images/mawm_0201.png" />
<figcaption>Diagram of the Locations iOS application</figcaption>
</figure>

<div data-type="note">
<p>Throughout the chapter, we will show all the code required to run the application.</p>

<p>The whole application code can be retrieved from the <a href="https://github.com/mobile-web-messaging/code">GitHub repository</a> in the <em>stomp/ios/</em> directory.</p>
</div>

<section data-type="sect1" id="_stompkit">
<h1>StompKit</h1>

<p>To use STOMP on iOS, we will use the StompKit Objective-C library that implements the STOMP protocol in a modern, event-driven way using ARC, Grand Central Dispatch, and<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="StompKit" data-type="indexterm">&nbsp;</a> blocks.<a contenteditable="false" data-primary="StompKit" data-type="indexterm">&nbsp;</a></p>

<p>The source code of this library project is hosted on <a href="https://github.com/mobile-web-messaging/StompKit/">GitHub</a>.</p>
</section>

<section data-type="sect1" id="_create_the_code_locations_code_project_with_xcode">
<h1>Create the Locations Project with Xcode</h1>

<p>We will use <a href="https://developer.apple.com/xcode/">Xcode</a> to create the <code>Locations</code> iOS <a contenteditable="false" data-primary="Xcode" data-secondary="creating Locations project" data-type="indexterm">&nbsp;</a>application.<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="creating Locations project with Xcode" data-type="indexterm">&nbsp;</a></p>

<p>When Xcode is installed and started, we create a new project from its launch screen, as illustrated in :</p>

<figure id="img_mobile_stomp_125"><img alt="XCode Launch screen" src="images/mawm_0202.png" />
<figcaption>Select &quot;Create a new Xcode project&quot; from the Xcode launch screen</figcaption>
</figure>

<p>The application consists of a single view, so we choose the Single View Application template in iOs &rarr; Application from the template screen, as illustrated in .</p>

<figure id="img_mobile_stomp_2"><img alt="XCode template screen" src="images/mawm_0203.png" />
<figcaption>Select Single View Application from the template screen</figcaption>
</figure>

<p>We will call the project Locations and select to build it only for iPhone devices, as illustrated in .</p>

<figure id="img_mobile_stomp_3"><img alt="XCode project options screen" src="images/mawm_0204.png" />
<figcaption>XCode project options screen</figcaption>
</figure>

<p>Finally, we will save it in a folder on our machine.</p>
</section>

<section data-type="sect1" id="ch_mobile_stomp_cocoapods">
<h1>Create the Podfile</h1>

<p>To import the library that we will use to send and receive messages, we will set up the project to use <a href="http://cocoapods.org">CocoaPods</a>, an <a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="creating the Podfile" data-type="indexterm">&nbsp;</a>Objective-C <a contenteditable="false" data-primary="Objective-C" data-secondary="CocoaPods library manager" data-type="indexterm">&nbsp;</a>Library Manager.<a contenteditable="false" data-primary="CocoaPods library manager" data-type="indexterm">&nbsp;</a></p>

<p>First, we need to close Xcode, because we will modify the project structure to import our dependencies.</p>

<p>After installing CocoaPods by following the <a href="http://guides.cocoapods.org/using/getting-started.html#getting-started">instructions on its website</a>, we create a file named <em>Podfile</em> at the root of<a contenteditable="false" data-primary="Podfile, creating" data-type="indexterm">&nbsp;</a> the project (in the same directory as <em>Locations.xcodeproj</em>):</p>

<pre data-type="programlisting">
xcodeproj 'Locations.xcodeproj'

pod 'StompKit', '~&gt; 0.1'

platform :ios, '5.0'</pre>

<p>After saving<a contenteditable="false" data-primary="pod install command" data-type="indexterm">&nbsp;</a> this file, run the <strong><code>pod install</code></strong> command:</p>

<pre data-type="programlisting">
$ pod install
Analyzing dependencies
Downloading dependencies
Installing CocoaAsyncSocket (7.3.2)
Installing StompKit (0.1.0)
Generating Pods project
Integrating client project

[!] From now on use `Locations.xcworkspace`.</pre>

<p>We can now open Xcode again, <a contenteditable="false" data-primary="Xcode" data-secondary="opening Locations workspace file" data-type="indexterm">&nbsp;</a>but we must do it using the workspace file named <em>Locations.xcworkspace</em>, and not the project file named <em>Locations.xcodeproj</em> ().</p>

<figure id="img_mobile_stomp_4"><img alt="Open the Workspace file" src="images/mawm_0205.png" />
<figcaption>Open the Workspace file</figcaption>
</figure>

<p>First, we will verify that the project is set up correctly and that the application can run in the iOS simulator.<a contenteditable="false" data-primary="iOS simulator" data-secondary="testing Locations application in" data-type="indexterm">&nbsp;</a></p>

<p>We will simulate the latest iPhone devices by selecting Product &rarr; Destination &rarr; iPhone Retina (4-inch 64-bit) from the Xcode menu bar.<a contenteditable="false" data-primary="Xcode" data-secondary="simulating iPhone devices for Locations application" data-type="indexterm">&nbsp;</a></p>
<!--
Command symbol is not displayed in PDF.
-->

<p>If we run the application by selecting Product &rarr; Run (or pressing <code>âŒ˜+R</code>), the iOS simulator starts and opens the application, which is composed of a blank view ().</p>

<figure id="img_mobile_stomp_5"><img alt="Locations Blank View" src="images/mawm_0206.png" />
<figcaption>Blank view of the Locations application</figcaption>
</figure>

<p>Nothing is displayed, but it confirms that the project and its dependencies are successfully compiled and launched.</p>
</section>

<section data-type="sect1" id="ch_mobile_stomp_deviceID">
<h1>Identify the Device</h1>

<p>The iPhone device will broadcast<a contenteditable="false" data-primary="iPhone" data-secondary="identifying the device" data-type="indexterm">&nbsp;</a> its position.<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="identifying the device" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="device IDs" data-type="indexterm">&nbsp;</a> The first thing to do is identify the device. To keep the example simple, we will use a <em>universal unique identifier</em> (or UUID) as <a contenteditable="false" data-primary="UUIDs (universal unique identifiers)" data-type="indexterm">&nbsp;</a>the device identifier and display it in the view.</p>

<p>Because the application will run only on iPhone devices,&nbsp;the entire user interface will be set up in the <em>Main.storyboard</em> file.</p>

<p>Click on <em>Main.storyboard</em> to open it. From the Object library, drag a Label on the View's window. Place it at the top of the view and change the text to &quot;Device ID,&quot; as illustrated in .</p>

<figure id="img_mobile_stomp_6"><img alt="Add the Device ID label" src="images/mawm_0207.png" />
<figcaption>Add the Device ID label</figcaption>
</figure>

<div data-type="note">
<p>I will not describe in detail how to set up the layout constraints for the graphical objects so that they adapt correctly to the device&rsquo;s size and orientation.</p>

<p>However, the example code in the <a href="https://github.com/mobile-web-messaging/code">GitHib repository</a> is constrained correctly.</p>
</div>

<p>The UUID that we will generate is quite long, so we will change its appearance by setting its Font to System 13.0 and its Alignment to centered to fit the screen, as illustrated in .</p>

<figure id="img_mobile_stomp_7"><img alt="Change the appearance of the device ID label" src="images/mawm_0208.png" />
<figcaption>Change the appearance of the device ID label</figcaption>
</figure>

<p>We will connect this label to the <code>MWMViewController</code> object.</p>

<p>Add the necessary outlet property in the <code>MWMViewController</code> private interface in <em>MWMViewController.m</em> and an <code>NSString</code> to hold the identifier:</p>

<pre data-code-language="objc" data-type="programlisting">
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (copy, nonatomic) NSString *deviceID;

@end</pre>

<p>Open the <em>Main.storyboard</em> and Ctrl-click on View Controller to see its connection panel. Drag from deviceIDLabel to the UILabel to connect it. See .</p>

<figure id="img_mobile_stomp_8"><img alt="Connect the deviceIDLabel outlet property to the device ID UILabel" src="images/mawm_0209.png" />
<figcaption>Connect the deviceIDLabel outlet property to the Device ID UILabel</figcaption>
</figure>

<p>Now that the outlet property is connected to the label, we need to generate a UUID for the application and display it when the view appears.<a contenteditable="false" data-primary="UUIDs (universal unique identifiers)" data-secondary="generating for Locations iOS application" data-type="indexterm">&nbsp;</a></p>

<p>Open the <em>MWMViewController.m</em> file to add code to the <code>MWMViewController</code> implementation. When the application starts and the view is loaded in <code>viewDidLoad</code>, we set the <code>deviceID</code> using a UUID:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@&quot;Device identifier is %@&quot;, self.deviceID);
}</pre>

<div data-type="note">
<p>The <code>identifierForVendor</code> property will uniquely identify the device for the application&rsquo;s vendor (that we set to <code>net.mobile-web-messaging</code> when we created the project).</p>
</div>

<p>We also need to set the label to this ID when the view appears:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewWillAppear:(BOOL)animated
{
    self.deviceIDLabel.text = self.deviceID;
}</pre>

<p>If we run the application, we will see the device ID displayed instead of <code>Device ID</code> in the view ().</p>

<figure id="img_mobile_stomp_9"><img alt="Display the device ID" src="images/mawm_0210.png" />
<figcaption>Display the device ID</figcaption>
</figure>

<p>Now that we have the identifier of the device, the next step is to retrieve its geolocation data using the <code>CoreLocation</code> framework before we can send them in a STOMP message.<a contenteditable="false" data-primary="CoreLocation framework" data-type="indexterm">&nbsp;</a></p>

<div data-type="note">
<p>The following sections deal with setting up the framework and writing code to retrieve the GPS data from the device and display it. This is unrelated to messaging, and you can skip these sections if you only want to know how to send and receive messages. Still, I thought the messaging code would be more meaningful if it were using real data instead of generating random dummy data. By using GPS data instead, we will be able to build a mobile application that displays this data on a map in the next chapter.</p>
</div>
</section>

<section data-type="sect1" id="ch_mobile_stomp_display_position">
<h1>Display the Device Position</h1>

<p>We will retrieve the geolocation data from the device&rsquo;s GPS sensor to send them using STOMP messages.<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="displaying device position" data-type="indexterm">&nbsp;</a> However, we also want to have some graphical feedback to show that the data changes over time as we move with our device.</p>

<p>To display the geolocation data, we will add a <code>UILabel</code> to the view and change its text to &quot;Current position: ???&quot; ().</p>

<figure id="img_mobile_stomp_10"><img alt="Add the current position label" src="images/mawm_0211.png" />
<figcaption>Add the current position label</figcaption>
</figure>

<p>We will change its appearance to match the <code>deviceID</code> label by setting its Font to System 13.0 and its Alignment to centered ().</p>

<figure id="img_mobile_stomp_11"><img alt="Change the current position label appearance" src="images/mawm_0212.png" />
<figcaption>Change the appearance of the current position label</figcaption>
</figure>

<p>Open the <em>MWMViewController.m</em> file and add a property to the <code>MWMViewController</code> private interface:</p>

<pre data-code-language="objc" data-type="programlisting">
@property (weak, nonatomic) IBOutlet UILabel *currentPositionLabel;</pre>

<p>We then bind this property to the label. Open the <em>Main.storyboard</em> and Ctrl-click on View Controller to see its connection panel. Drag from currentPositionLabel to the label to connect it. See .</p>

<figure id="img_mobile_stomp_12"><img alt="Connect the currentPositionLabel outlet property to the current position UILabel" src="images/mawm_0213.png" />
<figcaption>Connect the currentPositionLabel outlet property to the Current Position UILabel</figcaption>
</figure>

<p>The label is now connected to the property. The next step is to retrieve the geolocation data from the device to update this property and send a STOMP message with them.</p>
</section>

<section data-type="sect1" id="_access_the_device_geolocation_data_with_code_corelocation_code_framework">
<h1>Access the Device Geolocation Data with CoreLocation Framework</h1>

<p>iOS provides the <code>CoreLocation</code> framework<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="accessing device geolocation data with CoreLocation" data-type="indexterm">&nbsp;</a> to access the location data.<a contenteditable="false" data-primary="CoreLocation framework" data-secondary="accessing device geolocation data with" data-type="indexterm">&nbsp;</a></p>

<p>We need to add it to the libraries linked by the application. Click on the Locations project and then the Locations target. In the General tab, under the Linked Frameworks and Libraries section, click on the <code>+</code> button. In the selection window, type <strong><code>CoreLocation</code></strong>, select the CoreLocation.framework, and click on the Add button ().</p>

<figure id="img_mobile_stomp_13"><img alt="Add the CoreLocation framework" src="images/mawm_0214.png" />
<figcaption>Add the CoreLocation framework</figcaption>
</figure>

<p>We can now use the CoreLocation framework by importing <em>CoreLocation/CoreLocation.h</em> at the top of the <em>MWMViewController.m</em> file.</p>

<p>We will make the <code>MWMViewController</code> private interface conform to the <code>CLLocationManagerDelegate</code> protocol and declare a <code>CLLocationManager</code> property named <code>locationManager</code>:</p>

<pre data-code-language="objc" data-type="programlisting">
#import &lt;CoreLocation/CoreLocation.h&gt;

interface MWMViewController () &lt;CLLocationManagerDelegate&gt;

@property (strong, nonatomic) CLLocationManager *locationManager;

@end</pre>

<p>We will define two methods to start and stop updating the current location. When the app starts updating the current location in <code>startUpdatingCurrentLocation</code>, it creates the <code>locationManager</code> if it is not already created and designates the controller as the <code>locationManager</code>&rsquo;s <code>delegate</code>. Because the geolocation data will be used to follow the device as it moves, we set the <code>locationManager</code>&rsquo;s <code>desiredAccuracy</code> to <code>kCLLocationAccuracyBestForNavigation</code>.</p>

<p>Finally, the application will start listening for the device location by calling <code>locationManager</code>&rsquo;s <code>startUpdatingLocation</code> method:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - CoreLocation actions

- (void)startUpdatingCurrentLocation
{
    NSLog(@&quot;startUpdatingCurrentLocation&quot;);

    // if location services are restricted, do nothing
    if ([CLLocationManager authorizationStatus] == 
    kCLAuthorizationStatusDenied ||
  [CLLocationManager authorizationStatus] == 
  kCLAuthorizationStatusRestricted) {
        return;
    }

    // if locationManager does not currently exist, create it
    if (!self.locationManager) {
        self.locationManager = [[CLLocationManager alloc] init];
        // set its delegate to self
        self.locationManager.delegate = self;
        // use the accuracy best suite for navigation
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation;
    }

    // start updating the location
    [self.locationManager startUpdatingLocation];
}</pre>

<p>To stop receiving the device location in <code>stopUpdatingCurrentLocation</code>, we simply call <code>locationManager</code>&rsquo;s <code>stopUpdatingLocation</code> method:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)stopUpdatingCurrentLocation
{
    [self.locationManager stopUpdatingLocation];
}</pre>

<p>The location of the device will be received by the designated <code>CLLocationManagerDelegate</code> (in our case, the <code>MWMViewController</code> implementation itself). We need to implement the <code>locationManager:didUpdateToLocation:fromLocation:</code> method and extract the coordinates from the <code>newLocation</code>'s <code>coordinate</code>.</p>

<p>After we have them, we can update the <code>currentPositionLabel</code>'s <code>text</code> to display them:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - CLLocationManagerDelegate protocol

- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30s
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) &gt; 30) {
        return;
    }

    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@&quot;&phi;:%.4F, &lambda;:%.4F&quot;, coord.latitude, coord.longitude];
}</pre>

<p>If there is any problem with the <code>locationManager</code>, we want to warn the user about it and stop updating the location. To do so, we implement the <code>CLLocationManagerDelegate</code>'s <code>locationManager:didFailWithError:</code> method to display a warning to the user:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)locationManager:(CLLocationManager *)manager
       didFailWithError:(NSError *)error
{
    // reset the current position label
    self.currentPositionLabel.text = @&quot;Current position: ???&quot;;

    // show the error alert
    UIAlertView *alert = [[UIAlertView alloc] init];
    alert.title = @&quot;Error obtaining location&quot;;
    alert.message = [error localizedDescription];
    [alert addButtonWithTitle:@&quot;OK&quot;];
    [alert show];
}</pre>

<p>Now that the code related to <code>CoreLocation</code> is in place, we just need to call the <code>startUpdatingCurrentLocation</code> method when the view appears:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;

    [self startUpdatingCurrentLocation];
}</pre>

<p>We also need to stop updating the location when the view disappears in <code>viewDidDisappear:</code>.</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
}</pre>

<p>The first time the application asks the <code>locationManager</code> to start updating the device location, the user will see an alert view asking for permission to access the device location ().</p>

<figure id="img_mobile_stomp_14"><img alt="Permission to use the current location" src="images/mawm_0215.png" />
<figcaption>Permission to use the current location</figcaption>
</figure>

<p>If the user taps OK, the <code>locationManager</code> will start updating the device location and the label for its current position will be updated with the latitude and longitude ().</p>

<figure id="img_mobile_stomp_15"><img alt="Display the current position of the device" src="images/mawm_0216.png" />
<figcaption>Display the current position of the device</figcaption>
</figure>

<section data-type="sect2" id="ch_mobile_stomp_location_simulator">
<h2>Simulate a Location with iOS Simulator</h2>

<p>If you are running the application on an iPhone device, the real geolocation data from the device will be used.<a contenteditable="false" data-primary="iOS simulator" data-secondary="simulation a location" data-type="indexterm">&nbsp;</a> <a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="simulating a location with iOS Simulator" data-type="indexterm">&nbsp;</a>If you run the application using the iOS Simulator, you can simulate different locations in the Debug &rarr; Location menu. For example, the Freeway Drive option will simulate a car driving on a freeway between Palo Alto and San Francisco.</p>

<p>Whether you are running the application on a device or in the simulator, you should see the <code>currentPositionLabel</code> be updated. The latitude and longitude numbers are difficult to interpret as such, but in <a data-type="xref" href="#ch_web_stomp">#ch_web_stomp</a> we will use them to draw the position on a map to locate the devices.</p>

<p>Now that the <code>Locations</code> application is handling the device geolocation data, the next step is to send them using STOMP.</p>
</section>
</section>

<section data-type="sect1" id="_create_a_stomp_client_with_code_stompkit_code">
<h1>Create a STOMP Client with StompKit</h1>

<p>Before sending any messages, we must first import the StompKit library that we added to the <em>Podfile</em> file at the beginning<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="creating a STOMP client with StompKit" data-type="indexterm">&nbsp;</a> of this chapter.<a contenteditable="false" data-primary="StompKit" data-secondary="creating a STOMP client with" data-type="indexterm">&nbsp;</a></p>

<p>We must import its header file <em>StompKit.h</em> at the top of the <em>MWMViewController.m</em> file and add a <code>STOMPClient</code> property named <code>client</code> to the <code>MWMViewController</code> private interface:</p>

<pre data-code-language="objc" data-type="programlisting">
#import &lt;StompKit.h&gt;

@interface MWMViewController () &lt;CLLocationManagerDelegate&gt;

@property (nonatomic, strong) STOMPClient *client;

@end</pre>

<p>The <code>client</code> property will be used to communicate with the STOMP broker after it is created and connected.</p>

<p>We do not need to conform to any protocol to use StompKit, as its API is based on <em>blocks</em> instead of protocol delegates.</p>

<p>The <code>client</code> variable is created when the controller&rsquo;s view is loaded in <code>MWMViewController</code>'s <code>viewDidLoad</code> method implementation. To create it, we need to pass the host and port of the STOMP broker to connect to. This information depends on the broker you are using. If you have configured ActiveMQ on your machine as described in <a data-type="xref" href="#appendix_activemq">#appendix_activemq</a>, you will be able to connect on its <code>61613</code> port.</p>

<p>The host will depend on your network configuration. On my local network, my server has the IP address <em>192.168.1.25</em>. I will use this value for the example, but you should replace this with your own server address to run the applications:</p>

<pre data-code-language="objc" data-type="programlisting">
#define kHost     @&quot;192.168.1.25&quot;
#define kPort     61613

...

@implementation MWMViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@&quot;Device identifier is %@&quot;, self.deviceID);

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];
}</pre>
</section>

<section data-type="sect1" id="_connect_to_a_stomp_broker">
<h1>Connect to a STOMP Broker</h1>

<p>When the <code>client</code> object is created, it is not yet connected to the<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="connecting to a STOMP broker" data-type="indexterm">&nbsp;</a> STOMP broker.<a contenteditable="false" data-primary="brokers" data-secondary="connecting to a STOMP broker" data-type="indexterm">&nbsp;</a> To connect, we must call its <code>connectWithHeaders:completionHandler:</code> method.</p>

<p>StompKit uses Grand Central Dispatch and blocks to provide an event-driven API. This means that the client is <em>not</em> connected when the call to its <code>connectWithHeaders:completionHandler:</code> method returns but when the <code>completionHandler</code> block is called.</p>

<p>We can pass a dictionary to <code>connectWithHeaders:completionHandler:</code> to add additional headers during the connection to the STOMP broker. In our application, we will send a <code>client-id</code> header set to the <code>deviceID</code> to uniquely identify the client against the STOMP broker.</p>

<p>This ensures that no two devices will be able to connect using the same identifier. After a client is connected with a given <code>client-id</code>, any subsequent clients that use the same value will fail to connect to the broker.</p>

<p>We will encapsulate this code in a <code>connect</code> method in the <code>MWMViewController</code> implementation.</p>

<pre data-code-language="objc" data-type="programlisting">
@implementation MWMViewController

#pragma mark - Messaging

- (void)connect
{
    NSLog(@&quot;Connecting...&quot;);
    [self.client connectWithHeaders:@{ @&quot;client-id&quot;: self.deviceID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError
                  *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@&quot;Error during connection: %@&quot;,
                          error);
                      } else {
                          // we are connected to the STOMP broker without an
                          error
                          NSLog(@&quot;Connected&quot;);
                      }
                  }];
    // when the method returns, we cannot assume that the client is connected
}

@end</pre>

<p>We will call this <code>connect</code> method when the view appears in <code>viewWillAppear:</code>.</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;

    [self startUpdatingCurrentLocation];
    [self connect];
}</pre>
</section>

<section data-type="sect1" id="_disconnect_from_a_stomp_broker">
<h1>Disconnect from a STOMP Broker</h1>

<p>The <code>STOMPClient</code> disconnects from<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="disconnecting from a STOMP broker" data-type="indexterm">&nbsp;</a> the <a contenteditable="false" data-primary="brokers" data-secondary="disconnecting from a STOMP broker" data-type="indexterm">&nbsp;</a>broker using its <code>disconnect:</code> method. This method takes a block that will be called when the client is disconnected from the server. The block takes an <code>NSError</code> parameter that is set if there is an error during the disconnection operation.</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - Messaging

- (void)disconnect
{
    NSLog(@&quot;Disconnecting...&quot;);
    [self.client disconnect:^(NSError *error) {
        if (error) {
            NSLog(@&quot;Error during disconnection: %@&quot;, error);
        } else {
            // the client is disconnected from the broker without any problem
            NSLog(@&quot;Disconnected&quot;);
        }
    }];
    // when the method returns, we cannot assume that the client is disconnected
}</pre>

<p>We will disconnect from the broker after the view has disappeared in <code>viewDidDisappear:</code>.</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [self disconnect];
}</pre>

<p>At this stage, we have an application that connects to the STOMP broker when its view is displayed and disconnects when its view disappears.</p>

<p>If we run the application, we see logs in Xcode that show the connection process:</p>

<pre data-type="programlisting">
2014-03-13 17:07:21.667 Locations[79069:60b] Connecting...
2014-03-13 17:07:21.723 Locations[79069:3903] Connected</pre>
</section>

<section data-type="sect1" id="_send_stomp_messages">
<h1>Send STOMP Messages</h1>

<p>We now have a connection to the STOMP broker and receive the device&rsquo;s geolocation data from the <code>CoreLocation</code> framework.<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="sending STOMP messages" data-type="indexterm">&nbsp;</a> The last step is to send this data to the topic associated to the device ID.<a contenteditable="false" data-primary="messages" data-secondary="sending STOMP messages" data-tertiary="Locations mobile application (example)" data-type="indexterm">&nbsp;</a></p>

<p>As we described in <a data-type="xref" href="#ch_introduction_stomp_example_topology">#ch_introduction_stomp_example_topology</a>, each device will send its location in a topic named after its identifier.</p>

<pre data-code-language="objc" data-type="programlisting">
NSString *destination = 
  [NSString stringWithFormat:@&quot;/
topic/device.%@.location&quot;, 
self.deviceID];</pre>

<div data-type="note">
<p>ActiveMQ convention is to prefix a STOMP destination with <code>/topic/</code> to use a publish/subscribe messaging model and by <code>/queue/</code> to use a point-to-point model.</p>

<p>We designed our application to use a topic for the <code>device.XXX.location</code>, so we must prefix it with <code>/topic/</code>.</p>
</div>

<p>As we described in <a data-type="xref" href="#ch_introduction_stomp_example_message">#ch_introduction_stomp_example_message</a>, the message representation is a JSON string that contains the location coordinates, the timestamp, and the device ID. We build an <code>NSDictionary</code> from this data and serialize it as a JSON string:</p>

<pre data-code-language="objc" data-type="programlisting">
NSDictionary *dict = @{
    @&quot;deviceID&quot;: self.deviceID,
    @&quot;lat&quot;: [NSNumber numberWithDouble:location.coordinate.latitude],
    @&quot;lng&quot;: [NSNumber numberWithDouble:location.coordinate.longitude],
    @&quot;ts&quot;: [dateFormatter stringFromDate:location.timestamp]
};
   NSData *data = 
[NSJSONSerialization 
dataWithJSONObject:dict 

options:0 

error:nil];
   NSString *body =[[NSString alloc] 
initWithData:data 

encoding:NSUTF8StringEncoding];</pre>

<p>This body follows the JSON format.<a contenteditable="false" data-primary="JSON" data-secondary="STOMP message body" data-type="indexterm">&nbsp;</a> We will add a <code>content-type</code> header in the STOMP message and set it to <code>application/json; charset=utf-8</code> to let the STOMP brokers and the eventual consumers know that this message&rsquo;s payload can be read as a JSON string encoded with UTF-8. Without such a <code>content-type</code>, the consumers would not necessarily know how to <em>read</em> the data in the body and interpret it.</p>

<pre data-code-language="objc" data-type="programlisting">
NSDictionary *headers = @{
    @&quot;content-type&quot;: @&quot;application/json;charset=utf-8&quot;
};</pre>

<p>We now have the <code>destination</code>, <code>headers</code>, and <code>body</code> to send in the message. The last step is to use the <code>client</code>'s <code>sendTo:headers:body</code> method to send it.</p>

<pre data-code-language="objc" data-type="programlisting">
// send the message
[self.client sendTo:destination
            headers:headers
               body:body];</pre>

<p>We will encapsulate all of these steps in a <code>sendLocation:</code> method that takes a <code>CLLocation</code> parameter.</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)sendLocation:(CLLocation *)location
{
    // build a static NSDateFormatter to display the current date in ISO-8601
    static NSDateFormatter *dateFormatter = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.dateFormat = @&quot;yyyy-MM-d'T'HH:mm:ssZZZZZ&quot;;
    });

    // send the message to the truck's topic
    NSString *destination = 
    [NSString stringWithFormat:@&quot;/topic/device.%@.location&quot;, self.deviceID];

    // build a dictionary containing all the information to send
    NSDictionary *dict = @{
        @&quot;deviceID&quot;: self.deviceID,
        @&quot;lat&quot;: [NSNumber numberWithDouble:location.coordinate.latitude],
        @&quot;lng&quot;: [NSNumber numberWithDouble:location.coordinate.longitude],
        @&quot;ts&quot;: [dateFormatter stringFromDate:location.timestamp]
    };
    // create a JSON string from this dictionary
       NSData *data = 
    [NSJSONSerialization dataWithJSONObject:dict 
    
    options:0
    
    error:nil];
       NSString *body =[[NSString alloc] 
   initWithData:data 
   
   encoding:NSUTF8StringEncoding];

    NSDictionary *headers = @{
        @&quot;content-type&quot;: @&quot;application/json;charset=utf-8&quot;
    };

    // send the message
    [self.client sendTo:destination
                headers:headers
                   body:body];
}</pre>

<p>The next step is to call this method every time we receive an updated location in the <code>locationManager:didUpdateToLocation:fromLocation:</code> method.</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30 seconds
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) &gt; 30) {
        return;
    }

    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@&quot;&phi;:%.4F, &lambda;:%.4F&quot;, coord.latitude, coord.longitude];

    // send a message with the location data
    [self sendLocation:newLocation];
}</pre>

<p>Messages will be sent every time the device location changes. This is a bit inconvenient during development, as I do not want to move around my workspace whenever I need to update my location and send a message.</p>

<p>To simplify the development process, we will add code to send the last known location when the user shakes the device.</p>

<p>We will need to add a <code>lastKnownLocation</code> property to the <code>MWMViewController</code> private interface and use it to store the location returned by the <code>CLLocationManager</code> delegate method:</p>

<pre data-code-language="objc" data-type="programlisting">
@interface MWMViewController () &lt;CLLocationManagerDelegate&gt;

...
@property (strong, nonatomic) CLLocation *lastKnownLocation;

@end

@implementation MWMViewController

...

#pragma mark - CLLocationManagerDelegate protocol

- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{

    ...

    // send a message with the location data
    [self sendLocation:newLocation];
    // store the location to send it again when user shakes the device
    self.lastKnownLocation = newLocation;
}</pre>

<p>To send a message with this <code>lastKnownLocation</code> when the user shakes the device, we must implement the <code>motionEnded:withEvent:</code> method in the <code>MWMViewController</code> implementation and check if the event is a motion shake (identified by <code>UIEventSubtypeMotionShake</code>):</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - User Events

- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event
{
    if (motion == UIEventSubtypeMotionShake) {
        NSLog(@&quot;device is shaked&quot;);
        if (self.lastKnownLocation) {
            [self sendLocation:self.lastKnownLocation];
        }
    }
}</pre>

<p>When we run the application, a STOMP message will be sent every time the location manager updates the device&rsquo;s location or when the user shakes the device.</p>

<p>How can we check that messages are effectively sent?</p>

<p>We will confirm it at three different stages:</p>

<ol>
	<li>
	<p>We will display the debug log on the device to check that messages are sent.</p>
	</li>
	<li>
	<p>Next, we'll use the ActiveMQ administration console to check that it effectively handled the sent messages.</p>
	</li>
	<li>
	<p>Finally, we will write the simplest STOMP consumer that can receive these messages.</p>
	</li>
</ol>

<section data-type="sect2" id="_display_code_stompkit_code_debug_log">
<h2>Display StompKit Debug Log</h2>

<p>Every time the StompKit library sends a message to a STOMP broker, it logs the STOMP frame that is sent.<a contenteditable="false" data-primary="StompKit" data-secondary="displaying debug log" data-type="indexterm">&nbsp;</a></p>

<p>To display them in the console, edit the file named <em>StompKit.m</em> in Xcode that is under the <em>Pods</em> project (its full path is Pods &rarr; Pods &rarr; StompKit &rarr; StompKit.m in the Project Navigator view) and change the macro to activate logs by replacing the <code>0</code> with <code>1</code>:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark Logging macros

#if 1 // set to 1 to enable logs

...</pre>

<p>If we restart the application, we now see debug statements in Xcode&rsquo;s Debug console:</p>

<pre data-type="programlisting">
2014-03-13 17:19:05.711 Locations[79549:60b] &gt;&gt;&gt; SEND
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.location
content-type:application/json;charset=utf-8
content-length:122

{&quot;lng&quot;:-122.03254905,&quot;deviceID&quot;:&quot;2262EC25-E9FD-4578-BADE-4E113DE45934&quot;,&quot;lat&quot;:37.33521504,&quot;ts&quot;:&quot;2014-03-13T17:19:05+01:00&quot;}
...</pre>

<p>This confirms that STOMP messages are effectively sent by the Locations application.</p>
</section>





<section data-type="sect2" id="_activemq_admin_console">
<h2>ActiveMQ Admin Console</h2>



<p>Go to the ActiveMQ admin console in your web browser at <a href="http://localhost:8161/hawtio"><em class="hyperlink">http://localhost:8161/hawtio</em></a> and navigate the ActiveMQ tree down to the position topic in mybroker &rarr; Topic &rarr; device.2262EC25-E9FD-4578-BADE-4E113DE45934.location.</p>

<p>In the righthand panel, select Attributes in the top menu to display all the attributes associated to this topic.</p>

<p>To check whether the broker is receiving the messages on this destination, check the Enqueue count attribute. It corresponds to the messages that have been <em>enqueued</em> (in other words, <em>sent</em>) to the destination. We see that this value is growing over time (it was at 113 when the screenshot in was captured). This confirms that the broker is actually receiving the messages sent by the mobile application.</p>

<figure id="img_mobile_stomp_16"><img alt="Check the number of messages sent to a destination in ActiveMQ admin console" src="images/mawm_0217.png" />
<figcaption>Check the number of messages sent to a destination in the ActiveMQ admin console</figcaption>
</figure>

<p>Another interesting attribute is Dequeue count. It corresponds to the messages removed from the topic and sent to consumers. In our case, it stays at <code>0</code> because there are no consumers subscribed to this destination.</p>
</section>




<section data-type="sect2" id="_a_simple_stomp_consumer">
<h2>A Simple STOMP Consumer</h2>

<p>When I presented STOMP, I wrote that the protocol is so simple that a telnet client <em>is</em> a STOMP client.<a contenteditable="false" data-primary="consumers" data-secondary="simple STOMP consumer" data-type="indexterm">&nbsp;</a></p>

<p>Let&rsquo;s prove this by writing the simplest STOMP client that will consume the messages sent by the application to the destination.</p>

<p>We need to open a telnet client to connect to the broker host on the <code>61613</code> port. I am on the same machine as the broker, so I will simply connect to <code>localhost</code>:</p>

<pre data-type="programlisting">
$ <strong><code>telnet localhost 61613</code></strong>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</pre>

<p>Once the client is connected, we must connect to the broker to open a STOMP connection (as we did in the application using <code>STOMPClient</code>'s <code>connectWithHeaders:completionHandler:</code> method).</p>

<pre data-type="programlisting">
<strong><code>CONNECT

</code></strong>^@
</pre>

<div data-type="caution">
<p>A STOMP frame must be ended with a NULL octet.</p>

<p><code>^@</code> is the ASCII character for a NULL octet. Type Ctrl + @ to enter it.</p>
</div>

<p>Note also that there is a blank line between the <code>CONNECT</code> line and the NULL octet. This blank line is mandatory to separate the command name and the headers from the beginning of the optional payload (which is not present in the <code>CONNECT</code> frame).</p>

<p>Once you type Ctrl + @, the messaging broker will process the <code>CONNECT</code> frame and reply with a <code>CONNECTED</code> frame:</p>

<pre data-type="programlisting">
CONNECTED
heart-beat:0,0
session:ID:jeff.local-63055-1391518653216-2:23
server:ActiveMQ/5.9.0
version:1.2
</pre>

<p>The STOMP connection is now established and the telnet client can now exchange messages with the broker. We are only interested in consuming messages sent by the application on the device&rsquo;s location topic. The device ID is displayed on the application screen. You will have to adapt the command to use your own device ID to receive its message:</p>

<pre data-type="programlisting">
SUBSCRIBE
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.location

^@</pre>

<p>After sending this command to the STOMP broker, we will immediately receive <code>MESSAGE</code> frames that correspond to the messages sent by the application:</p>

<pre data-type="programlisting">
MESSAGE
content-type:application/json;charset=utf-8
message-id:ID:jeff.local-50971-1394726830317-2:5:-1:1:323
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.location
timestamp:1394727930755
expires:0
content-length:122
priority:4

{&quot;lng&quot;:-122.12966111,&quot;deviceID&quot;:&quot;2262EC25-E9FD-4578-BADE-4E113DE45934&quot;,&quot;lat&quot;:37.36492641,&quot;ts&quot;:&quot;2014-03-13T17:25:30+01:00&quot;}</pre>

<div data-type="note">
<p>We can see that there are more headers in the consumed messages than in the messages we sent (which only had <code>content-type</code> and <code>content-length</code>). These headers are added by the STOMP broker and provide additional metadata about the messages. We will explore some of them later in <a data-type="xref" href="#ch_advanced_stomp">#ch_advanced_stomp</a> and <a data-type="xref" href="#ch_beyond_stomp">#ch_beyond_stomp</a>.</p>
</div>

<p>At this stage, we have a mobile application that is a STOMP <em>producer</em>. It broadcasts its position by sending messages to a STOMP destination.</p>
</section>
</section>

<section data-type="sect1" id="_display_the_text_messages">
<h1>Display the Text Messages</h1>

<p>We will now write the second part of the<a contenteditable="false" data-primary="messages" data-secondary="displaying text messages in STOMP Locations application (example)" data-type="indexterm">&nbsp;</a> Locations <a contenteditable="false" data-primary="text messages" data-secondary="displaying in STOMP mobile messaging application" data-type="indexterm">&nbsp;</a>application (which will <em>consume</em> STOMP messages containing some text and display them in a table).<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="displaying text messages" data-type="indexterm">&nbsp;</a></p>

<p>We will write the graphical part first by adding a <code>UITable</code> to the user interface.</p>

<p>Click on <em>Main.storyboard</em> to open it. From the Object library, drag a Table View on the View&rsquo;s window. Place it below the Current Position UILabel (see ).</p>

<figure id="img_mobile_stomp_162"><img alt="Add a Table View" src="images/mawm_0218.png" />
<figcaption>Add a Table View</figcaption>
</figure>

<p>From the Object library, drag a Table View Cell inside the Table View (see ).</p>

<figure id="img_mobile_stomp_17"><img alt="Add a Table View Cell" src="images/mawm_0219.png" />
<figcaption>Add a Table View Cell</figcaption>
</figure>

<p>We will change the Table View Cell properties by setting its Style to Basic and its Identifier to TextCell ().</p>

<figure id="img_mobile_stomp_18"><img alt="Edit the Table View Cell Properties" src="images/mawm_0220.png" />
<figcaption>Edit the Table View Cell properties</figcaption>
</figure>

<p>The <code>MWMViewController</code> interface will be declared as both the data source and delegate of the table. Open the <em>MWMViewController.m</em> file, make the <code>MWMViewController</code> interface conform to the <code>UITableViewDataSource</code> and <code>UITableViewDelegate</code> protocols and add an outlet property for the table.</p>

<pre data-code-language="objc" data-type="programlisting">
@interface MWMViewController () &lt;CLLocationManagerDelegate, UITableViewDataSource, UITableViewDelegate&gt;

@property (weak, nonatomic) IBOutlet UITableView *tableView;

@end</pre>

<p>We need to bind this outlet property to the table view. Open the <em>Main.storyboard</em> and Ctrl-click on View Controller to see its connection panel. Drag from Table View the table to connect it. See</p>
.

<figure id="img_mobile_stomp_182"><img alt="Connect the tableView outlet property to the Table View" src="images/mawm_0221.png" />
<figcaption>Connect the tableView outlet property to the Table View</figcaption>
</figure>

<p>We also need to connect the View Controller to the Table View and declare it as its dataSource and delegate.</p>

<p>Open the <em>Main.storyboard</em> and Ctrl-click on Table View to see its connection panel. Drag from dataSource to the View Controller to connect it ().</p>

<figure id="img_mobile_stomp_19"><img alt="Connect the Table View's dataSource to the View Controller" src="images/mawm_0222.png" />
<figcaption>Connect the Table View's dataSource to the View Controller</figcaption>
</figure>

<p>We do the same operation to connect the Table View's delegate property to the View Controller ().</p>

<figure id="img_mobile_stomp_20"><img alt="Connect the Table View's delegate to the View Controller" src="images/mawm_0223.png" />
<figcaption>Connect the Table View's delegate property to the View Controller</figcaption>
</figure>

<p>The graphical objects are now properly connected to the properties. The next step is to make the <code>MWMViewController</code> implementation comply with the <code>UITableViewDataSource</code> and <code>UITableViewDelegate</code> protocols.</p>

<p>The table will only display the received text messages. As there is no interaction with the table, we do not need to add any methods from the <code>UITableViewDelegate</code> protocol. Let&rsquo;s just add a comment to the <code>MWMViewController</code> implementation to remember this:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - UITableViewDelegate

// no delegate actions</pre>

<p>The controller is also the <code>dataSource</code> of the table. We will keep a list of the texts in memory in an array. Let&rsquo;s add a <code>texts</code> array to the <code>MWMViewController</code> implementation and instantiate it in its <code>viewDidLoad</code> method:</p>

<pre data-code-language="objc" data-type="programlisting">
@implementation MWMViewController

// the texts are stored in an array of NSString
NSMutableArray *texts;

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@&quot;Device identifier is %@&quot;, self.deviceID);

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];

    texts = [[NSMutableArray alloc] init];
}</pre>

<p>This <code>texts</code> array will be used as the source of data for the table. Let&rsquo;s implement the required <code>UITableViewDataSource</code> methods:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - UITableViewDataSource protocol

- (NSInteger)tableView:(UITableView *)tableView 
numberOfRowsInSection:(NSInteger)section
{
    return [texts count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // this identifier must be the same as the onethat was set in
    // the Table View Cell properties in the storyboard
    static NSString *CellIdentifier = @&quot;TextCell&quot;;

    UITableViewCell *cell = [tableView 
    dequeueReusableCellWithIdentifier:CellIdentifier];

    cell.textLabel.text = [texts objectAtIndex:indexPath.row];
    return cell;
}</pre>

<p>With these methods implemented, the table will display all the texts that are stored in the <code>texts</code> array.</p>
</section>

<section data-type="sect1" id="_receive_stomp_messages">
<h1>Receive STOMP Messages</h1>

<p>Now that we are ready to display the table, the next step is to subscribe to the device&rsquo;s text destination to consume<a contenteditable="false" data-primary="mobile messaging with STOMP" data-secondary="receiving STOMP messages" data-type="indexterm">&nbsp;</a> STOMP messages <a contenteditable="false" data-primary="messages" data-secondary="receiving STOMP messages" data-tertiary="Locations mobile application (example)" data-type="indexterm">&nbsp;</a>and store their text payload in the <code>texts</code> array.</p>

<p>To consume messages, a STOMP client must:</p>

<ol>
	<li>
	<p>Connect to the broker.</p>
	</li>
	<li>
	<p>Subscribe to the destination from which it wants to consume messages.</p>
	</li>
</ol>

<section data-type="sect2" id="ch_mobile_stomp_subscribe">
<h2>Subscribe to a STOMP Destination</h2>

<p>We already took care of the<a contenteditable="false" data-primary="publish/subscribe messaging model" data-secondary="subscribing to a STOMP destination" data-type="indexterm">&nbsp;</a> first step by <a contenteditable="false" data-primary="destinations" data-secondary="subscribing to a STOMP destination" data-type="indexterm">&nbsp;</a>calling <code>STOMPClient</code>'s <code>connectWithHeaders:completionHandler:</code> in <code>MWMViewController</code>'s <code>connect</code> method.</p>

<p>Step 2 is handled in StompKit<a contenteditable="false" data-primary="StompKit" data-secondary="calling STOMPClient's subscribeTo:headers:messageHandler: method" data-type="indexterm">&nbsp;</a> by calling <code>STOMPClient</code>'s <code>subscribeTo:headers:messageHandler:</code> method.</p>

<p>This method takes three parameters:</p>

<ul>
	<li>
	<p>The <code>destination</code> that the client wants to consume from. In our case, it is the destination <code>/queue/device.XXX.text</code> (we prepended the destination with the <code>/queue/</code> prefix according to the ActiveMQ naming convention).</p>
	</li>
	<li>
	<p>A dictionary of <code>headers</code> to pass additional metadata to the connection process. Because we do not have any such header for the time being, we will pass an empty dictionary.</p>
	</li>
	<li>
	<p>A <code>STOMPMessageHandler</code> block with a <code>STOMPMessage</code> parameter that will be called every time the broker sends a messages to the client to consume it. In our case, we just have to get the <code>NSString</code> text from the message <code>body</code> property and add it to the <code>texts</code> array.</p>
	</li>
</ul>

<p>We will add a method named <code>subscribe</code> to the <code>MWMViewController</code> implementation:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - Messaging

- (void)subscribe
{
    // subscribes to the device text queue:
    NSString *destination = [NSString stringWithFormat:@&quot;/queue/device
    .%@.text&quot;, self.deviceID];

    NSLog(@&quot;subscribing to %@&quot;, destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the destination
        NSLog(@&quot;received message %@&quot;, message);
        // the text is sent in a plain string; we use it as is
        NSString *text = message.body;
        NSLog(@&quot;adding text = %@&quot;, text);
        [texts addObject:text];
        // TODO reloads the table
    }];
}</pre>

<p><code>subscription</code> is an object returned by the <code>subscribe</code> method, which identifies the STOMP subscription and that can be used to <em>unsubscribe</em>.</p>

<p>We declare this object in the <code>MWMViewController</code>'s implementation:</p>

<pre data-code-language="objc" data-type="programlisting">
@implementation MWMViewController

STOMPSubscription *subscription;</pre>

<p>We need to call this <code>subscribe</code> method as soon as the client is connected to the STOMP broker. The correct location is inside the <code>completionHandler</code> block of the <code>connect</code> method that will be called when the client is <em>successfully</em> connected to the STOMP broker:</p>

<pre data-code-language="objc" data-type="programlisting">
#pragma mark - Messaging

- (void)connect
{
    NSLog(@&quot;Connecting...&quot;);
    [self.client connectWithHeaders:@
    { @&quot;client-id&quot;: self.deviceID}
                  completionHandler:^
    (STOMPFrame *connectedFrame, 
    NSError *error) {
                      if (error) {
                          // we have not been able to connect to the broker
                          // let's log the error
                          NSLog(@&quot;Error during connection: %@&quot;, error);
                      } else {
                          // we are connected to the STOMP broker 
                          // without an error
                          NSLog(@&quot;Connected&quot;);
                          [self subscribe];
                      }
                  }];
    // when the method returns, we cannot assume that the client is connected
}</pre>
</section>
</section>

<section data-type="sect1" id="_unsubscribe_from_the_destination">
<h1>Unsubscribe from the Destination</h1>

<p>The application will consume messages from the destination as long as it remains connected to the <a contenteditable="false" data-primary="publish/subscribe messaging model" data-secondary="unsubscribing from a STOMP destination" data-type="indexterm">&nbsp;</a>STOMP broker.<a contenteditable="false" data-primary="destinations" data-secondary="unsubscribing from a STOMP destination" data-type="indexterm">&nbsp;</a></p>

<p>We do not need to explicitly unsubscribe from the destination when we disconnect from the broker, but it is a good practice to do so. To unsubscribe, we just need to call the <code>unsubscribe</code> method on the <code>subscription</code> object that was created when we subscribed to the text destination. We will unsubscribe just prior to disconnecting from the broker in the <code>viewDidDisappear:</code> method:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [subscription unsubscribe];
    [self disconnect];
}</pre>
</section>

<section data-type="sect1" id="_finish_the_application">
<h1>Finish the Application</h1>

<p>The application is now ready to consume messages. Let&rsquo;s start it and check that it is working.</p>

<p>Run the application in the iOS simulator or on your device.<a contenteditable="false" data-primary="ActiveMQ" data-secondary="admin console" data-tertiary="sending a message via" data-type="indexterm">&nbsp;</a></p>

<p>Go to the ActiveMQ admin console and browse to the device text destination (in my case, its name is device.2262EC25-E9FD-4578-BADE-4E113DE45934.text) and click on the Send tab.</p>

<p>As illustrated in , fill the text area with a plain-text string (e.g., &quot;Hello, where are you?&quot;) and set the body format to Plain Text.</p>

<figure id="img_mobile_stomp_21"><img alt="Send a Message using ActiveMQ Admin Console" src="images/mawm_0224.png" />
<figcaption>Send a message using the ActiveMQ Admin Console</figcaption>
</figure>

<p>Click on the Send Message button to send the message on the destination.</p>

<p>We see in the application log that a STOMP message has been received and that the <code>text</code> was extracted from the message&rsquo;s body:</p>

<pre data-type="programlisting">
2014-03-14 14:24:19.807 Locations[86050:3903] received message MESSAGE
priority:0
destination:/queue/device.2262EC25-E9FD-4578-BADE-4E113DE45934.text
timestamp:1394803459806
message-id:ID\cjeff.local-53346-1394795959634-37\c1\c1\c1\c1
expires:0
subscription:sub-0

Hello, where are you?
2014-03-14 14:24:19.808 Locations[86050:3903] adding text = Hello, where are you?</pre>

<p>However, nothing is displayed in the application. We forgot to reload the table to display the received orders.</p>

<p>Let&rsquo;s fix that by calling <code>reloadData</code> on the <code>tableView</code> property from the <code>STOMPMessageHandler</code> block:</p>

<pre data-code-language="objc" data-type="programlisting">
- (void)subscribe
{
    // susbscribes to the device text queue:
    NSString *destination = [NSString stringWithFormat:@&quot;/queue/device.%@.text&quot;, self.deviceID];

    NSLog(@&quot;subscribing to %@&quot;, destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the destination
        NSLog(@&quot;received message %@&quot;, message);
        // the text is sent in a plain string; we use it as is
        NSString *text = message.body;
        NSLog(@&quot;adding text = %@&quot;, text);
        [texts addObject:text];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.tableView reloadData];
        });
    }];
}</pre>

<p>Note that we did not call directly <code>[self.tableView reloadData];</code> from the <code>STOMPMessageHandler</code> block.</p>

<p>StompKit uses Grand Central Dispatch&rsquo;s global queue to handle the communication between the client and the STOMP brokers. The <code>STOMPMessageHandler</code> block is called on that queue. However, any code that deals with <code>UIKit</code> (such as reloading the <code>tableView</code>) <em>must</em> be executed on the queue bound to the main thread. This is why we must wrap the <code>reloadData</code> call into a block executed on the main queue.</p>

<p>If we restart the application and send another message on the destination with the ActiveMQ admin console, the table will display the text as soon as it is received. See .</p>

<figure id="img_mobile_stomp_22"><img alt="The Received Text is Displayed in the Table" src="images/mawm_0225.png" />
<figcaption>The received text is displayed in the table</figcaption>
</figure>
</section>

<section data-type="sect1" id="_summary_2">
<h1>Summary</h1>

<p>In this chapter, we learned to use StompKit to send and receive STOMP messages from an iOS application.</p>

<p>To send a message, the application must do the following:</p>

<ol>
	<li>
	<p>Connect to the STOMP broker.</p>
	</li>
	<li>
	<p>Send the message to the destination.</p>
	</li>
</ol>

<p>To consume a message, the application must do the following:</p>

<ol>
	<li>
	<p>Connect to the STOMP broker.</p>
	</li>
	<li>
	<p>Subscribe to the destination and pass a block that is called every time a message is received. This block is executed on the Grand Central Dispatch global queue. If there is any code that changes the user interface, it must be wrapped in a block executed on the main queue.</p>
	</li>
</ol>

<p>We use two different types of message payloads:</p>

<ul>
	<li>
	<p>A JSON payload by using its string representation for the message body and specifying <code>application/json; charset=utf-8</code> in its <code>content-type</code> header</p>
	</li>
	<li>
	<p>A simple plain-text payload without any <code>content-type</code> header</p>
	</li>
</ul>

<p>Sending and consuming messages is only possible when the client is <em>successfully</em> connected to the STOMP broker. Due to the event-driven design of StompKit, this is the case <a contenteditable="false" data-primary="mobile messaging with STOMP" data-startref="mobmessSTOMP" data-type="indexterm">&nbsp;</a>when the <a contenteditable="false" data-primary="STOMP" data-secondary="mobile messaging with" data-startref="STOMPmobmess" data-type="indexterm">&nbsp;</a><code>completionHandler</code> block is executed without an error in <code>connectWithHeaders:completionHandler:</code>.</p>
</section>
</section>
