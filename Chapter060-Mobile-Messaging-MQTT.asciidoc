[[ch_mobile_mqtt]]
== Mobile Messaging With MQTT

[role="lead"]
In this chapter, we present MQTT, a binary-based protocol develop for telemetry
communication. Its simplicity and compactness make it ideally suited for mobile devices. We will write an iOS application using the +MQTTKit+ library to send and receive messages using the MQTT protocol.

In <<ch_introduction_mqtt_example>>, we described the +Motions+ application. In this chapter, we will write the iOS application that broadcast the device motion data and receive alert message.

[[img_mobile_mqtt_1]]
.Diagram of the +Motions+ iOS application
image::images/Chapter060/mqtt_ios_app.png["Diagram of the Motions+ iOS application"]

=== About the Code

All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +mqtt/ios/+ directory.

=== MQTT

MQTT only supports the _Publish/Subscribe_ messaging model.

=== +MQTTKit+

TODO

[[ch_mobile_mqtt_paho]]
=== Eclipse Paho MQTT Server

TODO

=== Create the +Motions+ project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +Locations+ iOS application.

Once Xcode is installed and started, we select +Create a new Xcode project+ from its launch screen. The application will be composed of a single view so we select the +Single View Application+ template in +iOs > Application+ from the template screen.

[[img_mobile_mqtt_1]]
.Select +Single View Application+ from the template screen.
image::images/Chapter060/template_screen.png["XCode template screen"]

We will call the project +Motions+ and select to build it only for iPhone devices.

[[img_mobile_mqtt_2]]
.XCode project options screen
image::images/Chapter060/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

We will again use CocoaPods to manage the project dependencies.

We close Xcode because CocoaPods will modify the project settings to import the dependencies.

we create a file named **`Podfile`** at the root of the project (in the same directory than +Motions.xcodeproj+).

[[ex_mobile_mqtt_1]]
.+Motions+'s Podfile
====
----
xcodepxcodeproj 'Motions.xcodeproj'

pod 'MQTTKit', :git => 'https://github.com/mobile-web-messaging/MQTTKit.git'

platform :ios, '5.0'
----
====

After saving this file, run the **`pod install`** command.

[[ex_mobile_mqtt_2]]
.Install +Motions+ dependencies
====
----
$ pod install
Analyzing dependencies
Pre-downloading: `MQTTKit` from `https://github.com/mobile-web-messaging/MQTTKit.git`
Downloading dependencies
Installing MQTTKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `Motions.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the _Workspace_ file named +Motions.xcworkspace+, and not the _Project_ file named +Motions.xcodeproj+.

[[img_mobile_mqtt_3]]
.Open the workspace file
image::images/Chapter060/open_workspace.png["Open the workspace file"]

First, we will verify that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting +Product > Destination > iPhone Retina (4-inch 64-bit)+ from Xcode menu bar.
If we run the application by selecting **`Product`** > **`Run`** (or pressing **`âŒ˜R`**), the iOS simulator starts and opens the application which is composed of a blank view. This confirms that the project and its dependencies are  successfully compiled and launched.

=== Identify the Device

This step is similar to the +Locations+ iOS application that is described in [[ch_mobile_stomp_deviceID]].

We will generate an unique identifier for the iOS device and display it in the view.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag a +Label+ on the +View+'s window. Place it at the top of the view and change the text to +Device ID+.

[[img_mobile_mqtt_4]]
.Add the Device ID label.
image::images/Chapter060/deviceID_label.png[Add the Device ID label]

We will again change its +Font+ to +System 13.0+ and its +Alignment+ to centered to fit the screen.

This label will be connected to a +deviceIDLabel+ outlet property defined in the +MWMViewController+ private interface in +MWMViewController.m+ file.
We also add a +deviceID+ string to store the device identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +deviceIDLabel+ to the +UILabel+ to connect it.

[[img_mobile_mqtt_5]]
.Connect the +deviceIDLabel+ outlet property to the device ID +UILabel+.
image::images/Chapter060/deviceIDLabel_connection.png[Connect the deviceIDLabel outlet property to the device ID UILabel]

The device identifier is generated in the +MWMViewController+ implementation when the view is loaded and stored in the +deviceID+ property. We also set the +deviceIDLabel+'s +text+ to this identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;
}
----

=== Display the Device Motions Values

The device motion will be identified using their _pitch_, _roll_ and _yaw_ values.
To have some graphical feedback as we move the device, we will add three +UILabel+ that shows these three values.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag three +Labels+ on the +View+'s window below the Device ID label. Change their respective text to +pitch+, +roll+, and +yaw+.

[[img_mobile_mqtt_6]]
.Add three labels to display the device's pitch, roll and yaw values.
image::images/Chapter060/motions_labels.png["Add three labels to display the device's pitch, roll and yaw values."]

We create three outlet properties in the +MWMViewController+ private interface for these labels.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;
@property (weak, nonatomic) IBOutlet UILabel *pitchLabel;
@property (weak, nonatomic) IBOutlet UILabel *rollLabel;
@property (weak, nonatomic) IBOutlet UILabel *yawLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Next step is to the connect the three labels in the +Main.storyboard+ to these three outlet properties.

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from its +pitchLabel+ property to the corresponding pitch +UILabel+ to connect it.

[[img_mobile_mqtt_7]]
.Connect the +pitchLabel+ outlet property to the pitch +UILabel+.
image::images/Chapter060/pitchLabel_connection.png[Connect the pitchLabel outlet property to the pitch UILabel]

Repeat this operation for the +rollLabel+ and +yawLabel+ to connect them.

At this stage, the graphical objects are connected and we can capture the device motion to update these labels and then broadcast the motion data using MQTT.

=== Capture the Device Motions with +CoreMotion+ Framework

iOS provides the +CoreMotion+ framework to capture the motion of the devices.

We need to add it to the libraries linked by the application. Click on the +Motions+ project and then the +Motions+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreMotion`**, select the +CoreMotion.framework+ and click on the +Add+ button.

.Add the +CoreMotion+ framework.
image::images/Chapter060/CoreMotion_framework.png["Add the CoreMotion framework"]

We can now use the +CoreMotion+ framework by importing +<CoreMotion/CoreMotion.h>+ at the top of the +MWMViewController.m+ file.

We will also define a +motionManager+ property in +MWMViewController+ private interface to use +CoreMotion+.

[source,objc]
----
#import <CoreMotion/CoreMotion.h>

@interface MWMViewController ()

@property (strong, nonatomic) CMMotionManager *motionManager;

@end
----

This +motionManager+ is used to capture the device motions. We must create a new +CMMotionManager+, specify the interval of update and call its +startDeviceMotionUpdatesToQueue:withHandler:+ method to get the device motion
periodically in a block. We create a new +NSOperationQueue+ to receive these updates on this queue.

The device motion is represented by a +CMDeviceMotion+ object. In our example, we are interested only by its +attitude+ property that contains the +pitch+, +roll+ and +yaw+ value we want to broadcast.

Since the block to receive motion update is executed on the +NSOperationQueue+ we have created, we can not update the +UILabel+ from it. We must instead create another block and call +dispatch_async+ to execute the graphical changes on the UI main queue (that is retrieved by calling +dispatch_get_main_queue()+).

All this logic can be written in +viewDidLoad+ so that the motion manager will start receiving updates when the view is loaded.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // get the device motion updates every second.
    self.motionManager.deviceMotionUpdateInterval = 1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.1f", attitude.pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.1f", attitude.roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.1f", attitude.yaw];
            });
        }
    }];
}
----

We also need to notify the +motionManager+ that we no longer want to receive updates when the view is no longer used. We need to call its +stopDeviceMotionUpdates+ method inside the view controller's +dealloc+ method.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
}
----

At this stage, if you run the +Motions+ application on your iPhone and move it, the pitch, roll, and yaw labels will be updated to reflect the changes in the device motions.

[[img_mobile_mqtt_8]]
.The motion values change when the device moves.
image::images/Chapter060/app.png["The motion values change when the device moves."]

[NOTE]
====
The +iOS Simulator+ is not able to simulate device motions. If you run the +Motions+ applicatio in the simulator, the +motionManager+ will not send any device motions updates. At the time of writing this book, the only way to test this code is to run the application on a real iOS device.
====

We now capture the device motions and display them. Next step is to broadcast them by sending MQTT messages.

[[ch_mobile_mqtt_client]]
=== Create a MQTT Client With MQTTKit

To send and receive message with MQTT, we must first import the +MQTTKit+ library that was added to the project using CocoaPods at the beginning of this chapter.

We must import its header file +MQTTKit.h+ at the top of the +MWMViewController.m+ file and add a +MQTTClient+ property named +client+ to the +MWMViewController+ private interface.

We also define a constant to represent the hostname of the MQTT broker we are using +iot.eclipse.org+.

[source,objc]
----
#import <MQTTKit/MQTTKit.h>

#define kMqttHost @"iot.eclipse.org"

@interface MWMViewController ()

@property (strong, nonatomic) MQTTClient *client;

@end
----

We will create a new +MQTTClient+ object in the +MWMViewController+'s +viewDidLoad+ method.
A +MQTTClient+ must be uniquely identified for the MQTT brokers it connects to.
We can use the +deviceID+ as its client identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    [self connect];
}
----

=== Connect to a MQTT Broker

A +MQTTKit+ client will connect to the MQTT Broker when its +connectToHost:completionHandler:+ method is called.
Since +MQTTKit+ is event-driven, the client will be *effectively* connected when its completionHandler block is called and the return code is +MQTTConnectionReturnCode+ is equal to +ConnectionAccepted+.

You can not assume that the client is connected when the +connectToHost:completionHandler:+ method returns. Any actions that requires the client to be connected must happen inside the +completionHandler+ block.

We will encapsulate this code in a +connect+ method.

[source,objc]
----
#pragma mark - MQTTKit Actions

- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}
----

We will call this method from +viewDidLoad+ to connect to the MQTT broker as soon as the view is loaded.


[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];

    [queue addOperationWithBlock:^{
        [self connect];
    }];
}
----

We will use the +queue+ that was created for the +motionManager+ udpates to run the +connect+ method. This ensures that no network operation will slow down the UI (since +viewDidLoad+ is running on the main queue).

=== Disconnect from a MQTT Broker

The +client+ can disconnect from the MQTT broker by calling its +disconnectWithCompletionHandler:+ method.

The +completionHandler+ block as a +code+ parameter that will be +0+ if the disconnection was successful.

[source,objc]
----
- (void)disconnect
{
    [self.client disconnectWithCompletionHandler:^(NSUInteger code) {
        if (code == 0) {
            NSLog(@"disconnected from the MQTT broker");
        } else {
            NSLog(@"disconnected unexpectedly...");
        }
    }];
}

----

We want to disconnect from the MQTT broker when the +MWMViewController+ is no longer used. We will call the +disconnect+ method from +dealloc+.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self disconnect];
}
----

=== Send MQTT Messages

The +MWMViewController+ automatically connects to the MQTT broker when its view is loaded and disconnects when it is deallocated.
Next step is to send messages every time the device motion values are updated.

The MQTT protocol is a binary protocol. The message payload must be encoded as binary data to be sent.
The +MQTTKit+ library provides two methods to send messages:

* The +publishData:toTopic:withQos:retain:+ method expects a +NSData+ object as the message payload and its +bytes+ will be used.
* The +publishString:toTopic:withQos:retain:+ method can also be used for the common case of sending a text message. Internally, the +NSString+ that is passed in parameter is encoded as a +NSData+ using the UTF-8 encoding.

In the +Motions+ iOS application, we send a message with a binary payload composed of three 64-bit floats for the +pitch+, +roll+, and +yaw+ values contained in a +CMAttitude+ object. We will build the payload's +NSData+ by converting the double values to a platform-independent format using the +CFConvertDoubleHostToSwapped+ function.

The other three parametes to the +publish...+ methods are the same for both the binary and text payload version.

The +topic+ parameter is the name of the topic to send the message.
According to <<ch_introduction_mqtt_example_topology>>, the name of the topic is +/mwm/XXX/motion+ where XXX is the device identifier.

The +qos+ parameter to the _Quality of Service_ (or QoS) to use to deliver the messages to the consumers.

==== Quality Of Service

The MQTT protocol defines three levels of Quality of Service:

* At Most Once (wit the value +0+ represented by +AtMostOnce+ in +MQTTKit+)
* At Least Once (wit the value +1+ represented by +AtLeastOnce+ in +MQTTKit+)
* Exactly Once (wit the value +2+ represented by +ExactlyOnce+ in +MQTTKit+)

These levels of QoS determines the guarantee that the MQTT broker will accept to deliver a message.
With +At Most Once+, the MQTT broker guarantees that the published message will be delivered at most once to its consumers. This means that the consumers may not receive the message at all. If an error (either a network failure or a crash) occurs while the message is sent to the broker, it is possible that it will be lost and the consumers will never receive it.

With +At Least Once+, the MQTT broker guarantees that the published message will be delivered at least once to the consumers. This also means that a consumer may receive the same message twice. If there is any error when the producer sends the message to the broker and did not receive an acknowledgement that its message has been received, it will resend it as second time as a _duplicate_ (the MQTT message will have a +DUP+ bit set). When the broker receives this duplicate message it will redeliver it to the consumer but it is possible that they in fact received the original message. The consumer may need to check if the +DUP+ bit is set on the delivered message to know whether it is an original message (and it must process it) or a duplicate (and it can discard it)

The +At Least Once+ QoS offers the guarantee that no published message will be lost but at the cost of performance and additional code on the consumer side.
The performance cost is caused by the additional message (a +PUBACK+ message) sent from the broker to the client to acknowledge that it has received the published message. That means that using this QoS level to publish +N+ messages will involve exchanging +2*N+ messages between the producer and the broker.

The highest level of delivery is provided using the +Exactly Once+ QoS. With that level, the MQTT broker guarantees that the published message will be delivered _exactly_ once by the consumers. There will be no lost messages or duplicate messages. This is guaranteed by additional exchange of messages between the producer and broker (+PUBREC+, +PUBREL+, +PUBCOMP+ messages).
That means that using this QoS level to publish +N+ messages will involve exchanging +4*N+ messages, requires four times more network trips that the lowest level of QoS of +At Most Once+ and twice the +At Least Once+.

Choosing the correct QoS depends on the type of message exchanged and the _importance_ of its payload.
In the +Motions+ iOS application, the published message contains device motion that are updated every second. It is acceptable if a published message is _lost_ because an new message with updated content will be sent just one second after. Using the +AtMostOnce+ QoS is the best choice for this type of message.

==== Retain

The final parameter of the +publish...+ methods is a boolean to specify whether the published message must be _retained_ by the topic.

If this flag is set on the message, the broker will deliver the message to its subscribers and keep holding the message. If a new consumer subscribes to this topic, the broker will deliver the retained message to it. This is useful as the new subscriber will not have to wait for a publisher to send a message to receive new data. The retained message contains the _Last Known Good_ value.

If our case, we will publish messages with _retain_ set to +YES+. If consumers subscribes to the device motion topic *after* the device stops updated its motion values, they will still be able to use the last know device motion value.
This example is a bit of a stretch. A more interesting example would be an application broadcasting its location (similar to the +Locations+ application). Using retained message would allow the consumers to know the last know position of the device before it stops broadcasting its position.

To sum up, the +Motions+ application will send a message:

* with a binary payload composed of three 64-bits floats for the device's +pitch+, +roll+, and +yaw+ values
* to the device motion topic +/mwm/XXX/motion+ where +XXX+ is the device identifier
* with a QoS ot +AtMostOnce+ since we accept that a published message may not be delivered
* with +retain+ set to +YES+ so that the broker will retain the Last Known Good message to deliver it to new subscribers.

We will encapsulate this code in a +send:+ method taking a +CMAttitude+ parameter.

[source,objc]
----
- (void)send:(CMAttitude *)attitude
{
    uint64_t values[3] = {
        CFConvertDoubleHostToSwapped(attitude.pitch).v,
        CFConvertDoubleHostToSwapped(attitude.roll).v,
        CFConvertDoubleHostToSwapped(attitude.yaw).v
    };
    NSData *data = [NSData dataWithBytes:&values length:sizeof(values)];
    NSString *topic =[NSString stringWithFormat:@"/mwm/%@/motion", self.deviceID];
    [self.client publishData:data
                     toTopic:topic
                     withQos:AtMostOnce
                      retain:NO
           completionHandler:nil];
}
----

Finally, last step is to call this method every time a device motion value is updated by the +motionManger+. This occurs in the +viewDidLoad+ method inside the +handler+ block passed to the +motionManger+'s +startDeviceMotionUpdatesToQueue:withHandler:+ method.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // use a frequency of circa 10Hz to get the device motion updates
    self.motionManager.deviceMotionUpdateInterval = 0.1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.1f", attitude.pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.1f", attitude.roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.1f", attitude.yaw];
            });
            // send the MQTT message
            [self send:attitude];
        }
    }];

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
}
----

Note that we do not send the message from the main queue that is used by UI code. Sending a MQTT message can be done from any queue, so we call it directly from the handler that is running on the +queue+ that was passed to the +startDeviceMotionUpdatesToQueue:withHander:+ method.

[[ch_mobile_mqtt_receive]]
=== Receive MQTT Messages

As described in <<ch_introduction_mqtt_example>>, the +Motions+ iOS application is also a consumer from the topic +/mwm/XXX/alert+. When it receives a message from this topic, it must change its background color to "alert" the user.

Let's write the method that aler the user by changing the background color first. This +warnUser:+ method takes a +NSString+ parameter that should correspond to a color. Using +UIKit+ animations, we will:

. animate the controller's view to change its background color from its original color to the one created from the +NSString+ parameter
. we wait two seconds after the first animation is completed to revert back to the original background color.

[source,objc]
----
# pragma mark - UI Actions

// Warn the user by changing the view's background color to the specified color during 2 seconds
- (void)warnUser:(NSString *)colorStr
{
    // keep a reference to the original color
    UIColor *originalColor = self.view.backgroundColor;

    [UIView animateWithDuration:0.5
                          delay:0.0
                        options:0
                     animations:^{
                         // change it to the color passed in parameter
                         SEL sel = NSSelectorFromString([NSString stringWithFormat:@"%@Color", colorStr]);
                         UIColor* color = nil;
                         if ([UIColor respondsToSelector:sel]) {
                             color  = [UIColor performSelector:sel];
                         } else {
                             color = [UIColor redColor];
                         }
                         self.view.backgroundColor = color;
                     }
                completion:^(BOOL finished) {
                         // after a delay of 2 seconds, revert it to the original color
                         [UIView animateWithDuration:0.5
                                               delay:2
                                             options:0
                                          animations:^{
                                              self.view.backgroundColor = originalColor;
                                          }
                                          completion:nil];
                     }];
}
----

To consumer messages from a MQTT broker, the +client+ must:

. subscribe to its topic of interest
. set its +messageHandler+ property that will be called every time a message is delivered.

Note that you can subscribe to many topics from the client but it has only one +messageHandler+ property. If the client is subscribed to different topics, its +messageHandler+ must determine which topic the message is consumed from.

==== Subscription

The +Motions+ application will subscribe to its device alert topic +/mwm/XXX/alert+ by calling the method +subscribe:withQos:completionHandler:+ on its +client+ property.

The first parameter is the device alert topic. We will define it at the top of the +MWMViewController.m+ file.

[source,objc]
----
#define kAlertTopic @"/mwm/%@/alert"
----

The +subscribe:withQos:completionHandler:+ method takes a +qos+ that correspond to the quality of service that the consumer is requesting for message delivered from the topic.

The completion handler will be called when the client is effectively subscribed to the topic. The handler has a +grantedQos+ parameter that corresponds to the effective quality of service. The producer is responsible for determining the maximum quality of service that a message can be delivered at but the consumer can decide to _downgrade_ the quality of service according to its usage.
For example, a producer may publish a message with a QoS of +ExactlyOnce+ but a consumer may decide that it is acceptable for it if there are message duplicates and downgrade its QoS to +At Least Once+.

In our case, we will request to have message delivered with a +qos+ set to +AtLeastOnce+ as we do not want to lose messages but can accept duplicate messages.

[source,objc]
----
- (void)subscribe
{
    NSString *topic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.client subscribe:topic withQos:AtLeastOnce completionHandler:^(NSArray *grantedQos) {
        NSLog(@"subscribed to %@ with QoS %@", topic, grantedQos);
    }];
}
----

TODO








We need to call this method every time a message is received from the device's alert topic.

[source,objc]
----
#pragma mark - MQTTClientDelegate

- (void)client:(MQTTClient *)client didReceiveMessage:(MQTTMessage *)message
{
    NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    if ([alertTopic isEqualToString:message.topic]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self warnUser:message.payloadString];
        });
    }
}
----

TODO



TODO



TODO

[source,objc]
----
#pragma mark - MQTTClientDelegate

- (void)client:(MQTTClient *)client
    didConnect:(NSUInteger)code
{
    // once connect, subscribe to the client's alerts topic
    [self subscribe];
}
----

=== Unsubscribe From the Topic

TODO

[source,objc]
----
- (void)unsubscribe
{
    NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.mqttClient unsubscribe:alertTopic];
}
----

TODO

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self unsubscribe];
    [self disconnect];
}
----

=== Summary

TODO
