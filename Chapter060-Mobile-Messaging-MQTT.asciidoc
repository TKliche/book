[[part_mqtt]]
= MQTT

[partintro]
--
MQTT is a simple and lightweight messaging protocol that only supports the _Publish/Subscribe_ messaging model.

This book covers the latest released version of the protocol at the time of this writing: MQTT 3.1 <<mqttv3.1>>.

Its most interesting features are its compactness (reducing bandwidth and memory usage) and its small set of features (making it simple to implement on various platforms)

MQTT is a simple protocol well suited for a limited set of applications that can be modeled using Publish/Subscribe. However, MQTT is also lacking flexibility and you have to consider carefully if it meets your requirements.

One missing feature of MQTT is the lack of headers in the message representation.

MQTT defines a fixed set of headers for its command messages (used to connect to the broker, send a message, create a subscription, etc.) but there is no general notions of a header that the application or the broker could add to the messages.

This significantely reduces the usefulness of the messages that are delivered by MQTT. As a simple example, the absence of headers mean that there is no way to know what type of data to expect from the payload. HTTP and STOMP defines a +content-type+ header that can be queried to know the MIME type of the payload and extract it accordingly. MQTT does not allow this and the consumer must have _a priori_ knowledge of the payload type for a message before being able to read it.

The absence of headers also imply tha the MQTT broker can not provide additional features not covered by the protocol in a non-intrusive way. As we saw in <<ch_beyond_stomp>>, STOMP broker can use headers to priority, expiration, and other features just by adding headers to the messages.

If you plan to use MQTT in your applications, you should consider carefully whether its features match your requirements.

If you require features that are not provided by the protocol (or another messaging model than _Publish/Subscribe_), you may lose all the benefits of using this simple protocol and write brittle code that puts all the complexity in your applications instead of relying on the broker's set of features.
But if your requirements are fullfilled by MQTT features (as is the case for a lot of applications), you will be all set to use messaging in your applications.

.Eclipse public MQTT Server
[NOTE]
====
For the MQTT +Motions+ application, we will not run a MQTT broker on our local network but use instead a public MQTT broker hosted by http://iot.eclipse.org/sandbox.html#mqtt[iot.eclipse.org], the portal for Internet of Things development of the Eclipse foundation. This public broker is running using the Mosquitto project (the same codebase underneath MQTT) and any MQTT client can connect to it. While it is not appropriate to use it for production (there is no uptime guarantee for it), it shows that it is possible to use MQTT on Internet.

MQTT clients can connect to it using the +iot.eclipse.org+ hostname on the port +1883+ (that is reserved for MQTT).
====
--

[[ch_mobile_mqtt]]
== Mobile Messaging With MQTT

[role="lead"]
In this chapter, We will write an iOS application using the +MQTTKit+ library to send and receive messages using the MQTT protocol.

In <<ch_introduction_mqtt_example>>, we described the +Motions+ application. In this chapter, we will write the iOS application that broadcasts the device motion data and receives alert message.

[[img_mobile_mqtt_1]]
.Diagram of the +Motions+ iOS application
image::images/Chapter060/mqtt_ios_app.png["Diagram of the Motions+ iOS application"]

.About the Code
[NOTE]
====
All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +mqtt/ios/+ directory.
====

=== +MQTTKit+

This book uses the MQTTKit library for iOS (and Mac OS X) applications. It is a modern Objective-C library that uses ARC and blocks to write messaging clients in a simple fashion. It is based on the http://mosquitto.org[Mosquitto] project that provides a lower-level C implementation of MQTT.

The source code of this library project is hosted on https://github.com/mobile-web-messaging/MQTTKit[GitHub].

=== Create the +Motions+ project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +Locations+ iOS application.

Once Xcode is installed and started, we select +Create a new Xcode project+ from its launch screen. The application will be composed of a single view so we select the +Single View Application+ template in +iOS > Application+ from the template screen.

[[img_mobile_mqtt_1]]
.Select +Single View Application+ from the template screen.
image::images/Chapter060/template_screen.png["XCode template screen"]

We will call the project +Motions+ and select to build it only for iPhone devices.

[[img_mobile_mqtt_2]]
.XCode project options screen
image::images/Chapter060/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

We will again use CocoaPods to manage the project dependencies (as explained in <<ch_mobile_stomp_cocoapods>> for the STOMP example).

We close Xcode because CocoaPods will modify the project settings to import the dependencies.

We create a file named **`Podfile`** at the root of the project (in the same directory as +Motions.xcodeproj+).

[[ex_mobile_mqtt_1]]
.+Motions+'s Podfile
====
----
xcodeproj 'Motions.xcodeproj'

pod 'MQTTKit', :git => 'https://github.com/mobile-web-messaging/MQTTKit.git'

platform :ios, '5.0'
----
====

After saving this file, run the **`pod install`** command.

[[ex_mobile_mqtt_2]]
.Install +Motions+ dependencies
====
----
$ pod install
Analyzing dependencies
Pre-downloading: `MQTTKit` from `https://github.com/mobile-web-messaging/MQTTKit.git`
Downloading dependencies
Installing MQTTKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `Motions.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the _Workspace_ file named +Motions.xcworkspace+, and not the _Project_ file named +Motions.xcodeproj+.

[[img_mobile_mqtt_3]]
.Open the workspace file
image::images/Chapter060/open_workspace.png["Open the workspace file"]

First, we will verify that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting +Product > Destination > iPhone Retina (4-inch 64-bit)+ from Xcode menubar.

++++
<remark>
Command symbol is not displayed in PDF.
</remark>
++++

If we run the application by selecting **`Product`** > **`Run`** (or pressing   +&#x2318;+R+), the iOS simulator starts and opens the application which is composed of a blank view. This confirms that the project and its dependencies are  successfully compiled and launched.

=== Identify the Device

This step is similar to the +Locations+ iOS application that is described in <<ch_mobile_stomp_deviceID>>.

We will generate an unique identifier for the iOS device and display it in the view.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag a +Label+ on the +View+'s window. Place it at the top of the view and change the text to +Device ID+.

[[img_mobile_mqtt_4]]
.Add the Device ID label.
image::images/Chapter060/deviceID_label.png[Add the Device ID label]

We will again change its +Font+ to +System 13.0+ and its +Alignment+ to centered to fit the screen.

This label will be connected to a +deviceIDLabel+ outlet property defined in the +MWMViewController+ private interface in +MWMViewController.m+ file.
We also add a +deviceID+ string to store the device identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +deviceIDLabel+ to the +UILabel+ to connect it.

[[img_mobile_mqtt_5]]
.Connect the +deviceIDLabel+ outlet property to the device ID +UILabel+.
image::images/Chapter060/deviceIDLabel_connection.png[Connect the deviceIDLabel outlet property to the device ID UILabel]

The device identifier is generated in the +MWMViewController+ implementation when the view is loaded and stored in the +deviceID+ property. We also set the +deviceIDLabel+'s +text+ to this identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;
}
----

=== Display the Device Motions Values

The device motion will be identified using the _pitch_, _roll_ and _yaw_ values.
To have some graphical feedback as we move the device, we will add three +UILabel+ that shows these three values.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag three +Labels+ on the +View+'s window below the Device ID label. Change their respective text to +pitch+, +roll+, and +yaw+.

[[img_mobile_mqtt_6]]
.Add three labels to display the device's pitch, roll and yaw values.
image::images/Chapter060/motions_labels.png["Add three labels to display the device's pitch, roll and yaw values."]

We create three outlet properties in the +MWMViewController+ private interface for these labels.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;
@property (weak, nonatomic) IBOutlet UILabel *pitchLabel;
@property (weak, nonatomic) IBOutlet UILabel *rollLabel;
@property (weak, nonatomic) IBOutlet UILabel *yawLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Next step is to the connect the three labels in the +Main.storyboard+ to these three outlet properties.

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from its +pitchLabel+ property to the corresponding pitch +UILabel+ to connect it.

[[img_mobile_mqtt_7]]
.Connect the +pitchLabel+ outlet property to the pitch +UILabel+.
image::images/Chapter060/pitchLabel_connection.png[Connect the pitchLabel outlet property to the pitch UILabel]

Repeat this operation for the +rollLabel+ and +yawLabel+ to connect them.

At this stage, the graphical objects are connected and we can capture the device motion to update these labels and then broadcast the motion data using MQTT.

=== Capture the Device Motions with +CoreMotion+ Framework

iOS provides the +CoreMotion+ framework to capture the motion of the devices.

We need to add it to the libraries linked by the application. Click on the +Motions+ project and then the +Motions+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreMotion`**, select the +CoreMotion.framework+ and click on the +Add+ button.

.Add the +CoreMotion+ framework.
image::images/Chapter060/CoreMotion_framework.png["Add the CoreMotion framework"]

We can now use the +CoreMotion+ framework by importing +<CoreMotion/CoreMotion.h>+ at the top of the +MWMViewController.m+ file.

We will also define a +motionManager+ property in +MWMViewController+ private interface to use +CoreMotion+.

[source,objc]
----
#import <CoreMotion/CoreMotion.h>

@interface MWMViewController ()

@property (strong, nonatomic) CMMotionManager *motionManager;

@end
----

This +motionManager+ is used to capture the device motions. We must create a new +CMMotionManager+, specify the interval of update and call its +startDeviceMotionUpdatesToQueue:withHandler:+ method to get the device motion
periodically in a block. We create a new +NSOperationQueue+ to receive these updates on this queue.

The device motion is represented by a +CMDeviceMotion+ object. In our example, we are interested only by its +attitude+ property that contains the +pitch+, +roll+ and +yaw+ value we want to broadcast. Their values are expressed in radians, so we will convert them in degrees to display them.

Since the block to receive motion update is executed on the +NSOperationQueue+ we have created, we can not update the +UILabel+ from it. We must instead create another block and call +dispatch_async+ to execute the graphical changes on the UI main queue (that is retrieved by calling +dispatch_get_main_queue()+).

All this logic can be written in +viewDidLoad+ so that the motion manager will start receiving updates when the view is loaded.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // get the device motion updates every second.
    self.motionManager.deviceMotionUpdateInterval = 1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue
                                            withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                // convert values from radians to degrees
                double pitch = attitude.pitch * 180 / M_PI;
                double roll = attitude.roll * 180 / M_PI;
                double yaw = attitude.yaw * 180 / M_PI;
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.0f°", pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.0f°", roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.0f°", yaw];
            });
        }
    }];
}
----

We also need to notify the +motionManager+ that we no longer want to receive updates when the view is no longer used. We need to call its +stopDeviceMotionUpdates+ method inside the view controller's +dealloc+ method.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
}
----

At this stage, if you run the +Motions+ application on your iPhone and move it, the pitch, roll, and yaw labels will be updated to reflect the changes in the device motions.

[[img_mobile_mqtt_8]]
.The motion values change when the device moves.
image::images/Chapter060/app.png["The motion values change when the device moves."]

[NOTE]
====
The +iOS Simulator+ is not able to simulate device motions. If you run the +Motions+ application in the simulator, the +motionManager+ will not send any device motions updates. At the time of writing this book, the only way to test this code is to run the application on a real iOS device.
====

We now capture the device motions and display them. Next step is to broadcast them by sending MQTT messages.

[[ch_mobile_mqtt_client]]
=== Create a MQTT Client With MQTTKit

To send and receive message with MQTT, we must first import the +MQTTKit+ library that was added to the project using CocoaPods at the beginning of this chapter.

We must import its header file +MQTTKit.h+ at the top of the +MWMViewController.m+ file and add a +MQTTClient+ property named +client+ to the +MWMViewController+ private interface.

We also define a constant to represent the hostname of the MQTT broker we are using +iot.eclipse.org+.

[source,objc]
----
#import <MQTTKit/MQTTKit.h>

#define kMqttHost @"iot.eclipse.org"

@interface MWMViewController ()

@property (strong, nonatomic) MQTTClient *client;

@end
----

We will create a new +MQTTClient+ object in the +MWMViewController+'s +viewDidLoad+ method.
A +MQTTClient+ must be uniquely identified for the MQTT brokers it connects to.
We can use the +deviceID+ as its client identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
}
----

=== Connect to a MQTT Broker

A +MQTTKit+ client will connect to the MQTT Broker when its +connectToHost:completionHandler:+ method is called.
Since +MQTTKit+ is event-driven, the client will be *effectively* connected when its completionHandler block is called and the return code is +MQTTConnectionReturnCode+ is equal to +ConnectionAccepted+.

You can not assume that the client is connected when the +connectToHost:completionHandler:+ method returns. Any actions that requires the client to be connected must happen inside the +completionHandler+ block.

We will encapsulate this code in a +connect+ method.

[source,objc]
----
#pragma mark - MQTTKit Actions

- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}
----

We will call this method from +viewDidLoad+ to connect to the MQTT broker as soon as the view is loaded.


[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    [self connect];
}
----

=== Disconnect from a MQTT Broker

The +client+ can disconnect from the MQTT broker by calling its +disconnectWithCompletionHandler:+ method.

The +completionHandler+ block as a +code+ parameter that will be +0+ if the disconnection was successful.

[source,objc]
----
- (void)disconnect
{
    [self.client disconnectWithCompletionHandler:^(NSUInteger code) {
        if (code == 0) {
            NSLog(@"disconnected from the MQTT broker");
        } else {
            NSLog(@"disconnected unexpectedly...");
        }
    }];
}

----

We want to disconnect from the MQTT broker when the +MWMViewController+ is no longer used. We will call the +disconnect+ method from +dealloc+.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self disconnect];
}
----

=== Send MQTT Messages

The +MWMViewController+ automatically connects to the MQTT broker when its view is loaded and disconnects when it is deallocated.
Next step is to send messages every time the device motion values are updated.

The MQTT protocol is a binary protocol. The message payload must be encoded as binary data to be sent.
The +MQTTKit+ library provides two methods to send messages:

* The +publishData:toTopic:withQos:retain:+ method expects a +NSData+ object as the message payload and its +bytes+ will be used.
* The +publishString:toTopic:withQos:retain:+ method can also be used for the common case of sending a text message. Internally, the +NSString+ that is passed in parameter is encoded as a +NSData+ using the UTF-8 encoding.

In the +Motions+ iOS application, we send a message with a binary payload composed of three 64-bit floats for the +pitch+, +roll+, and +yaw+ values contained in a +CMAttitude+ object. We will build the payload's +NSData+ by converting the double values to a platform-independent format using the +CFConvertDoubleHostToSwapped+ function.

The other three parametes to the +publish...+ methods are the same for both the binary and text payload version.

The +topic+ parameter is the name of the topic to send the message.
According to <<ch_introduction_mqtt_example_topology>>, the name of the topic is +/mwm/XXX/motion+ where XXX is the device identifier.

The +qos+ parameter corresponds to the _Quality of Service_ (or QoS) to use to deliver the messages to the consumers.

[[mqtt_qos]]
==== Quality Of Service

The MQTT protocol defines three levels of Quality of Service:

* At Most Once (with the value +0+ represented by +AtMostOnce+ in +MQTTKit+)
* At Least Once (with the value +1+ represented by +AtLeastOnce+ in +MQTTKit+)
* Exactly Once (with the value +2+ represented by +ExactlyOnce+ in +MQTTKit+)

These levels of QoS determine the guarantee that the MQTT broker will accept to deliver a message.
With +At Most Once+, the MQTT broker guarantees that the published message will be delivered at most once to its consumers. This means that the consumers may not receive the message at all. If an error (such as a network failure or a crash) occurs while the message is sent to the broker, it is possible that it will be lost and the consumers will never receive it.

With +At Least Once+, the MQTT broker guarantees that the published message will be delivered at least once to the consumers. This also means that a consumer may receive the same message twice. If there is any error when the producer sends the message to the broker and did not receive an acknowledgement that its message has been received, it will resend it as second time as a _duplicate_ (the MQTT message will have a +DUP+ bit set). When the broker receives this duplicate message it will redeliver it to the consumer but it is possible that they in fact received the original message. The consumer may need to check if the +DUP+ bit is set on the delivered message to know whether it is an original message (and it must process it) or a duplicate (and it can discard it)

The +At Least Once+ QoS offers the guarantee that no published message will be lost but at the cost of performance and additional code on the consumer side.
The performance cost is caused by the additional message (a +PUBACK+ message) sent from the broker to the client to acknowledge that it has received the published message. That means that using this QoS level to publish +N+ messages will involve exchanging +2*N+ messages between the producer and the broker.

The highest level of delivery is provided using the +Exactly Once+ QoS. With that level, the MQTT broker guarantees that the published message will be delivered _exactly_ once by the consumers. There will be no lost messages or duplicate messages. This is guaranteed by additional exchange of messages between the producer and broker (+PUBREC+, +PUBREL+, +PUBCOMP+ messages).
That means that using this QoS level to publish +N+ messages will involve exchanging +4*N+ messages, requires four times more network trips than the lowest level of QoS of +At Most Once+ and twice more than the +At Least Once+ level.

Choosing the correct QoS depends on the type of message exchanged and the _importance_ of its payload.
In the +Motions+ iOS application, the published message contains device motion that are updated every second. It is acceptable if a published message is _lost_ because an new message with updated content will be sent just one second after. Using the +AtMostOnce+ QoS is the best choice for this type of message.

All the complexities of using higher level of QoS is transparent from the application using MQTT as it is the responsibility of the client library to handle it. However you need to be aware of the cost associated to using these QoS as they can have significant impact on your application performance and the device in general (as the additional network trips will drain the battery life).

==== Retained Message

The final parameter of the +publish...+ methods is a boolean to specify whether the published message must be _retained_ by the topic.

If this flag is set on the message, the broker will deliver the message to its subscribers and keep holding the message. If a new consumer subscribes to this topic, the broker will deliver the retained message to it. This is useful as the new subscriber will not have to wait for a publisher to send a message to receive new data. The retained message contains the _Last Known Good_ value.

If our case, we will publish messages with _retain_ set to +YES+. If consumers subscribes to the device motion topic *after* the device stops updated its motion values, they will still be able to use the last know device motion value.
This example is a bit of a stretch. A more interesting example would be an application broadcasting its location (similar to the +Locations+ application). Using retained message would allow the consumers to know the last know position of the device before it stops broadcasting its position.

To sum up, the +Motions+ application will send a message:

* with a binary payload composed of three 64-bits floats for the device's +pitch+, +roll+, and +yaw+ values
* to the device motion topic +/mwm/XXX/motion+ where +XXX+ is the device identifier
* with a QoS ot +AtMostOnce+ since we accept that a published message may not be delivered
* with +retain+ set to +YES+ so that the broker will retain the Last Known Good message to deliver it to new subscribers.

We will encapsulate this code in a +send:+ method taking a +CMAttitude+ parameter.

[source,objc]
----
- (void)send:(CMAttitude *)attitude
{
    uint64_t values[3] = {
        CFConvertDoubleHostToSwapped(attitude.pitch).v,
        CFConvertDoubleHostToSwapped(attitude.roll).v,
        CFConvertDoubleHostToSwapped(attitude.yaw).v
    };
    NSData *data = [NSData dataWithBytes:&values length:sizeof(values)];
    NSString *topic =[NSString stringWithFormat:@"/mwm/%@/motion", self.deviceID];
    [self.client publishData:data
                     toTopic:topic
                     withQos:AtMostOnce
                      retain:NO
           completionHandler:nil];
}
----

The message will contain the motion values in radians. It will be up to the consumers to convert them in degrees if necessary.

Finally, the last step is to call this method every time a device motion value is updated by the +motionManger+. This occurs in the +viewDidLoad+ method inside the +handler+ block passed to the +motionManger+'s +startDeviceMotionUpdatesToQueue:withHandler:+ method.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // get the device motion updates every second.
    self.motionManager.deviceMotionUpdateInterval = 1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue
                                            withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                // convert values from radians to degrees
                double pitch = attitude.pitch * 180 / M_PI;
                double roll = attitude.roll * 180 / M_PI;
                double yaw = attitude.yaw * 180 / M_PI;
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.0f°", pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.0f°", roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.0f°", yaw];
            });
            [self send:attitude];
        }
    }];


    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
}
----

We now have the +Motions+ iOS application that is sending MQTT messages. How can we check that this is working as expected?

Conversely to +STOMP+, +MQTT+ is a binary protocol and we can not use a simple +telnet+ client to create a consumer and receive messages sent by the application.

However the http://mosquitto.org[Mosquitto broker] provides simple command-line tool to send and receive message from a MQTT broker. The <<appendix_mosquitto>> explains how to download and install the Mosquitto broker. After it is done, we can use its +mosquitto_sub+ command line tool to connect to a MQTT broker (hosted at +iot.eclipse.org+) and subscribe to the device motion topic (in my case +/mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/motion+, you will have to replace it using your own device identifier).

This tool will display the message payload. Since we are sending binary payload, we will pipe the command into the +hexdump+ tool to display the hexadecimal representation of the binary payload.

[source,bash]
----
$ mosquitto_sub -h iot.eclipse.org -t /mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/motion | hexdump
...
0000050 aa b0 4c 3f 9b 41 0c 6b 08 35 d3 3f d2 4b 23 f2
0000060 71 1e 47 0a 3f d5 05 6a c4 37 52 16 3f d8 f7 b5
0000070 34 f6 19 ea bf d2 97 6f 1a 65 86 af 0a 3f af 23
0000080 78 91 85 1c 8d bf df b9 12 c4 78 64 1c 3f cb 3c
0000090 50 fd 05 26 5b 0a 3f d1 60 87 16 0b 12 9e bf c2
...
----

This confirms that the +Motions+ application is effectively publishing MQTT messages.

[[ch_mobile_mqtt_receive]]
=== Receive MQTT Messages

As described in <<ch_introduction_mqtt_example>>, the +Motions+ iOS application is also a consumer from the topic +/mwm/XXX/alert+. When it receives a message from this topic, it must change its background color to "alert" the user.

Let's write the method that aler the user by changing the background color first. This +warnUser:+ method takes a +NSString+ parameter that should correspond to a color. Using +UIKit+ animations, we will:

. animate the controller's view to change its background color from its original color to the one created from the +NSString+ parameter
. we wait two seconds after the first animation is completed to revert back to the original background color.

[source,objc]
----
# pragma mark - UI Actions

// Warn the user by changing the view's background color to the specified color during 2 seconds
- (void)warnUser:(NSString *)colorStr
{
    // keep a reference to the original color
    UIColor *originalColor = self.view.backgroundColor;

    [UIView animateWithDuration:0.5
                          delay:0.0
                        options:0
                     animations:^{
                         // change it to the color passed in parameter
                         SEL sel = NSSelectorFromString([NSString stringWithFormat:@"%@Color", colorStr]);
                         UIColor* color = nil;
                         if ([UIColor respondsToSelector:sel]) {
                             color  = [UIColor performSelector:sel];
                         } else {
                             color = [UIColor redColor];
                         }
                         self.view.backgroundColor = color;
                     }
                completion:^(BOOL finished) {
                         // after a delay of 2 seconds, revert it to the original color
                         [UIView animateWithDuration:0.5
                                               delay:2
                                             options:0
                                          animations:^{
                                              self.view.backgroundColor = originalColor;
                                          }
                                          completion:nil];
                     }];
}
----

To consumer messages from a MQTT broker, the +client+ must:

. subscribe to its topic of interest
. set its +messageHandler+ property that will be called every time a message is delivered.

Note that you can subscribe to many topics from the client but it has only one +messageHandler+ property. If the client is subscribed to different topics, its +messageHandler+ must determine which topic the message is consumed from.

==== Subscription

The +Motions+ application will subscribe to its device alert topic +/mwm/XXX/alert+ by calling the method +subscribe:withQos:completionHandler:+ on its +client+ property.

The first parameter is the device alert topic. We will define it at the top of the +MWMViewController.m+ file.

[source,objc]
----
#define kAlertTopic @"/mwm/%@/alert"
----

The +subscribe:withQos:completionHandler:+ method takes a +qos+ that correspond to the quality of service that the consumer is requesting for message delivered from the topic.

The completion handler will be called when the client is effectively subscribed to the topic. The handler has a +grantedQos+ parameter that corresponds to the effective quality of service. The producer is responsible for determining the maximum quality of service that a message can be delivered at but the consumer can decide to _downgrade_ the quality of service according to its usage.
For example, a producer may publish a message with a QoS of +ExactlyOnce+ but a consumer may decide that it is acceptable for it if there are message duplicates and downgrade its QoS to +At Least Once+.

In our case, we will request to have messages delivered with a +qos+ set to +AtLeastOnce+ as we do not want to lose messages but can accept duplicate messages.

[source,objc]
----
- (void)subscribe
{
    NSString *topic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.client subscribe:topic withQos:AtLeastOnce completionHandler:^(NSArray *grantedQos) {
        NSLog(@"subscribed to %@ with QoS %@", topic, grantedQos);
    }];
}
----

We will subscribe to the alert topic as soon as the +client+ is connected to the MQTT broker by calling this +subscribe+ method from inside the +completionHandler+ in the +connect+ method.

[source,objc]
----
- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
            [self subscribe];
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}
----

==== Unsubscription

To unsubscribe from a topic and stop receiving messages from it, we will call the +unsubscribe:withCompletionHandler:+ method of the +client+ where the first parameter is the topic to unsubscribe from (the alert topic in our case).
The second parameter is a completion handler that is called back when the client has been acknowledged by the server that it is effectively unsubscribed.
We don't have any need for this information in our case so we just pass +nil+ as the handler.

[source,objc]
----
- (void)unsubscribe
{
    NSString *topic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.client unsubscribe:topic withCompletionHandler:nil];
}
----

We will call this +unsubscribe+ method just before disconnecting from the MQTT broker from the +dealloc+ method.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self unsubscribe];
    [self disconnect];
}
----

Since we disconnect just after unsubscribing, we could skip that step and just disconnect from the MQTT broker. At that moment, the MQTT broker will automatically unsubscribe the client from any topic. However it is a good practice to explicitly unsubscribe from subscribed topic. There are also many cases where unsubscribing may occur at a different time than the disconnection. In these cases, we can not rely on the client disconnection to perfom the unsubscription.

==== Define a MQTTMessage Handler

Subscribing to a topic is the first step to receive messages with +MQTTKit+. The secon step is to define a block that will be called every time a message is received from a subscribed topic.

The +client+'s +messageHandler+ property defines a +MQTTMessageHandler+ block. This block has a +MQTTMessage+ parameter representing the MQTT message that is deliver to the client.

The +MQTTMessage+ interface defines four properties corresponding to the message data:

* +mid+ is a +unsigned short+ corresponding to the _message ID_.
* +topic+ is the name of the topic that this message is coming from. If the client is subscribed to many topics, we must use this property to determine which topic the received message is coming from.
* +retained+ is a +BOOL+ to check whether the message was retained (and contains the last known good value) or not (it is a _fresh_ message)
* +payload+ is a +NSData+ object containing the binary content of the message payload.

Since sending and receiving text message is very common, the +MQTTMessage+ interface also defines a +payloadString+ method that returns a +NSString+ decoded from the message binary payload using UTF-8.

In the +Motions+ application, we expect to receive a text payload and will use this +payloadString+ to extract the color string from the received message.

We need to set the +client+'s +messageHandler+ _before_ subscribing to the alert topic so that we do not miss any alert message sent after we subscribe but _before_ the +messageHandler+ is defined.
We will do that in the +viewDidLoad+ method just after creating the +client+ instance.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    // use a weak reference to avoid a retain/release cycle in the block
    __weak MWMViewController *weakSelf = self;
    self.client.messageHandler = ^(MQTTMessage *message) {
        NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, weakSelf.deviceID];
        if ([alertTopic isEqualToString:message.topic]) {
            NSString *color = message.payloadString;
            dispatch_async(dispatch_get_main_queue(), ^{
                [weakSelf warnUser:color];
            });
        }
    };

    [self connect];
}
----

We extracted the color using the message +payloadString+ method after checking that it was indeed coming from the device alert topic.
We then call the +warnUser:+ method in a block that is run on the main queue since it contains code related to +UIKit+.

To avoid a retain/release cycle between +self+ and the +messageHandler+ block, we need to create a _weak_ reference of +self+ and uses it from the block.

How can we verify that the +Motions+ application is effectively receiving alert messages? To verify that the application was sending messages, we used the +mosquitto_sub+ tool. We will now use the opposite tool, +mosquitto_pub+, to publish a message on the alert topic and verify that the application background color changes.

The +mosquitto_pub+ can send a text payload using the +-m+ option. We will use this option to pass the background color (for example +green+).

[source,bash]
----
$ mosquitto_pub -h iot.eclipse.org -t /mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/alert -m green
----

After this message is sent, the device will receive it and change its background color to green.

[[img_mobile_mqtt_2]]
.Alert message is received by the +Motions+ iOS application
image::images/Chapter060/background_color_change.png[Alert message is received by the Motions iOS application]

=== Summary

In this chapter, we learn to use +MQTTKit+ to send and receive MQTT messages from an iOS application.

To send a message, the application must:

. connect to the MQTT broker
. send the message to the topic

To consume a message, the application must

. connect to the MQTT broker
. subscribe to the topic
. define a message handler block that is called every time a message is received. This block is executed on a dispath queue. If there are any code that changes the user interface, it must be wrapped in a block executed on the main queue.

We used two different types of message payloads:

* a binary payload to send the device motions values as three 64-bit floats
* a text payload to extract a background color from the messages received on the alert topic.
