[[ch_mobile_mqtt]]
== Mobile Messaging With MQTT

[role="lead"]
In this chapter, we present MQTT, a binary-based protocol develop for telemetry
communication. Its simplicity and compactness make it ideally suited for mobile devices. We will write an iOS application using the +MQTTKit+ library to send and receive messages using the MQTT protocol.

In <<ch_introduction_mqtt_example>>, we described the +Motions+ application. In this chapter, we will write the iOS application that broadcast the device motion data and receive alert message.

[[img_mobile_mqtt_1]]
.Diagram of the +Motions+ iOS application
image::images/Chapter060/mqtt_ios_app.png["Diagram of the Motions+ iOS application"]

=== About the Code

All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +mqtt/ios/+ directory.

=== MQTT

MQTT only supports the _Publish/Subscribe_ messaging model. 

=== +MQTTKit+

TODO

[[ch_mobile_mqtt_paho]]
=== Eclipse Paho MQTT Server

TODO

=== Create the +Motions+ project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +Locations+ iOS application.

Once Xcode is installed and started, we select +Create a new Xcode project+ from its launch screen. The application will be composed of a single view so we select the +Single View Application+ template in +iOs > Application+ from the template screen.

[[img_mobile_mqtt_1]]
.Select +Single View Application+ from the template screen.
image::images/Chapter060/template_screen.png["XCode template screen"]

We will call the project +Motions+ and select to build it only for iPhone devices.

[[img_mobile_mqtt_2]]
.XCode project options screen
image::images/Chapter060/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

We will again use CocoaPods to manage the project dependencies.

We close Xcode because CocoaPods will modify the project settings to import the dependencies.

we create a file named **`Podfile`** at the root of the project (in the same directory than +Motions.xcodeproj+).

[[ex_mobile_mqtt_1]]
.+Motions+'s Podfile
====
----
xcodepxcodeproj 'Motions.xcodeproj'

pod 'MQTTKit', :git => 'https://github.com/mobile-web-messaging/MQTTKit.git'

platform :ios, '5.0'
----
====

After saving this file, run the **`pod install`** command.

[[ex_mobile_mqtt_2]]
.Install +Motions+ dependencies
====
----
$ pod install
Analyzing dependencies
Pre-downloading: `MQTTKit` from `https://github.com/mobile-web-messaging/MQTTKit.git`
Downloading dependencies
Installing MQTTKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `Motions.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the _Workspace_ file named +Motions.xcworkspace+, and not the _Project_ file named +Motions.xcodeproj+.

[[img_mobile_mqtt_3]]
.Open the workspace file
image::images/Chapter060/open_workspace.png["Open the workspace file"]

First, we will verify that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting +Product > Destination > iPhone Retina (4-inch 64-bit)+ from Xcode menu bar.
If we run the application by selecting **`Product`** > **`Run`** (or pressing **`âŒ˜R`**), the iOS simulator starts and opens the application which is composed of a blank view. This confirms that the project and its dependencies are  successfully compiled and launched.

=== Identify the Device

This step is similar to the +Locations+ iOS application that is described in [[ch_mobile_stomp_deviceID]].

We will generate an unique identifier for the iOS device and display it in the view.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag a +Label+ on the +View+'s window. Place it at the top of the view and change the text to +Device ID+.

[[img_mobile_mqtt_4]]
.Add the Device ID label.
image::images/Chapter060/deviceID_label.png[Add the Device ID label]

We will again change its +Font+ to +System 13.0+ and its +Alignment+ to centered to fit the screen.

This label will be connected to a +deviceIDLabel+ outlet property defined in the +MWMViewController+ private interface in +MWMViewController.m+ file.
We also add a +deviceID+ string to store the device identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +deviceIDLabel+ to the +UILabel+ to connect it.

[[img_mobile_mqtt_5]]
.Connect the +deviceIDLabel+ outlet property to the device ID +UILabel+.
image::images/Chapter060/deviceIDLabel_connection.png[Connect the deviceIDLabel outlet property to the device ID UILabel]

The device identifier is generated in the +MWMViewController+ implementation when the view is loaded and stored in the +deviceID+ property. We also set the +deviceIDLabel+'s +text+ to this identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;
}
----

=== Display the Device Motions Values

The device motion will be identified using their _pitch_, _roll_ and _yaw_ values.
To have some graphical feedback as we move the device, we will add three +UILabel+ that shows these three values.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag three +Labels+ on the +View+'s window below the Device ID label. Change their respective text to +pitch+, +roll+, and +yaw+.

[[img_mobile_mqtt_6]]
.Add three labels to display the device's pitch, roll and yaw values.
image::images/Chapter060/motions_labels.png["Add three labels to display the device's pitch, roll and yaw values."]

We create three outlet properties in the +MWMViewController+ private interface for these labels.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;
@property (weak, nonatomic) IBOutlet UILabel *pitchLabel;
@property (weak, nonatomic) IBOutlet UILabel *rollLabel;
@property (weak, nonatomic) IBOutlet UILabel *yawLabel;

@property (strong, nonatomic) NSString *deviceID;

@end
----

Next step is to the connect the three labels in the +Main.storyboard+ to these three outlet properties.

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from its +pitchLabel+ property to the corresponding pitch +UILabel+ to connect it.

[[img_mobile_mqtt_7]]
.Connect the +pitchLabel+ outlet property to the pitch +UILabel+.
image::images/Chapter060/pitchLabel_connection.png[Connect the pitchLabel outlet property to the pitch UILabel]

Repeat this operation for the +rollLabel+ and +yawLabel+ to connect them.

At this stage, the graphical objects are connected and we can capture the device motion to update these labels and then broadcast the motion data using MQTT.

=== Capture the Device Motions with +CoreMotion+ Framework

iOS provides the +CoreMotion+ framework to capture the motion of the devices.

We need to add it to the libraries linked by the application. Click on the +Motions+ project and then the +Motions+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreMotion`**, select the +CoreMotion.framework+ and click on the +Add+ button.

.Add the +CoreMotion+ framework.
image::images/Chapter060/CoreMotion_framework.png["Add the CoreMotion framework"]

We can now use the +CoreMotion+ framework by importing +<CoreMotion/CoreMotion.h>+ at the top of the +MWMViewController.m+ file.

We will also define a +motionManager+ property in +MWMViewController+ private interface to use +CoreMotion+.

[source,objc]
----
#import <CoreMotion/CoreMotion.h>

@interface MWMViewController ()

@property (strong, nonatomic) CMMotionManager *motionManager;

@end
----

This +motionManager+ is used to capture the device motions. We must create a new +CMMotionManager+, specify the interval of update and call its +startDeviceMotionUpdatesToQueue:withHandler:+ method to get the device motion 
periodically in a block. We create a new +NSOperationQueue+ to receive these updates on this queue.

The device motion is represented by a +CMDeviceMotion+ object. In our example, we are interested only by its +attitude+ property that contains the +pitch+, +roll+ and +yaw+ value we want to broadcast.

Since the block to receive motion update is executed on the +NSOperationQueue+ we have created, we can not update the +UILabel+ from it. We must instead create another block and call +dispatch_async+ to execute the graphical changes on the UI main queue (that is retrieved by calling +dispatch_get_main_queue()+).

All this logic can be written in +viewDidLoad+ so that the motion manager will start receiving updates when the view is loaded.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;
    
    self.motionManager = [[CMMotionManager alloc] init];
    // use a frequency of circa 10Hz to get the device motion updates
    self.motionManager.deviceMotionUpdateInterval = 0.1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            dispatch_async(dispatch_get_main_queue(), ^{
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.1f", motion.attitude.pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.1f", motion.attitude.roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.1f", motion.attitude.yaw];
            });
        }
    }];
}
----

We also need to notify the +motionManager+ that we no longer want to receive updates when the view is no longer used. We need to call its +stopDeviceMotionUpdates+ method inside the view controller's +dealloc+ method.

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
}
----

At this stage, if you run the +Motions+ application on your iPhone and move it, the pitch, roll, and yaw labels will be updated to reflect the changes in the device motions.

[[img_mobile_mqtt_8]]
.The motion values change when the device moves.
image::images/Chapter060/app.png["The motion values change when the device moves."]

[NOTE]
====
The +iOS Simulator+ is not able to simulate device motions. If you run the +Motions+ applicatio in the simulator, the +motionManager+ will not send any device motions updates. At the time of writing this book, the only way to test this code is to run the application on a real iOS device.
====

We now capture the device motions and display them. Next step is to broadcast them by sending MQTT messages.

[[ch_mobile_mqtt_client]]
=== Create a MQTT Client With MQTTKit

To send and receive message with MQTT, we must first import the +MQTTKit+ library that was added to the project using CocoaPods at the beginning of this chapter.

We must import its header file +MQTTKit.h+ at the top of the +MWMViewController.m+ file and add a +MQTTClient+ property named +client+ to the +MWMViewController+ private interface.

We also define a constant to represent the hostname of the MQTT broker we are using +iot.eclipse.org+.

[source,objc]
----
#import <MQTTKit/MQTTKit.h>

#define kMqttHost @"iot.eclipse.org"

@interface MWMViewController ()

@property (strong, nonatomic) MQTTClient *client;

@end
----

We will create a new +MQTTClient+ object in the +MWMViewController+'s +viewDidLoad+ method.
A +MQTTClient+ must be uniquely identified for the MQTT brokers it connects to.
We can use the +deviceID+ as its client identifier.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    ...
    
    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    [self connect];
}
----

TODO












[source,objc]
----
#pragma mark - MQTTKit Actions

- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}

----

=== Connect to a MQTT Broker

TODO

[source,objc]
----
#pragma mark - MQTT actions

- (void)connect
{
    [self.mqttClient connectToHost:kMqttHost];
}
----

TODO

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];
    
    ...

    self.mqttClient = [[MQTTClient alloc] initWithClientId:self.deviceID];
    // Override point for customization after application launch.
    self.mqttClient.delegate = self;

    [self connect];
}
----

=== Disconnect from a MQTT Broker

TODO

[source,objc]
----
- (void)disconnect
{
    [self.mqttClient disconnect];
}
----

TODO

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self disconnect];
}
----

=== Send MQTT Messages

[source,objc]
----
- (void)send:(CMAttitude *)attitude
{
    uint64_t values[3] = {
        CFConvertDoubleHostToSwapped(attitude.pitch).v,
        CFConvertDoubleHostToSwapped(attitude.roll).v,
        CFConvertDoubleHostToSwapped(attitude.yaw).v
    };
    NSData *data = [NSData dataWithBytes:&values length:sizeof(values)];
    [self.mqttClient publishData:data
                         toTopic:[NSString stringWithFormat:kMotionTopic, self.deviceID]
                         withQos:0
                          retain:NO];

}
----

[source,objc]
----
- (void)viewDidLoad
{
    ...
    [self.motionManager startDeviceMotionUpdatesToQueue:queue withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            [self send:motion.attitude];
            dispatch_async(dispatch_get_main_queue(), ^{
                self.pitchLabel.text = [NSString stringWithFormat:@"pitch: %.1f", motion.attitude.pitch];
                self.rollLabel.text = [NSString stringWithFormat:@"roll: %.1f", motion.attitude.roll];
                self.yawLabel.text = [NSString stringWithFormat:@"yaw: %.1f", motion.attitude.yaw];
            });
        }
    }];
    ...
}
----

<<ch_mobile_mqtt_receive>>
=== Receive MQTT Messages

[source,objc]
----
#pragma mark - MQTTClientDelegate

- (void)client:(MQTTClient *)client didReceiveMessage:(MQTTMessage *)message
{
    NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    if ([alertTopic isEqualToString:message.topic]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self warnUser:message.payloadString];
        });
    }
}
----

TODO

[source,objc]
----
# pragma mark - UI Actions

// Warn the user by changing the view's background color to red for 2 seconds
- (void)warnUser:(NSString *)colorStr
{
    // keep a reference to the original color
    UIColor *originalColor = self.view.backgroundColor;
    
    [UIView animateWithDuration:0.5
                          delay:0.0
                        options:0
                     animations:^{
                         // change it to the color passed in parameter
                         SEL sel = NSSelectorFromString([NSString stringWithFormat:@"%@Color", colorStr]);
                         UIColor* color = nil;
                         if ([UIColor respondsToSelector:sel]) {
                             color  = [UIColor performSelector:sel];
                         } else {
                             color = [UIColor redColor];
                         }
                         self.view.backgroundColor = color;
                     }
                     completion:^(BOOL finished) {
                         // after a delay of 2 seconds, revert it to the original color
                         [UIView animateWithDuration:0.5
                                               delay:2
                                             options:0
                                          animations:^{
                                              self.view.backgroundColor = originalColor;
                                          }
                                          completion:nil];
                     }];
}
----

TODO

[source,objc]
----
- (void)subscribe
{
    NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.mqttClient subscribe:alertTopic
                       withQos:0];
}
----

TODO

[source,objc]
----
#pragma mark - MQTTClientDelegate

- (void)client:(MQTTClient *)client
    didConnect:(NSUInteger)code
{
    // once connect, subscribe to the client's alerts topic
    [self subscribe];
}
----

=== Unsubscribe From the Topic

TODO

[source,objc]
----
- (void)unsubscribe
{
    NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.mqttClient unsubscribe:alertTopic];
}
----

TODO

[source,objc]
----
- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self unsubscribe];
    [self disconnect];
}
----

=== Summary

TODO
