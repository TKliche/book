[[ch_stomp]]
== STOMP

[role="lead"]
In this chapter, we present the STOMP protocol, a simple text-based messaging
protocol that is well suited to build lightweight messaging applications on any platforms.

STOMP provides an interoperable wire format so that clients can communicate with any message broker.
The simplicity of the protocol ensures that it's straightforward to have interoperability between any client and brokers.

This chapter covers the latest released version of the protocol:
http://stomp.github.io/stomp-specification-1.2.html[STOMP 1.2]

[NOTE]
====
TODO: add section about STOMP development model (no organization/company, OSS...)
====

=== Anatomy of a STOMP Frame

STOMP is modelled on HTTP and based on _frames_.
Each frame is composed of 3 elements:

* a _command_
* an (optional) set of _headers_
* an (optional) _payload_

[[ex_stomp_frame]]
.STOMP Frame Structure
====
----
COMMAND<1>
header1:value1<2>
header2:value2
<3>
payload^@<4>
----
<1> A frame starts with a command string followed by an end-of-line (EOL)
<2> Header entries followed the format +<key>:<value>+ and is ended by EOL
<3> A blank line separates the set of headers from the payload
<4> A frame is ended by a NULL octet (represented by +^@+ in ASCII)
====

STOMP is based on text (using UTF-8 for its default encoding)
but it can also transmit binary data in its payload by specifying an alternative encoding.

A STOMP client can serve two messaging roles:

[NOTE]
====
TODO: cross-reference with the messaging concepts of producer and consumer
====

. It can be a _producer_ and send messages with +SEND+ frames
(i.e. frames with the +SEND+ command)
. It can be a _consumer_ and subscribe to receive messages using a +SUBSCRIBE+ frame. Each received messages will be delivered by the broker to the client as +MESSAGE+ frames.

Messages are *pushed* to STOMP clients. The protocol does not offer any command to pull messages from the broker.

==== Command

A STOMP frame starts with a command string terminated by an end-of-line (EOL).

+SEND+, +SUBSCRIBE+, +MESSAGE+, along with +CONNECT+ (resp. +DISCONNECT+) used to connect (resp. disconnect) to the broker, are the principal commands.

Other commands correspond to additional features (message acknowledgement, transaction, receiption and error handling).

This chapter describes all the commands supported by STOMP 1.2.

==== Headers

Following the command string, a STOMP frame accepts an optional set of headers.
A header follows the format +<key>:<value>+ and is terminated by an EOL.

The end of the headers is indicated by an empty blank line.

Some headers are defined in the specification and are mandatory for a given frame.
For example, a +SEND+ frame must have a +destination+ header to indicate the destination of the messages.

Other headers are optional.
For example, a +SEND+ frame can be sent inside a transaction by addin a +transaction+ header.

==== Payload

After the headers, a STOMP frame may contain a payload.

Only +SEND+, +MESSAGE+ and +ERROR+ frames can contain payload.

The payload in +SEND+ and +MESSAGE+ are the user data that are exchanged between the client and the broker.

A messaging broker may send +ERROR+ frames to the client if something went wrong.
The +ERROR+ frame may contain a payload with detailed information about the problem (in addition to a short description in a +message+ header).

Finally, a STOMP frame is always terminated by a NULL octet (+^@+).

===== Payload content

If a frame contains a payload, it should have a +content-length+ header corresponding to the size of the payload (its number of octets).

It is also advised to set a +content-type+ with the MIME type of the payload. Otherwise, it is considered as a binary blob.

For example, we want to send a message with a JSON string:

----
{"name":"foo","value":"bar"}{
----

The corresponding +SEND+ frame should have both the +content-length+ and +content-type+ headers set:

[[ex_stomp_payload]]
.Payload with a JSON string
====
----
SEND
destination:/queue/myqueue<1>
content-length:28<2>
content-type:application/json<3>

{"name":"foo","value":"bar"}^@<4>
----
<1> A +SEND+ frame must contain a +destination+ header.
<2> The length of the JSON string is 28 octets.
<3> The MIME type for JSON is +application/json+.
<4> The frame must be ended by a NULL octet (represented by +^@+ in ASCII) even when the +content-length+ header is set.
====

=== Connection

.Install and configure a messaging broker
[NOTE]
====
Before using a STOMP client, a messaging broker must be installed and
configured to be able to exchange messages.

In the book, we use Apache ActiveMQ as the messaging broker. The <<appendix_activemq>>
 shows how to install and configure ActiveMQ.

This chapter expects that ActiveMQ is configured with STOMP (as explained in <<app_activemq_stomp>>) and the security is enabled
(as explained in <<app_activemq_security>>).

Once ActiveMQ is started, it accepts STOMP connections on +localhost:61613+.
====

Since STOMP is text-based, we can send and receive message from the command
line using a +telnet+ client.

[[ex_stomp_telnet]]
.Connection with a telnet client
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</screen>
++++
====

((("STOMP Frames", "CONNECT")))

The telnet client is now connected to the broker using a TCP connection.
It must also establish a STOMP connection by sending a +CONNECT+ frame:

[[ex_stomp_connect]]
.Connect to a STOMP broker
====
++++
<screen>
<userinput>CONNECT
accept-version:1.2<co xml:id="co.ex_stomp_connect_1"/>
login:user<co xml:id="co.ex_stomp_connect_2"/>
passcode:password<co xml:id="co.ex_stomp_connect_3"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connect_1">
    <para>The <literal>accept-version</literal> indicates the client wants to communicate
with the broker using the version 1.2 of the protocol.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connect_2 co.ex_stomp_connect_3">
    <para>The client authenticates by passing the username and password with the <literal>login</literal> 
and <literal>passcode</literal> headers.</para>
  </callout>
</calloutlist>
++++
====

[CAUTION]
====
A STOMP frame must be ended by a NULL octet.

The +^@+ is the ASCII character for NULL octet. Type +ctrl + @+ to enter it.
====

Note also that there is a blank line between the +accept-version+ header and the NULL octet.
The blank line is mandatory to determine the end of the headers and the beginning
of the optional payload (that is not present in the +CONNECT+ frame).

((("STOMP Frames", "CONNECTED")))

Once you type +ctrl + @+, the messaging broker will process the +CONNECT+ frame
and reply with a +CONNECTED+ frame:

[[ex_stomp_connected]]
.Receive a connection confirmation
====
++++
<screen>
CONNECTED<co xml:id="co.ex_stomp_connected_1"/>
heart-beat:0,0<co xml:id="co.ex_stomp_connected_2"/>
session:ID:retsina.local-64904-1378366884467-2:1<co xml:id="co.ex_stomp_connected_3"/>
server:ActiveMQ/5.8.0<co xml:id="co.ex_stomp_connected_4"/>
version:1.2<co xml:id="co.ex_stomp_connected_5"/>
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connected_1">
    <para>The <literal>CONNECTED</literal> frame means the connection was successful.
 If there were any problem during the connection, an <literal>ERROR</literal> frame would have been returned.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_2">
    <para>The <literal>heart-beat</literal> header is explained below in <xref linkend="ch_stomp_heartbeat"/>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_3">
    <para>The <literal>session</literal> header uniquely identifies the session between the client and the broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_4">
    <para>The <literal>server</literal> header contains information about the STOMP broker. In that example, we are connected to Apache ActiveMQ 5.8.0.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_5">
    <para>The <literal>version</literal> header is the version of the STOMP protocol that will be used during the session.</para>
  </callout>
</calloutlist>
++++
====

The STOMP connection is now established and the telnet client can now exchange messages with the broker.

If the authentication credentials provided by the client are not correct, the broker will return an +ERROR+ frame instead of the
+CONNECTED+ frame (as described in <<ch_stomp_error>>).

[[ch_stomp_send_message]]
=== Send a Message

((("STOMP Frames", "SEND")))

Now that the telnet client is connected to the messaging broker, it can send a message to a _destination_ on the broker using the +SEND+ frame.

_Destinations_ are opaque strings specific to each messaging broker implementation.

STOMP itself has no notion of delivery semantics (whether a destination is a queue, a topic or another exchange type) and you have to consult the messaging broker documentation to check how to name the destination for STOMP.

[NOTE]
====
ActiveMQ convention is to prefix the destination by +/queue/+ to send to a queue.
To send to a topic, we would prefix the destination by +/topic/+ instead.

ActiveMQ will automatically create a destination based on the +destination+ header so we do not have to create it beforehands.
Other brokers may behave differently and require to create the destination before sending any messages to it.
====

[[ex_stomp_send]]
.Send a message
====
++++
<screen>
<userinput>SEND
destination:/queue/myqueue<co xml:id="co.ex_stomp_send_1"/>
content-type:text/plain
content-length:13

Hello, STOMP!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_1">
    <para>The message must be sent to the <literal>/queue/myqueue</literal> destination.</para>
  </callout>
</calloutlist>
++++
====

[NOTE]
====
TODO: cross-reference to the queue concept (one-to-one)
====

By following ActiveMQ convention, the message was sent to a queue. This message can only be received by a single consumer.

The +destination+ header indicates the destination of the message.

It also contains payload with the text +Hello, STOMP!+.
The payload is immediately followed by the NULL octet (represented by +^@+) to end the frame.

Once you +ctrl + @+ to enter the NULL octet, the message is processed by the broker.

[[ch_stomp_receipt]]
==== Frame Receiption

((("STOMP Frames", "RECEIPT")))

The STOMP broker can sent some feedback to let the client know that a frame has been received. This is a general mechanism available on any frame sent by a client to a broker (and not only on the +SEND+ frame).

To receive a confirmation that a message is handled by the STOMP broker, a frame sent by the client must indicate a +receipt+ header.

[[ex_stomp_send_with_receipt]]
.Send a message with a receipt
====
++++
<screen>
<userinput>SEND
destination:/queue/myqueue
receipt:123<co xml:id="co.ex_stomp_send_with_receipt_1"/>
content-type:text/plain
content-length:28

Hello, STOMP with a receipt!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_with_receipt_1">
    <para>The <literal>receipt</literal> header will serve to identify the receipt sent by the broker
when it will have successfully handled this frame.</para>
  </callout>
</calloutlist>
++++
====

When this +SEND+ frame is received by the broker and succesfully handled, the broker replies with a +RECEIPT+ frame containing the corresponding receipt ID in a +receipt-id+ header:

[[ex_stomp_receipt]]
.Receive the receipt
====
++++
<screen>
RECEIPT
receipt-id:123<co xml:id="co.ex_stomp_receipt_1"/>

</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receipt_1">
    <para>The <literal>receipt-id</literal> header corresponds to the <literal>receipt</literal> header set on the frame successfully handled by the broker.</para>
  </callout>
</calloutlist>
++++
====

This +RECEIPT+ lets the client know that the broker has _received_ the message but it does not mean that the message has been processed yet (or will be processed at all).

[[ch_stomp_error]]
==== Error frame

((("STOMP Frames", "ERROR")))

If a message is sent with an invalid format, the messaging broker will reply immediately with an +ERROR+ frame.

For example, it is not valid to send a message without a +destination+ header (where would the message go?):

[[ex_stomp_invalid_send]]
.Send an invalid message
====
++++
<screen>
<userinput>SEND
<co xml:id="co.ex_stomp_invalid_send_1"/>

A SEND frame witout a destination is not allowed</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_invalid_send_1">
    <para>The <literal>destination</literal> header is missing.</para>
  </callout>
</calloutlist>
++++
====

Once the message is sent, the client receives an +ERROR+ frame:

[[ex_stomp_error]]
.Receive an error
====
++++
<screen>
ERROR
content-type:text/plain<co xml:id="ex_stomp_error_1"/>
message:SEND received without a Destination specified!<co xml:id="ex_stomp_error_2"/>

org.apache.activemq.transport.stomp.ProtocolException: SEND received without a Destination specified! <co xml:id="ex_stomp_error_3"/>
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:299)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)
        ...
</screen>
<calloutlist>
  <callout arearefs="ex_stomp_error_1">
    <para>This <literal>ERROR</literal> frame has a <literal>content-type</literal> header that let the client know the payload is in plain text (encoded in UTF-8 by default).</para>
  </callout>
  <callout arearefs="ex_stomp_error_2">
    <para>A <literal>ERROR</literal> frame contains a <literal>message</literal> header with a short description of the problem encountered by the broker.</para>
  </callout>
  <callout arearefs="ex_stomp_error_3">
    <para>It also contains a text payload with more information on the problem.</para>
    </callout>
</calloutlist>
++++
====

=== Receive a Message

((("STOMP Frames", "SUBSCRIBE")))

So far, the telnet client has acted as a STOMP _producer_ and sent messages.

It will now also become a STOMP _consumer_ to receive messages.

To receive messages, a STOMP client must send a +SUBSCRIBE+ frame with a +destination+ header.

[[ex_stomp_subscribe]]
.Subscribe to a destination
====
++++
<screen>
<userinput>SUBSCRIBE
destination:/queue/myqueue<co xml:id="co.ex_stomp_subscribe_1"/>
id:mysub<co xml:id="co.ex_stomp_subscribe_2"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_subscribe_1">
    <para>The <literal>destination</literal> is the name of destination the client wants to consume messages from.</para>
  </callout>
  <callout arearefs="co.ex_stomp_subscribe_2">
    <para>The subscription will be identified by the <literal>mysub</literal> identifier indicated in the <literal>id</literal> header.</para>
  </callout>
</calloutlist>
++++
====

The +id+ header corresponds to the subscription identifier and must be unique among all the subscriptions _inside the same connection_.
It is the responsibility of the client to choose this subscription identifier.

((("STOMP Frames", "MESSAGE")))

As soon as the messaging broker receives this +SUBSCRIBE+ frame and handle it,
it starts to send to the client some +MESSAGE+ frames corresponding to the messages sent to this destination.

[[ex_stomp_receive2]]
.Receive two messages
====
++++
<screen>
MESSAGE<co xml:id="co.ex_stomp_receive2_1"/>
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c1<co xml:id="co.ex_stomp_receive2_2"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_receive2_3"/>
subscription:mysub<co xml:id="co.ex_stomp_receive2_4"/>
timestamp:1378367602698<co xml:id="co.ex_stomp_receive2_5"/>
expires:0<co xml:id="co.ex_stomp_receive2_6"/>
content-length:13
priority:4<co xml:id="co.ex_stomp_receive2_7"/>

Hello, STOMP!
MESSAGE<co xml:id="co.ex_stomp_receive2_8"/>
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c2
destination:/queue/myqueue
timestamp:1378368275375
expires:0
subscription:mysub
content-length:28
priority:4
content-type:text/plain

Hello, STOMP with a receipt!
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receive2_1 co.ex_stomp_receive2_8">
    <para>Each received message is contained in a <literal>MESSAGE</literal> frame.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_2">
    <para>A <literal>message-id</literal> header uniquely identifies the message.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_3">
    <para>The <literal>destination</literal> indicates the destination this message was consumed from.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_4">
    <para>The <literal>subscription</literal> indicates which consumer's subscription is receiving the message.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_5 co.ex_stomp_receive2_6 co.ex_stomp_receive2_7">
    <para>A <literal>MESSAGE</literal> frame may contain additional headers (<literal>timestamp</literal>, <literal>expires</literal>,
 <literal>priority</literal> in this case) not specified by the STOMP protocol corresponding to features provided by the broker
(as described below in <xref linkend="ch_stomp_ext" />).</para>
  </callout>
</calloutlist>
++++
====

We have received the 2 messages that we have previously sent in the two examples
above (<<ex_stomp_send>> and <<ex_stomp_send_with_receipt>>). They were sent in a queue and the telnet client is the only consumer that is subscribed to this destination.

The telnet client is now a consumer of the +/queue/myqueue+ destination.
If another message is sent to this destination, it will receive this message immediately:

[[ex_stomp_send_receive]]
.Send a message and receive it
====
++++
<screen>
<userinput>SEND
destination:/queue/myqueue
content-type:text/plain
content-length:15

another message</userinput>^@

MESSAGE
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c3\c-1\c1\c3
destination:/queue/myqueue
timestamp:1378369910799
expires:0
subscription:mysub
content-length:15
priority:4

another message
</screen>
++++
====

=== Unsubscription

((("STOMP Frames", "UNSUBSCRIBE")))

To stop consuming messages from a destination, the client must send a +UNSUBSCRIBE+ frame
with a +id+ header corresponding to the subscription identifier indicated in the +SUBSCRIBE+ frame (+mysub+ in the example above).

[[ex_stomp_unsubscribe]]
.Unsubscribe a consumer
====
++++
<screen>
<userinput>UNSUBSCRIBE
id:mysub<co xml:id="co.ex_stomp_unsubscribe_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_unsubscribe_1">
    <para>The <literal>id</literal> is the subscription identifier set in the corresponding <literal>SUBSCRIBE</literal> frame.</para>
  </callout>
</calloutlist>
++++
====

The telnet client can still act as a producer and send messages but it will no longer receive any sent to the +/queue/myqueue+ destination.

=== Disconnection

((("STOMP Frames", "DISCONNECT")))

To disconnect from the messaging broker, the client must send a +DISCONNECT+ frame.

To ensure a graceful disconnection, the best practice is to send a +DISCONNECT+ frame
with a +receipt+ header and wait to receive the corresponding +RECEIPT+ frame.
The client can then safely close the TCP connection to the  broker (if the broker does not close it from its side first).

[[ex_stomp_disconnect]]
.Grafecul disconnection
====
++++
<screen>
<userinput>DISCONNECT
receipt:456<co xml:id="co.ex_stomp_disconnect_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_disconnect_1">
    <para>The <literal>receipt</literal> value will be used to correlate this frame with the corresponding <literal>RECEIPT</literal> frame.</para>
  </callout>
</calloutlist>
++++
====

When the +DISCONNECT+ frame is sent, the client receives the corresponding +RECEIPT+ frame.

[[ex_stomp_disconnect_receipt]]
.Receive a receipt for the graceful disconnection
====
++++
<screen>
RECEIPT
receipt-id:456<co xml:id="co.ex_stomp_disconnect_receipt_1"/>
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_disconnect_1">
    <para>The <literal>receipt-id</literal> value is the same that the <literal>DISCONNECT</literal>'s <literal>receipt</literal> value.</para>
  </callout>
</calloutlist>
++++
====

The messaging broker then closes the underlying TCP connection and the telnet client is closed:

++++
<screen>
Connection closed by foreign host.
</screen>
++++

[[ch_stomp_heartbeat]]
=== Heart-beat

((("STOMP Heart-beating")))

STOMP offers a mechanism to test the healthiness of a connection between a STOMP client and a broker

[NOTE]
====
TODO: better explanation on the necessity of heart-beating to circumvent TCP.
====

Heart-beat is negotiated between the client and the broker during the exchange of the +CONNECT+ and +CONNECTED+ frames.

When we connected previous in <<ex_stomp_connect>>, we received a +CONNECTED+ (in <<ex_stomp_connected>> ) with a header +heart-beat:0,0+.

The +heart-beat+ header's value is composed of 2 positive integers:

. The smallest number of milliseconds between heart-beats that the sender of the frame guarantees (or +0+ if it will not send heart-beats).
. The desired number of milliseconds between heart-beats that the sender of the frame expects to receive from the other party (or +0+ if it does not want to receive heart-beats).

The sender of +CONNECT+ frame is a STOMP _client_, the sender of a +CONNECTED+ frame is a STOMP _broker_.

A +CONNECTED+ frame with a +heart-beat:0,0+ header indicates that:

. The broker will *not* send heart-beats to the client
. The broker does *not* want to receive heart-beats from the client

Heart-beating is optional. Sending a +CONNECT+ frame without a +heart-beat+ header is equivalent to setting it to +0,0+.

Let's now activate heart-beating upon connection.

We will open a new telnet client for this example and send a +CONNECT+ frame with a +heart-beat+ header:

[[ex_stomp_hb_connect]]
.Connect to a STOMP broker with heart-beat
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
heart-beat:10000,2000<co xml:id="co.ex_stomp_hb_connect_1"/>
login:user
passcode:password

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connect_1">
    <para>The client guarantees to send a heart-beat every 10 seconds (10000ms) and expect to receive heart-beats from the broker every 2 seconds (2000ms).</para>
  </callout>
</calloutlist>
++++
====

The broker replies with a +CONNECTED+ frame but the value of the +heart-beat+ header is different from last time:

[[ex_stomp_hb_connected_with_hb]]
.Connect to a STOMP broker with heart-beat
====
++++
<screen>
<userinput>CONNECTED
heart-beat:2000,10000<co xml:id="co.ex_stomp_hb_connected_with_hb_1"/>
session:ID:retsina.local-60200-1378476149103-2:2
server:ActiveMQ/5.8.0
version:1.2

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connected_with_hb_1">
    <para>The broker replied that it guarantees to send heart-beats every 2 seconds and expect to receive heart-beats from the client every 10 seconds.</para>
  </callout>
</calloutlist>
++++
====

In this case, the heart-beating negotiation is straightforward since the broker replied with the same heart-beat expectation that we send.

[NOTE]
====
TODO: Add some description of the heart-beating negotation when values differ http://stomp.github.io/stomp-specification-1.2.html#Heart-beating
====

If we wait more that 10 seconds, the telnet client is closed:

====
++++
<screen>
Connection closed by foreign host.
</screen>
++++
====

Indeed the telnet client did not fulfill its promises to send heart-beats at least every 10 seconds.

What is a heart-beat? A heart-beat is *any data send over the network*.
If the client does not send any STOMP frame, it must send an end-of-line (EOL) as a heart-beat.

To simulate this, open a new telnet client and send the same +CONNECT+ frame than in <<ex_stomp_hb_connect>> and send a EOL every 10 seconds by typing +Enter+.
You will also notice that a new line appears every 2 seconds. This corresponds to the EOL sent by the broker as an heart-beat.

This client will remain open as long as you send EOL in the imparted time. Note that if you stop sending heart-beats, it may take more that 10 seconds for the broker to closed the connection.
It is considered good practice to leave an error of margin with the heart-beats because of timing inaccuracies (some broker may wait more than twice the heart-beat time before closing the connection).

=== Message acknowledgement

((("STOMP Frames", "ACK")))
((("STOMP Frames", "NACK")))

When a broker delivers a message to a client for consumption, the client must _acknowledge_ the message to inform the broker that it takes responsibility for the message.
With this acknowledgement, the broker can forget everything about the message, it is now under the client's responsibility. As long as the broker has not received such an acknowledgement, it must keep the message
to be able to eventually redeliver it.

.When does this acknowledgement takes place?

The first step happens when the client sends a +SUBSCRIBE+ frame to the broker. The +SUBSCRIBE+ frame takes an optional +ack+ header that accepts three valid values:

* +auto+ (if the +SUBSCRIBE+ frame does not contain a +ack+ header, it defaults to +auto+)
* +client+
* +client-individual+

When the +ack+ header is set to +auto+, the broker will consider the message _automatically_ acknowledged as soon as it is delivered to the client. The client does not need to acknowledge
the message at all. This mode may result in message loss if the client fails *after* the message was delivered but *before* it was processed.

When the client requires more control on the message acknowledgement, it can use either the +client+ or +client-individual+ values.
In both case, the client must send an +ACK+ frame to the broker for the message that it processes.
The +client+ value means the message acknowledgement is _cumulative_, it will acknowledge the specified message _and all the messages received before_. With +client-individual+, only the specified message is acknowledged.

If a client does not process a message it has received, it should send a +NACK+ frame (a negative acknowledgement) to the let the broker know that it refused to take responsibility for the specified message.
The broker can then deliver the message to another consumer.

The +ACK+ and +NACK+ frames require a +id+ header whose value must match the value of the +ack+ header from the +MESSAGE+ frame to acknowledge (or nack).
The +MESSAGE+ frame contains the +ack+ header only when the client specified explicit acknowledgement (+client+ or +client-individual+) in the +SUBSCRIBE+ frame.

We will open a telnet client and subscribe to the destination with an explicit +client+ acknowledgement:

[[ex_stomp_ack_subscribe_client]]
.Subscribe to a STOMP broker with a +client+ acknowledgement
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT<co xml:id="co.ex_stomp_ack_subscribe_client_1"/>
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED<co xml:id="co.ex_stomp_ack_subscribe_client_2"/>
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_ack_subscribe_client_3"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_ack_subscribe_client_4"/>
id:mysub<co xml:id="co.ex_stomp_ack_subscribe_client_5"/>
ack:client<co xml:id="co.ex_stomp_ack_subscribe_client_6"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_1">
    <para>The <literal>CONNECT</literal> frame is sent to connect to the STOMP broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2">
    <para>The <literal>CONNECTED</literal> frame sent by the broker confirms that the client is successfully connected.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_3 co.ex_stomp_ack_subscribe_client_4 co.ex_stomp_ack_subscribe_client_5">
    <para>The client subscribes to the <literal>/queue/myqueue</literal> destination with the subscription identifier <literal>mysub</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_6">
    <para>The client informs the broker that messages received by this subscription will be acknowledged explicitly (and cumulatively).</para>
  </callout>
</calloutlist>
++++
====

The client will now send a message to the destination and receives it through the subscription that has just been created:

[[ex_stomp_ack_send]]
.Send a message to the destination
====
++++
<screen>
<userinput>SEND<co xml:id="co.ex_stomp_ack_send_1"/>
destination: /queue/myqueue
content-type:text/plain
content-length:15

another message
</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_ack_send_2"/>
content-type:text/plain
ack:ID\cretsina.local-49965-1378989016784-4\c1<co xml:id="co.ex_stomp_ack_send_3"/>
message-id:ID\cretsina.local-49965-1378989016784-2\c2\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378989622992
expires:0
subscription:mysub
content-length:15
priority:4

another message
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_send_1">
    <para>The client sends a message to the broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_send_2 co.ex_stomp_ack_send_3">
    <para>The message is processed by the broker and delivered to the client. It contains a <literal>ack</literal> header whose value is an opaque identifier.</para>
  </callout>
</calloutlist>
++++
====

At this point, the client has received the message but has not acknowledged it. The broker will keep it as a reference until the client acknowledges it explicitly.

To illustrate that, the client will disconnect _without acknowledging the message_.

[[ex_stomp_ack_disconnect]]
.Disconnection of the client without acknowledging the message
====
++++
<screen>
<userinput>DISCONNECT

</userinput>^@
Connection closed by foreign host.
</screen>
++++
====

The broker will notice that the delivered message was not acknowledged by the client before it disconnected and will
take again responsibility for it and be ready to deliver it to any other subscribers on the destination.

A new telnet client will subscribe to the destination with a different subscription identifier to receive this message:

[[ex_stomp_ack_subscribe_client_2]]
.Subscribe to a STOMP broker with a +client+ acknowledgement
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_ack_subscribe_client_2_1"/>
destination:/queue/myqueue
id:mynewsub<co xml:id="co.ex_stomp_ack_subscribe_client_2_2"/>
ack:client<co xml:id="co.ex_stomp_ack_subscribe_client_2_3"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_ack_subscribe_client_2_4"/>
content-type:text/plain
redelivered:true<co xml:id="co.ex_stomp_ack_subscribe_client_2_5"/>
ack:ID\cretsina.local-49965-1378989016784-5\c1
message-id:ID\cretsina.local-49965-1378989016784-2\c2\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378989622992
expires:0
subscription:mysub2<co xml:id="co.ex_stomp_ack_subscribe_client_2_6"/>
content-length:15
priority:4

another message
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_1 co.ex_stomp_ack_subscribe_client_2_2">
    <para>The client subscribes again with a new <literal>mynewsub</literal> subscription identifier.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_3">
    <para>This new subscription also require explicit <literal>client</literal> acknowledgement.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_4">
    <para>As soon as the client is subscribed, it receives the <literal>MESSAGE</literal> sent in <xref linkend="ex_stomp_ack_message"/></para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_5 co.ex_stomp_ack_subscribe_client_2_6">
    <para>The message is delivered to the <literal>mysub2</literal> subscription and contains an additional <literal>redelivered</literal>
header set to <literal>true</literal> that informs the client that this message was delivered at least once without success and is redelivered.</para>
  </callout>
</calloutlist>
++++
====

This time, the client will properly acknowledge the message:

[[ex_stomp_ack_ack]]
.Acknowledge a message
====
++++
<screen>
<userinput>ACK
id:ID\cretsina.local-49965-1378989016784-5\c1<co xml:id="co.ex_stomp_ack_ack_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_ack_1">
    <para>The value of the <literal>id</literal> must match the value of the <literal>ack</literal> header
from the <literal>MESSAGE</literal> received in <xref linkend="ex_stomp_ack_subscribe_client_2"/>.</para>
  </callout>
</calloutlist>
++++
====

.Transactional Acknowlegement
[NOTE]
====
Acknowledgements using +ACK+ or +NACK+ frame can be part of a transaction by adding a +transaction+ header to
these frames as explained below in <<ch_stomp_transaction>>.
====

[[ch_stomp_transaction]]
=== Transaction

STOMP has basic support for transactions.

Sending (with +SEND+ frames) or acknowledging (with +ACK+ or +NACK+ frames) messages can be performed inside a transaction.
This means that the messages and acknowledgements are not processed by the broker when it receives the corresponding frames but when the transaction completes.

If the client does not complete the transaction, the broker will not process the frames that it received during the transaction and will discard them.

To illustrate this, we will open a new telnet client and subscribe to the destination.

[[ex_stomp_tx_subscribe]]
.Connect to a STOMP broker and subscribe to a destination
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT<co xml:id="co.ex_stomp_tx_subscribe_1"/>
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED<co xml:id="co.ex_stomp_tx_subscribe_2"/>
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_tx_subscribe_3"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_tx_subscribe_4"/>
id:mysub

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_subscribe_1">
    <para>The <literal>CONNECT</literal> frame is sent to connect to the STOMP broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_subscribe_2">
    <para>The <literal>CONNECTED</literal> frame sent by the broker confirms that the client is successfully connected.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_subscribe_3 co.ex_stomp_tx_subscribe_4">
    <para>The client subscribes to the <literal>/queue/myqueue</literal> destination with the subscription identifier <literal>mysub</literal>.</para>
  </callout>
</calloutlist>
++++
====

((("STOMP Frames", "BEGIN")))

A transaction is started by the client by sending a +BEGIN+ frame to the broker. This frame must have a +transaction+ header whose value is a transaction identifier
_that must be unique within a STOMP connection_.

Sending and acknowledging messages can then be part of this transaction by adding a +transaction+ header to their frames with the same transaction identifier.

[[ex_stomp_tx_begin_send]]
.Begin a transaction and send a message inside it
====
++++
<screen>
<userinput>BEGIN<co xml:id="co.ex_stomp_tx_begin_send_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_begin_send_2"/>

</userinput>^@

<userinput>SEND<co xml:id="co.ex_stomp_tx_begin_send_3"/>
destination:/queue/myqueue
content-type:text/plain
content-length:24
transaction:mytx1<co xml:id="co.ex_stomp_tx_begin_send_4"/>

Message in a transaction</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_begin_send_1 co.ex_stomp_tx_begin_send_2">
    <para>The client begins a transaction by sending a <literal>BEGIN</literal> frame with a <literal>transaction</literal> header
set to <literal>mytx1</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_begin_send_3 co.ex_stomp_tx_begin_send_4">
    <para>The client sends a <literal>SEND</literal> frame inside the transaction by adding a <literal>transaction</literal> header
with the same value than in the <literal>BEGIN</literal> frame.</para>
  </callout>
</calloutlist>
++++
====

At this point, the +MESSAGE+ frame has been received by the broker. However the broker has not processed it and deliver the message to the client's subcription created in <<ex_stomp_tx_subscribe>>.

((("STOMP Frames", "COMMIT")))

To complete this active transaction and allows the broker to process it, the client must send a +COMMIT+ frame with the same
+transaction+ header.

[[ex_stomp_tx_commit]]
.Commit a transaction and receives the message after the transaction is completed
====
++++
<screen>
<userinput>COMMIT<co xml:id="co.ex_stomp_tx_commit_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_commit_2"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_tx_commit_3"/>
content-type:text/plain
message-id:ID\cretsina.local-49965-1378989016784-2\c4\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378994631546
expires:0
subscription:mysub
content-length:24
priority:4

Message in a transaction
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_commit_1 co.ex_stomp_tx_commit_2">
    <para>The client completes the transaction by sending a <literal>COMMIT</literal> frame with the same <literal>transaction</literal> header
than  in the <literal>BEGIN</literal> frame.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_commit_3">
    <para>The client finally receives the message sent inside the transaction in <xref linkend="ex_stomp_tx_begin_send"/>.</para>
  </callout>
</calloutlist>
++++
====

((("STOMP Frames", "ABORT")))

To roll back a transaction and discard any messages or acknowledgements sent inside it, the client can send an +ABORT+ frame with the same +transaction+ header than in
the corresponding +BEGIN+ frame that started the transaction:

[[ex_stomp_tx_abort]]
.Abort a transaction
====
++++
<screen>
<userinput>ABORT<co xml:id="co.ex_stomp_tx_abort_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_abort_2"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_abort_1 co.ex_stomp_tx_abort_2">
    <para>The client rolls back the transaction by sending an <literal>ABORT</literal> frame with the same <literal>transaction</literal> header
than in the <literal>BEGIN</literal> frame.</para>
  </callout>
</calloutlist>
++++
====

STOMP does not provide a transaction timeout that would abort the transaction if it is not completed in a timely fashion.
The transaction lifecycle (controlled by +BEGIN+ and +COMMIT+/+ABORT+ frames) is the responsibility of the client.
However the broker will automatically abort any active transaction if the client send a +DISCONNECT+ frame or if the underlying TCP
connection fails.

==== Transaction and Receipt

In <<ch_stomp_receipt>>, we saw that the client can receive a +RECEIPT+ frame when the broker has received the frame and pointed out it does mean that the broker _processed_ it.

We can confirm this behaviour by sending a message inside a transaction and ask for a receipt:

[[ex_stomp_tx_receipt]]
.Ask a receipt for a message sent inside a transaction
====
++++
<screen>
<userinput>BEGIN<co xml:id="co.ex_stomp_tx_receipt_1"/>
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_2"/>

</userinput>
^@

<userinput>
SEND<co xml:id="co.ex_stomp_tx_receipt_3"/>
destination:/queue/myqueue
content-type:text/plain
content-length:32
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_4"/>
receipt:myreceipt1<co xml:id="co.ex_stomp_tx_receipt_5"/>

Another message in a transaction</userinput>^@
RECEIPT<co xml:id="co.ex_stomp_tx_receipt_6"/>
receipt-id:myreceipt1
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_receipt_1 co.ex_stomp_tx_receipt_2">
    <para>The client begins a transaction named <literal>mytx2</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_3 co.ex_stomp_tx_receipt_4 co.ex_stomp_tx_receipt_5">
    <para>The client sends a message inside this transaction and asks for a receipt.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_6">
    <para>As soon as the broker receives the <literal>MESSAGE</literal>, it sends a <literal>RECEIPT</literal> to the client
to confirm the message has been received. However the message has not be processed yet. It will be processed only when the transaction is commited.</para>
  </callout>
</calloutlist>
++++
====

We see above that the broker confirmed that it received the +MESSAGE+ but it has not processed it.

Only when the client commits the transaction, the client will process the message and deliver it to the client's subscription:

[[ex_stomp_tx_receipt_commit]]
.The message is processed by the broker only when the transaction is committed
====
++++
<screen>
<userinput>COMMIT<co xml:id="co.ex_stomp_tx_receipt_commit_1"/>
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_commit_2"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_tx_receipt_commit_3"/>
content-type:text/plain
message-id:ID\cretsina.local-49965-1378989016784-2\c4\c-1\c1\c2
destination:/queue/myqueue
timestamp:1378996600008
expires:0
subscription:mysub
content-length:32
priority:4

Another message in a transaction
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_receipt_commit_1 co.ex_stomp_tx_receipt_commit_2">
    <para>The client commits the transaction named <literal>mytx2</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_commit_3">
    <para>When the transaction is commited, the broker finally process the <literal>SEND</literal> frame sent in <xref linkend="ex_stomp_tx_receipt"/> and
deliver it to the client's subscription.</para>
  </callout>
</calloutlist>
++++
====

[[ch_stomp_ext]]
=== STOMP Extensions

STOMP protocol is very simple with few commands to know to be able to use it.

The protocol does not define advanced features that are often provided by messaging brokers such as persistency or expiration.

However, it is possible to use them from STOMP thanks to the additional /non-standard/ headers.

In the <<ex_stomp_receive2>>, the two messages received by the consumers were containing headers that have not been described yet: 
+timestamp+, +expires+ and +priority+.

The headers are added by ActiveMQ to provide additional information on the messages.

* +timestamp+ value corresponds to the time the message was handed off to the broker (it is an interval in milliseconds since the UNIX epoch).
* +expires+ value corresponds to the message expiration time. When a message exipration time is reached and it has not been consumed, the broker discards it.
  In the example, the +expires+ value is +0+ which mean that the messages _never_ expires.
* +priority+ value is the priority level of the message (+0+ being the lowest priority and +9+ being the highest). The broker tries
to deliver higher priority messages ahead of lower priority ones. In the example, the value is +4+ which corresponds to a normal priority.

ActiveMQ defines other headers that can be add to the +SEND+ frame when sending a message (as described in (http://activemq.apache.org/stomp.html[ActiveMQ STOMP page]).

[NOTE]
====
TODO: Cross-reference with message persistence concept.
====

One of the most important is the +persistent+ header. By default, STOMP does not define whether messages are _persistent_ or not.
Most STOMP brokers (including ActiveMQ) defaults to _non-persistent_ messages. To send a persistent message to an ActiveMQ broker,
the client must add a +persistent+ header whose value is +true+.

[[ex_stomp_ext_persistent]]
.Send a peristent message
====
++++
<screen>
<userinput>SEND
destination:/queue/myqueue
content-type:text/plain
content-length:26
persistent:true<co xml:id="co.ex_stomp_ext_persistent_1"/>

This message is persisted!^@
</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ext_persistent_1">
    <para>The message will be persisted by the broker and will be available if the server crashes or stops.</para>
  </callout>
</calloutlist>
++++
====

If the message is not consumed when the broker goes offline, the broker will load it when it restarts and consumers will be able to receive it.

Each STOMP brokers may define its own set of headers and you have to consult their documentation to know which additional features are supported.
