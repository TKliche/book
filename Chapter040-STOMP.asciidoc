[[ch_stomp]]
== STOMP

[role="lead"]
In this chapter, we present the STOMP protocol, a simple text-based messaging
protocol that is well suited to build lightweight messaging applications on any platforms.

STOMP provides an interoperable wire format so that clients can communicate with any message broker.
The simplicity of the protocol ensures that it's straightforward to have interoperability between any client and brokers.

This chapter covers the latest released version of the protocol:
http://stomp.github.io/stomp-specification-1.2.html[STOMP 1.2]

=== Anatomy of a STOMP Frame

STOMP is modelled on HTTP and based on _frames_.
Each frame is composed of 3 elements:

* a _command_
* an (optional) set of _headers_
* an (optional) _payload_

[[ex_stomp_frame]]
.STOMP Frame Structure
====
----
COMMAND        <1>
header1:value1 <2>
header2:value2
               <3>
payload^@      <4>
----
<1> A frame starts with a command string followed by an end-of-line (EOL)
<2> Header entries followed the format +<key>:<value>+ and is ended by EOL
<3> A blank line separates the set of headers from the payload
<4> A frame is ended by a NULL octet (represented by +^@+ in ASCII)
====

STOMP is based on text (using UTF-8 for its default encoding)
but it can also transmit binary data in its payload by specifying an alternative encoding.

A STOMP client can serve two messaging roles:

[NOTE]
====
TODO: cross-reference with the messaging concepts of producer and consumer
====

. It can be a _producer_ and send messages with +SEND+ frames
(i.e. frames with the +SEND+ command)
. It can be a _consumer_ and subscribe to receive messages using a +SUBSCRIBE+ frame. Each received messages will be delivered by the broker to the client as +MESSAGE+ frames.

Messages are *pushed* to STOMP clients. The protocol does not offer any command to pull messages from the broker.

=== Commands

A STOMP frame starts with a command string terminated by an end-of-line (EOL).

+SEND+, +SUBSCRIBE+, +MESSAGE+, along with +CONNECT+ (resp. +DISCONNECT+) used to connect (resp. disconnect) to the broker, are the principal commands.

Other commands correspond to additional features (message acknowledgement, transaction, receiption and error handling).

This chapter describes all the commands supported by STOMP 1.2.

==== Headers

Following the command string, a STOMP frame accepts an optional set of headers.
A header follows the format +<key>:<value>+ and is terminated by an EOL.

The end of the headers is indicated by an empty blank line.

Some headers are defined in the specification and are mandatory for a given frame.
For example, a +SEND+ frame must have a +destination+ header to indicate the destination of the messages.

Other headers are optional.
For example, if a +SEND+ frame contains a payload, it should also include both +content-type+ and +content-length+ headers.

==== Payload

After the headers, a STOMP frame may contain a payload.

Only +SEND+, +MESSAGE+ and +ERROR+ frames can contain payload.

The payload in +SEND+ and +MESSAGE+ are the user data that are exchanged between the client and the broker.

A messaging broker may send +ERROR+ frames to the client if something went wrong.
The +ERROR+ frame may contain a payload with detailed information about the problem (in addition to a short description in a +message+ header).

Finally, a STOMP frame is always terminated by a NULL octet (+^@+).

=== Connection

.Install and configure a messaging broker
[IMPORTANT]
====
Before using a STOMP client, a messaging broker must be installed and

configured to be able to exchange messages.

In the book, we use Apache ActiveMQ as the messaging broker. The <<appendix_activemq>>
appendix shows how to install and configure ActiveMQ with STOMP.

Once ActiveMQ is started, it accepts STOMP connections on +localhost:61613+.
====

Since STOMP is text-based, we can send and receive message from the command
line using a +telnet+ client.

[[ex_stomp_telnet]]
.Connection with a telnet client
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</screen>
++++
====

The telnet client is now connected to the broker using a TCP connection.
It must also establish a STOMP connection by sending a +CONNECT+ frame:

[[ex_stomp_connect]]
.Connect to a STOMP broker
====
++++
<screen>
<userinput>CONNECT
accept-version: 1.2 <co xml:id="co.ex_stomp_connect_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connect_1">
    <para>The <literal>accept-version</literal> indicates we want to communicate
with the broker using the version 1.2 of the protocol</para>
  </callout>
</calloutlist>
++++
====

[CAUTION]
====
A STOMP frame must be ended by a NULL octet.

The +^@+ is the ASCII character for NULL octet. Type +ctrl + @+ to enter it.
====

Note also that there is a blank line between the +accept-version+ header and the NULL octet.
The blank line is mandatory to determine the end of the headers and the beginning
of the optional payload (that is not present in the +CONNECT+ frame).

Once you type +ctrl + @+, the messaging broker will process the +CONNECT+ frame
and reply with a +CONNECTED+ frame:

[[ex_stomp_connected]]
.Receive a connection confirmation
====
++++
<screen>
CONNECTED                                         <co xml:id="co.ex_stomp_connected_1"/>
heart-beat:0,0                                    <co xml:id="co.ex_stomp_connected_2"/>
session:ID:retsina.local-64904-1378366884467-2:1  <co xml:id="co.ex_stomp_connected_3"/>
server:ActiveMQ/5.8.0                             <co xml:id="co.ex_stomp_connected_4"/>
version:1.2                                       <co xml:id="co.ex_stomp_connected_5"/>
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connected_1">
    <para>The <literal>CONNECTED</literal> frame means the connection was successful.
 If there were any problem during the connection, an <literal>ERROR</literal> frame would have been returned.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_2">
    <para>The <literal>heart-beat</literal> header is explained below in <xref linkend="ch_stomp_heartbeat"/>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_3">
    <para>The <literal>session</literal> header uniquely identifies the session between the client and the broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_4">
    <para>The <literal>server</literal> header contains information about the STOMP broker. In that example, we are connected to Apache ActiveMQ 5.8.0.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_5">
    <para>The <literal>version</literal> header is the version of the STOMP protocol that will be used during the session.</para>
  </callout>
</calloutlist>
++++
====

The STOMP connection is now established and the telnet client can now exchange messages with the broker.

=== Send a Message

Now that the telnet client is connected to the messaging broker, it can send a message to a _destination_ on the broker.

_Destinations_ are opaque strings specific to each messaging broker implementation.

STOMP itself has no notion of delivery semantics (whether a destination is a queue, a topic or another exchange type) and you have to consult the messaging broker documentation to check how to name the destination for STOMP.

[NOTE]
====
ActiveMQ convention is to prefix the destination by +/queue/+ to send to a queue.
To send to a topic, we would prefix the destination by +/topic/+ instead.

ActiveMQ will automatically create a destination based on the +destination+ header so we do not have to create it beforehands.
Other brokers may behave differently and require to create the destination before sending any messages to it.
====

[[ex_stomp_send]]
.Send a message
====
++++
<screen>
<userinput>SEND
destination: /queue/myqueue <co xml:id="co.ex_stomp_send_1"/>

Hello, STOMP!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_1">
    <para>The message must be sent to the <literal>/queue/myqueue</literal> destination.</para>
  </callout>
</calloutlist>
++++
====

[NOTE]
====
TODO: cross-reference to the queue concept (one-to-one)
====

By following ActiveMQ convention, the message was sent to a queue. This message can only be received by a single consumer.

The +destination+ header indicates the destination of the message.

It also contains payload with the text +Hello, STOMP!+.
The payload is immediately followed by the NULL octet (represented by +^@+) to end the frame.

Once you +ctrl + @+ to enter the NULL octet, the message is processed by the broker.

==== Frame Receiption

The STOMP broker can sent some feedback to let the client know that a frame has been *processed*. This is a general mechanism available on any frame sent by a client to a broker (and not only on the +SEND+ frame).

To receive a confirmation that a message is handled by the STOMP broker, you can use a +receipt+ header with an ID to ask for a +RECEIPT+ frame

[[ex_stomp_send_with_receipt]]
.Send a message with a receipt
====
++++
<screen>
<userinput>SEND
destination: /queue/myqueue
receipt: 123 <co xml:id="co.ex_stomp_send_with_receipt_1"/>

Hello, STOMP with a receipt!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_with_receipt_1">
    <para>The <literal>receipt</literal> header will serve to identify the receipt sent by the broker
when it will have successfully handle this <literal>SEND</literal> frame.</para>
  </callout>
</calloutlist>
++++
====

When this +SEND+ frame is received by the broker and handled, the broker replies with a +RECEIPT+ frame containing the corresponding receipt ID in a +receipt-id+ header:

[[ex_stomp_receipt]]
.Receive the receipt
====
++++
<screen>
RECEIPT
receipt-id: 123 <co xml:id="co.ex_stomp_receipt_1"/>

</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receipt_1">
    <para>The <literal>receipt-id</literal> header corresponds to the <literal>receipt</literal> header set on the frame
that has been successfully processed by the broker.</para>
  </callout>
</calloutlist>
++++
====

==== Error frame

If a message is sent with an invalid format, the messaging broker will reply immediately with an +ERROR+ frame.

For example, it is not valid to send a message without a +destination+ header (where would the message go?):

[[ex_stomp_invalid_send]]
.Send an invalid message
====
++++
<screen>
<userinput>SEND
<co xml:id="co.ex_stomp_invalid_send_1"/>

A SEND frame witout a destination is not allowed</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_invalid_send_1">
    <para>The <literal>destination</literal> header is missing.</para>
  </callout>
</calloutlist>
++++
====

Once the message is sent, the client receives an +ERROR+ frame:

[[ex_stomp_error]]
.Receive an error
====
++++
<screen>
ERROR
content-type:text/plain                                <co xml:id="ex_stomp_error_1"/>
message:SEND received without a Destination specified! <co xml:id="ex_stomp_error_2"/>
                                                       <co xml:id="ex_stomp_error_3"/>
org.apache.activemq.transport.stomp.ProtocolException: SEND received without a Destination specified!
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:299)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)
        ...
</screen>
<calloutlist>
  <callout arearefs="ex_stomp_error_1">
    <para>This <literal>ERROR</literal> frame has a <literal>content-type</literal> header that let the client know the payload is in plain text (encoded in UTF-8 by default)</para>
  </callout>
  <callout arearefs="ex_stomp_error_1">
    <para>A <literal>ERROR</literal> frame contains a <literal>message</literal> header with a short description of the problem encountered by the broker.</para>
  </callout>
  <callout arearefs="ex_stomp_error_1">
    <para>It also contains a text payload with more information on the problem. In this case, the problem is:<literal>SEND received without a Destination specified</literal>.</para>
    </callout>
</calloutlist>
++++
====

=== Receive a Message

So far, we have use telnet client as a STOMP _producer_ to send messages.

We will now use it as a STOMP _consumer_ to receive the messages we have sent.

To receive messages, a STOMP client must send a +SUBSCRIBE+ with a +destination+ header.

[[ex_stomp_subscribe]]
.Subscribe to a destination
====
++++
<screen>
<userinput>SUBSCRIBE
destination: /queue/myqueue
id: mysub <co xml:id="co.sub"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.sub">
    <para>The subscription will be identified by the <literal>mysub</literal> ID.</para>
  </callout>
</calloutlist>
++++
====

We must also indicate a +id+ header that corresponds to the subscription ID.
It is the responsibility of the client to choose this ID.

As soon as the messaging broker will receive this +SUBSCRIBE+ frame,
it will start to send to the STOMP client +MESSAGE+ frames corresponding to the message sent to this destination.

[[ex_stomp_receive2]]
.Receive two messages
====
++++
<screen>
MESSAGE                                                         <co xml:id="co.ex_stomp_receive2_1"/>
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c1 <co xml:id="co.ex_stomp_receive2_2"/>
destination:/queue/myqueue                                      <co xml:id="co.ex_stomp_receive2_3"/>
timestamp:1378367602698
expires:0
subscription: mysub                                             <co xml:id="co.ex_stomp_receive2_4"/>
priority:4

Hello, STOMP!
MESSAGE                                                         <co xml:id="co.ex_stomp_receive2_5"/>
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c2
destination:/queue/myqueue
timestamp:1378368275375
expires:0
subscription: mysub
priority:4

Hello, STOMP with a receipt!
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receive2_1 co.ex_stomp_receive2_5">
    <para>Each received message is contained in a <literal>MESSAGE</literal> frame.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_2">
    <para>An unique <literal>message-id</literal> can be used to identify uniquely a message.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_3">
    <para>The <literal>destination</literal> indicates the destination this message was consumed from.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_4">
    <para>The <literal>subscription</literal> indicates which consumer is receiving the message.</para>
  </callout>
</calloutlist>
++++
====

We have received the 2 messages that we have previously sent in the two examples
above (<<ex_stomp_send>> and <<ex_stomp_send_with_receipt>>).

The telnet client is now both a producer and a consumer. If we send another message, we will receive it immediately:

[[ex_stomp_send_receive]]
.Example Send a message and receive it
====
++++
<screen>
<userinput>SEND
destination:/queue/myqueue

another message</userinput>^@

MESSAGE
message-id:ID\cretsina.local-64904-1378366884467-2\c3\c-1\c1\c3
destination:/queue/myqueue
timestamp:1378369910799
expires:0
subscription: mysub
priority:4

another message
</screen>
++++
====

=== Unsubscription

To stop consuming messages from a destination, the client must send a +UNSUBSCRIBE+ frame
with a +id+ header corresponding to the subscription ID indicated in the +SUBSCRIBE+ frame (+mysub+ in the example above).

[[ex_stomp_unsubscribe]]
.Unsubscribe a consumer
====
++++
<screen>
<userinput>UNSUBSCRIBE
id: mysub

</userinput>^@
</screen>
++++
====

The telnet client can still send messages but it will no longer receive those sent to the +queue/myqueue+ destination.

=== Disconnection
To disconnect from the messaging broker, the client must send a +DISCONNECT+ frame.

To ensure a graceful disconnection, the best practice is to send a +DISCONNECT+ frame
with a +receipt+ header and wait to receive the corresponding +RECEIPT+ frame.
The client can then safely close the socket that is connected to the messaging broker.

[[ex_stomp_disconnect]]
.Grafecul disconnection
====
++++
<screen>
<userinput>DISCONNECT
receipt: 456

</userinput>^@
</screen>
++++
====

When the +DISCONNECT+ frame is sent, the client receives the corresponding +RECEIPT+ frame.

[[ex_stomp_disconnect_receipt]]
.Receive a receipt for the graceful disconnection
====
++++
<screen>
RECEIPT
receipt-id: 456
</screen>
++++
====

The messaging broker then closes its socket and the telnet client is closed:

++++
<screen>
Connection closed by foreign host.
</screen>
++++

[[ch_stomp_heartbeat]]
=== Heart-beat

STOMP offers a mechanism to test the healthiness of a connection between a STOMP client and a broker

[NOTE]
====
TODO: better explanation on the necessity of heart-beating to circumvent TCP.
====

Heart-beat is negotiated between the client and the broker during the exchange of the +CONNECT+ and +CONNECTED+ frames.

When we connected previous in <<ex_stomp_connect>>, we received a +CONNECTED+ (in <<ex_stomp_connected>> ) with a header +heart-beat:0,0+.

The +heart-beat+ header's value is composed of 2 positive integers:

. The smallest number of milliseconds between heart-beats that the sender of the frame guarantees (or +0+ if it will not send heart-beats).
. The desired number of milliseconds between heart-beats that the sender of the frame expects to receive from the other party (or +0+ if it does not want to receive heart-beats).

The sender of +CONNECT+ frame is a STOMP client, the sender of a +CONNECTED+ frame is a STOMP broker.

A +CONNECTED+ frame with a +heart-beat:0,0+ header indicates that:

. The broker will *not* send heart-beats to the client
. The broker does *not* want to receive heart-beats from the client

Heart-beating is optional. Sending a +CONNECT+ frame without a +heart-beat+ header is equivalent to setting it to +0,0+.

Let's now activate heart-beating upon connection.

We will open a new telnet client for this example and send a +CONNECT+ frame with a +heart-beat+ header:

[[ex_stomp_hb_connect]]
.Connect to a STOMP broker with heart-beat
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version: 1.2
heart-beat: 10000,2000 <co xml:id="co.ex_stomp_hb_connect_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connect_1">
    <para>the client guarantee to send a heart-beat every 10 seconds (10000ms) and expect to receive heart-beats from the broker every 2 seconds (2000ms).</para>
  </callout>
</calloutlist>
++++
====

The broker replies with a +CONNECTED+ frame but the value of the +heart-beat+ header is different from last time:

[[ex_stomp_hb_connected_with_hb]]
.Connect to a STOMP broker with heart-beat
====
++++
<screen>
<userinput>CONNECTED
heart-beat:2000,10000  <co xml:id="co.ex_stomp_hb_connected_with_hb_1"/>
session:ID:retsina.local-60200-1378476149103-2:2
server:ActiveMQ/5.8.0
version:1.2

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connected_with_hb_1">
    <para>The broker replied that it guarantees to send heart-beat every 2 seconds and expect to receive heart-beats from the client every 10 seconds.</para>
  </callout>
</calloutlist>
++++
====

In this case, the heart-beating negotiation is straightforward since the broker replied with the same heart-beat expectation that we send.

[NOTE]
====
TODO: Add some description of the heart-beating negotation when values differ http://stomp.github.io/stomp-specification-1.2.html#Heart-beating
====

If we wait more that 10 seconds, the telnet client is closed:

====
++++
<screen>
Connection closed by foreign host.
</screen>
++++
====

Indeed the telnet client did not fulfill its promises to send heart-beats at least every 10 seconds.

What is a heart-beat? A heart-beat is *any data send over the network*.
If the client does not send any STOMP frame, it must send an end-of-line (EOL) as a heart-beat.

To simulate this, open a new telnet client and send the same +CONNECT+ frame than in <<ex_stomp_hb_connect>> and send a EOL every 10 seconds by typing +Enter+.
You will also notice that a new line that appears every 2 seconds. This corresponds to the EOL sent by the broker as an heart-beat.

This client will remain open as long as you send EOL in the imparted time. Note that if you stop sending heart-beats, it may take more that 10 seconds for the broker to closed the connection.
It is considered good practice to leave an error of margin with the heart-beats because of timing inaccuracies (some broker may wait more than twice the heart-beat time before closing the connection).

=== Message acknowledgement

TODO

=== Transaction

use case

tx begin
send message with tx + receipt
=> no receipt?
tx commit
=> get receipt?

=== Authentication

TODO

=== STOMP extensions
