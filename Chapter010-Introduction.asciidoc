[[ch_introduction]]
== Introduction

[role="lead"]
In this chapter, I present the main concepts of messaging protocols.
To illustrate their use on mobile and Web platforms, we will write two application (one for each messaging protocols that are described, STOMP and MQTT). This chapter will present the overal design of these two applications that will be written in the subsequent chapters.

=== Messaging Concepts

In the preface, I introduces messaging protocols in two sentences and five concepts:

* An application _produces_ a _message_ to a _destination_ on a _broker_.
* An application subscribes to this same destination to _consume_ the message.

Let's now define these five concepts:

. A _message_ is the data exchanged between applications
. A _destination_ is a type of address that is used to exchange messages
. A _producer_ is an application that sends _messages_ *to* a _destination_
. A _consumer_ is an application that consumes _messages_ *from* a _destination_
. A _broker_ is the server entity that will handle messages from producers and delivers them to the consumers according to their destinations.

[[img_preface_messaging_concepts]]
.Messaging Concepts
image::images/Chapter010/messaging_concepts.png["Diagram of the messaging concepts"]

The simplicity of messaging can be deceiving but it is this simplicity that allows to use it in powerful ways.

.Messaging Terminology
[NOTE]
====
Depending on the messaging protocol or model, the _producer_ is sometimes called _sender_ or _publisher_. Likewise, the _consumer_ may be called _receiver_ or _subscriber_.

In this book, I will always use the general terms of _producer_ and _consumer_.
====

One key aspect of messaging is that it loosely couples its participants. The producer and consumer know nothing of each other. When one application produces a message, it has no knowledge on when or where the message will be consumed.
There may be one or many consumers that will receive the message. It also possible that the message will not be consumed at all if nobody has registered any interest for it.

Likewise, when an application consumes a message, it does not know which application sent it.

++++
<remark>Add an example about this.</remark>
++++

Producers and consumers do not even need to be online at the same time. The producers can send a message and exit. The message will be held by the broker until a consumer subscribes to the same destination. At that moment, the broker will deliver the message to the consumer.

Producers and consumers need to know about the broker to connect to it but they may even not connect to the same broker. A set of brokers can constitute a cluster and messages would flow from one to another before it is finally delivered to a consumer.

=== Messaging Models

A messaging model describes how the messages will be routed between the producer and consumers.

There are two main messaging models:

* Point-to-Point
* Publish/Subscribe

==== Point-to-Point

In a Point-to-Point messaging model, a message sent by a producer will be routed to a single consumer.

The producer sends a message to a destination identified as a _queue_ in that messaging model. There can be zero, one or many consumers subscribed (or _bound_) to this queue and the messaging broker will route incoming messages to only one of these consumers to deliver the message.
As illustrated in <<img_intro_point_to_point>>, when the producer sends a message to the queue, only one of the consumers that are subscribed receives the message.

[[img_intro_point_to_point]]
.Diagram of the Point-to-Point Topology
image::images/Chapter010/point_to_point.png["Diagram of the Point-to-Point Topology"]

This messaging model is also called _one-to-one_: for _one_ message sent by a producer to the queue, there is only _one_ consumer that will receive it.

If there are no consumers bound to the queue, the broker will retain the incoming messages until a consumer subscribes and then deliver the message to this consumer.
Some messaging brokers also allows to _expire_ messages if they remain in the queue for a certain amount of time. This can be useful to avoid having consumers receive message corresponding to stale data.

==== Publish/Subscribe

In a Publish/Subscribe messaging model (often shortened as pub/sub), a message sent by a producer is routed to many consumers.

The producer sends a message to a destination identified as a _topic_ in that messaging model. There can be none or many consumers subscribed to this topic and the messaging broker will route incoming message to _all_ these consumers to deliver the message. If there are no consumers bound to the topic, the broker will _not_ retain the incoming messages.
As illustrated in <<img_intro_pub_sub>>, when the producer sends a message to the topic, all the consumers that are subscribed receive the message.

[[img_intro_pub_sub]]
.Diagram of the Publish/Subscribe Topology
image::images/Chapter010/pub_sub.png["Diagram of the Point-to-Point Topology"]

This messaging model is also called _one-to-many_: for _one_ message sent by a producer to a topic, there are _many_ consumers that will receive it.

When a message is sent to a topic in this model, we often say that it is _broadcasted_ to all consumers as they will all receive it.

Some protocols defines the notions of _durable subscribers_. If a consumer subscribes to the topic as a durable subscriber, the broker will retain messages when the consumer is offline and deliver the messages sent to the topic during its downtime when the consumer comes online again.

=== Message Representation

Producers and consumers exchanges information using messages. 

A message is composed of three separate data: destination, headers, and body

[[img_intro_message_representation]]
.Diagram of a Message
image::images/Chapter010/message_representation.png["Diagram of a Message"]

When a producer sends a message to a _destination_, the name of the destination is put inside the message. When a consumer receives this message, it can use this information to know which destination held this message. This is especially useful when a consumer is subscribes to many destinations as it helps identify the exchanged data.

A message also contains _headers_. Messaging protocols uses headers to add metadata information to the messages. These metadata can be read by the consumers and give addition contextual information to a message. Examples of such metadata are message identifiers (that uniquely identify a message for a broker), timestamp (the date and time it was sent by the producer), redelivered flag (if the message was delivered unsuccessfully a first time and is delivered again), etc.
Headers are specific to messaging protocols. Some messaging protocols (such as STOMP) allows the producer to set application-specific headers in addition to the headers defined by the protocol. Other protocoles (such as MQTT) does not allow to set application-specific headers. In that case, the producer has to put any application-specific information in the message payload.

Finallyn, a message can have an optional _body_ (or payload) that contains the data exchanged between the producer and consumer. The type of body depends on the messaging protocols, some defining text payload (such as STOMP) or binary (MQTT). A payload is an _opaque blob of content_. The broker do not read or modify it when it holds a message.

In most cases, we will only use the message body to pass information using a variety of format (JSON string, simple plain string, array of float values, etc.). However if the protocol permits it, we will also set additional headers to the message to give metadata information to the body (the type of its content, its length, etc.).

=== Differences With Request/reply Protocol

++++
<remark>
TODO More about the difference between request/reply protocol and messaging protocols, strengths/weaknesses,...
</remark>
++++

HTTP hits the sweet spot between simplicity and efficiency. It has few disadvantages but one of the main is that it follows a request/reply pattern where the client must _initiate_ a request to get a _reply_ from the server. In other words, the server can not send data to the HTTP client if this one does not send a request first. There are workarounds to overcome this challenge but they bring additional issues when they are used. Messaging protocols are well suited for this kind of use cases.
