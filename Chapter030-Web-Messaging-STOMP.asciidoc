[[ch_web_stomp]]
== Web Messaging With STOMP

[role="lead"]
In this chapter, we will write a Web application that sends and receives messages using the STOMP protocol over HTML5 Web Sockets.

=== Web Browser Communication Model

One-way communication from the browser to the server. The server could not send data to the browser without the browser first initiating the conversation.

=== HTML5 Web Sockets

Thanks to HTML5 Web Sockets, it is now possible to have two-way communication between the browser and the server. The server can now send data to the browser without the client initiating the conversation. This enables to push messages from the Web server to the browser.

We are no longer limited to pull-based messages where the browser need to regularly contact the server to know whether there are any available messages to consume.

=== stomp.js, a JavaScript library for STOMP

stomp.js is a small JavaScript library that implements the STOMP protocol over HTML 5 Web Sockets and allows to send and receive STOMP messages in a Web browser.

TODO

=== Write the Control Center Web App

As we explained in the first chapter, the _Control Center_ Web will be use to follow the position of all the trucks in the fleet 
and send them orders.

It will be a very simple one-page Web application that can be run from a Web server serving static pages. It does not require
any server-side runtime as all the code will be executed inside the Web browser using JavaScript.

Let's bootstrap the Web application by creating a *__control.html__* page.

[[ex_web_stomp_1]]
====
[source,html]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="width=device-width" name="viewport">
    <meta charset="utf-8">
    <title>Truck Tracker Control Center</title>
  </head>
  <body>
    <h1>Truck Tracker Control Center</h1>
      <form id='connect_form'>
        <fieldset>
          <label>WebSocket URL</label>
          <input name=url id='connect_url' value='ws://localhost:61614' type="text">
          <button id='connect_button' type="submit">Connect</button>
          <button type="button" id='disconnect_button' disabled>Disconnect</button>
        </fieldset>
      </form>
      <form id="order_form" style="display: none;">
        <fieldset>
          <legend>Send order to a truck</legend>
          Truck: <select id="truckID"></select>
          <br>
          Order: <input id='order' size=64 placeholder="type the order to sent to the truck" type="text">
          <br>
          <button id='order_submit' type="submit">Send</button>
        </fieldset>
      </form>
      <hr>
      
      <div id="map-canvas" style="height:512px; width:100%; padding:0; margin:0">
      </div>


      <!-- Scripts placed at the end of the document so the pages load faster -->
      <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
      <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
      <script src="https://raw.github.com/jmesnil/stomp-websocket/v2.3.0/lib/stomp.min.js"></script>
      <script>
$(document).ready(function() {

// We will put all the JavaScript code in this block that is called
// when the document is ready

}
    </script>
  </body>
</html>
----
====

=== Create stomp.js Client

The STOMP client will be used for both consuming messages (from the trucks' position destination) and producing them (to the truck's orders queue).

We will declare the +client+ variable to use it throughout our script.

[[ex_web_stomp_1]]
====
[source,js]
----
$(document).ready(function() {

  var client; // keep a reference on the Stomp client that we will create

}

----
====

Once we have the +client+ object, we call **`connect`** by passing the credentials (login and password) and a function that will be called back
once the client has been successfully connected to the STOMP broker.

[[ex_web_stomp_2]]
====
[source,js]
----
    client.connect(login, passcode, function(frame) {
        // this function is executed after a successful connection to the STOMP broker.
    });
----
====

The Web page has a button with the id +connect_button+ to connect to the STOMP broker that is handled using jQuery. When the user clicks this button, we will create the +client+ object and connect to the STOMP broker Web Socket URL.

[source,js]
----
  // Connection to the STOMP broker
  $('#connect_form').submit(function() {
    var url = $("#connect_url").val();

    // create the STOMP client
    client = Stomp.client(url);

    client.connect("", "", function(frame) {
      client.debug("connected to Stomp");
      // TODO once the client is connected, subscribe to the truck's position destinations.
    });
    // disable the connect button
    $("#connect_button").prop("disabled",true);
    // enable the disconnect button
    $("#disconnect_button").prop("disabled",false);
    // show the form to send orders to the trucks
    $("#order_form").show();
    return false;
  });
----

If we want to be notified when the connection is *unsuccesful*, we can pass a fourth parameters to the `connect` method which is a call back that is executed in case of problem.

[[ex_web_stomp_3]]
====
[source,js]
----
    client.connect(login, passcode, function(frame) {
        // this function is executed after a successful connection to the STOMP broker.
      }, function(frame) {
        // this function is executed if the connection to the STOMP broker failed.
    });
----
====

Note that we passed empty strings to the +connect+ method's first and second parameters as we have not configured any security authentication in our STOMP broker.

=== Receive Messages with stomp.js

Once the client is connected successfully to the STOMP broker, it can subscribe to a destination using the **`subscribe`** method which takes two parameters: the name of the destination and a callback method that 
is executed every time a message is pushed from the broker to the client:

[[ex_web_stomp_4]]
====
[source,js]
----
client.subscribe(destination, function(message) {
  // this function is executed every time a message is received
});
----
====

The `message` parameter that is passed to the subscription callback corresponds to a STOMP message and has 3 properties:

* **`command`** - the command of the STOMP frame (when a message is receives, it will always be `MESSAGE`)
* **`headers`** - a JavaScript object containing all the frame headers. It can be empty if the message has no headers
* **`body`** - a string representing the message's payload. It can be `null` if the message has no payload.

=== Subscribe to a wildcard destination

This Web application is interested to receive the position of _any_ truck that broadcasts it.
This means that we must subscribe to the +/topic/truck.XXX.position+ for every trucks in the company where XXX is replaced by the truck ID.

There are two different ways to achieve this. The first way is to know beforehands all the truck IDs in the company and subscribe to their topics one after the other. We can use the same subscription callback for all of them.
However, that implies that the Web application must now have a way to know this list. For example, it could be a Web service that returns such a list.

The pseudo code for it would look like:

----
var truckListURL = "...";
var truckIDs = fetch(truckListURL);
var callback = function(message) {
  // we use the same callback for every subscription
}
for (truck in truckIDs) {
  var destination = "/topic/truck." + truckID + ".position";
  client.subscribe(destination, callback);
}
----

But what happens if another truck is added _after_ the Web application fetched the list of truck IDs? The Web application will not subscribe to its topic and will never display it on the map.
We have to periodically fetch the list of truck IDs and check whether there are new ones or if some trucks have been removed. This starts to be quite complex to write for a simple intent.

Fortunately, the flexibility of STOMP protocol comes handy to manage this in a simpler fashion. STOMP defines very loosely the destination

[quote, STOMP 1.2 Protocol]
____
A STOMP server is modelled as a set of destinations to which messages can be sent. The STOMP protocol treats destinations as opaque string and their syntax is server implementation specific. Additionally STOMP does not define what the delivery semantics of destinations should be. The delivery, or “message exchange”, semantics of destinations can vary from server to server and even from destination to destination. This allows servers to be creative with the semantics that they can support with STOMP. 
____

Until now, we have used _simple_ destinations such as +/topic/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.position+ or +/queue/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.orders+ that are straightforward to understand.

We will now use a feature from our STOMP broker, ActiveMQ, that allows to use http://activemq.apache.org/wildcards.html[_wildcard_ destinations].

* +.+ is used to separate names in a path
* +$$*$$+ is used to match any name in a path
* +>+ is used to recursively match any destination starting from this name

With our example using ActiveMQ, we can use this notation to subscribe to any
truck position topic by using the +/topic/truck.$$*$$.position+ widlcard destination (where +$$*$$+ stands for _any truck identifier_).

The subscription code becomes simpler:

[source,js]
----
      // we use a wildcard destination to register to any
      // destination that matches this pattern.
      var destination = "/topic/truck.*.position";
      client.subscribe(destination, function(message) {
        // this function is called every time a message is received
      });
----

[NOTE]
====
Since the semantic of STOMP destinations are specific to the STOMP broker, you have to check with its documentation to know if they support wildcard destinations or similar concepts. If it does not, you have to revert to the first idea to fetch the list of trucks and subscribe to each of the destination... or use another STOMP broker that supports this feature.
====

Since we no longer know _a priori_ which truck position we are receiving, how do we determine that.
There are 2 pieces of information we can use. When a consumer receives a STOMP message, the message always have a +destination+ header that corresponds to the _actual_ destination that we consume from. If we are subscribing to the wildcard address +/topic/truck.$$*$$.position+ and receives a message, we can look at the +message.headers["destination"]+ to get the actual destination (+/topic/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.position+ in my case).
However, we would then have to parse this +destination+ to extract the truck ID from it and write brittle code for that.

If you look back at <<ch_introduction_example_message>>, the message representation for the truck position also contains the truck ID in the +truck+ property:

[source,js]
----
{
  "truck": "66284AB0-C266-4A4D-9443-FEFB5774FA3C",
  "lat": 48.8581,
  "lng": 2.2946,
  "ts": "2013-09-23T08:43Z"
}
----

The message is _self-contained_ and gives all the interesting information that a consumer may need. When we receive a truck position message, we know which truck is sending it by simply looking at the +truck+ property from the JSON object created by parsing the message body.

[source,js]
----
      var destination = "/topic/truck.*.position";
      client.subscribe(destination, function(message) {
        // this function is called every time a message is received
        // create an object from the JSON string contained in the message body
        var payload = JSON.parse(message.body);
        var truckID = payload.truck;
----

When we receive the position of a truck, the last step we need to make is to display its position on a map. We will wrap this code in a +show+ method that is called from the subscription callback with the truck identifier and its latitute and longitude.

The whole code to connect to the STOMP broker, subscribes to the wildcard destination is shown below.

[source,js]
----
// Connection to the STOMP broker
// and subscription to the trucker's position destinations.
$('#connect_form').submit(function() {
  var url = $("#connect_url").val();

  // create the STOMP client
  client = Stomp.client(url);

  client.connect("", "", function(frame) {
    client.debug("connected to Stomp");
    // once the client is connected, subscribe to the truck's position destinations.

    // we use a wildcard destination to register to any
    // destination that matches this pattern.
    var destination = "/topic/truck.*.position";
    client.subscribe(destination, function(message) {
      // this function is called every time a message is received
      // create an object from the JSON string contained in the message body
      var payload = JSON.parse(message.body);

      var truckID = payload.truck;
      if (!$("#truckID option[value='" + truckID + "']").length) {
        // if the truck ID is not already in the list of trucks we can send orders to, we add it.
        $('#truckID').append($('<option>', {value:truckID}).text(truckID));                
      }
      // show the truck position on the map
      show(truckID, payload.lat, payload.lng);
    });
  });
  // disable the connect button
  $("#connect_button").prop("disabled",true);
  // enable the disconnect button
  $("#disconnect_button").prop("disabled",false);
  // show the form to send orders to the trucks
  $("#order_form").show();
  return false;
});
----

=== Draw the position on a map With Google Maps

The Web application is now receiving the GPS coordinates of any trucks that send them. We could just display them as text like we did for the mobile application in <<ch_mobile_stomp_display_truck_position>> but let's make it pretty by drawing them on a map instead by using Google Maps API.

In <<ex_web_stomp_1>> template, we already added the scripts to use Google Maps API. We now need to create the map and initialize it.

[source,js]
----
$(document).ready(function() {

  // Google map and the trackers to follow the trucks
  var map, trackers = {};

  function initialize() {
    var mapOptions = {
      zoom: 2,
      center: new google.maps.LatLng(30,0),
      mapTypeId: google.maps.MapTypeId.ROADMAP
    };
    map = new google.maps.Map($("#map-canvas").get(0), mapOptions);
  }

  // initialize the Google map.
  google.maps.event.addDomListener(window, 'load', initialize);
----

With this initialization code, the map will be drawn in the +map_canvas+ +div+ element and we can reference it using the +map+ variable.

The +trackers+ variable is a map whose key are the truck identifiers and the values is a tracker with the latest location of the truck on the map.

We have called a +show()+ method in the subscription handler. Let's code it now to display the truck on the map using its coordinates.

[source,js]
----
  // show the truckID at the given latitude and longitude
  function show(truckID, lat, lng) {
    var position = new google.maps.LatLng(lat, lng);
    // lazy instantiation of the map
    if (!map) {
      create_map(position);
    }
    // if there is no tracker for this truck
    if (!trackers[truckID]) {
      // create a marker for it
      var marker = new google.maps.Marker({
        position: position,
        map: map,
        title: truckID + " is here"});
      var infowindow = new google.maps.InfoWindow({
        content: "Truck " + truckID
      });
      var tracker = {
        marker: marker
      };
      // add it to the trackers
      trackers[truckID] = tracker;
      google.maps.event.addListener(marker, 'click', function() {
        infowindow.open(map, marker);
      });
    } else {
      // the tracker is know, we just need to update its position
      trackers[truckID].marker.setPosition(position);
    }
  }
----

If we open now this +control.html+ file in a Web browser, we will see a map of the whole world displayed.

[[img_web_stomp_1]]
.The Control Center Web application.
image::images/Chapter021/control_center.png["The Control Center Web application"]

If we click on the +Connect+ button, markers will appear on the map for each truck that sents its coordinates. 

In my case, I am using the iOS simulator to run the mobile application developed in the previous chapter and use its +Location+ tool to simulate a freeway drive (as explained in <<ch_mobile_stomp_location_simulator>>).

[[img_web_stomp_2]]
.Following a truck on a freeway drive.
image::images/Chapter021/truck_freeway_drive.png["Following a truck on a freeway drive"]

The position of the truck is updated every time the Web application receives a STOMP message from the truck's position destination and you will see it move on the map.

At this stage, the Web application receives STOMP messages to display the position of the trucks. We now need to write the code to send orders to the trucks.

=== Send Messages with stomp.js

The STOMP client can send messages to the broker by calling the **`send`** method which takes three parameters:

* +destination+ - the name of the destination
* +headers+ - a JavaScript object containing any additional headers
* +body+ - a string corresponding to the message payload.

Both `headers` and `body` are optional and can be omitted. However if you want to set the message payload, you must also specify the headers (using an empty
JavaScript literal if you have no header to set).

[source,js]
----
client.send(destination, {}, body);
----

As we described in <<ch_introduction_example_topology>>, we use a queue to send orders to a given truck and the destination for this is named +/queue/truck.XXX.orders+

The order is sent in the STOMP message body as a JSON string with a +order+ key.

[source,js]
----
{
  "order": "Go to warehouse #1"
}
----

We must respect this message format as it is the format expected by the mobile application to handle the orders and display them (we wrote this code in <<ch_mobile_stomp_subscribe>>).