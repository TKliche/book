<section xmlns="http://www.w3.org/1999/xhtml" data-type="chapter" id="ch_mobile_mqtt">
<h1>Mobile Messaging with MQTT</h1>


<p class="lead">In this chapter, we will write an iOS application using the MQTTKit library to send and receive messages using the MQTT protocol.</p>

<p>In <a data-type="xref" href="#ch_introduction_mqtt_example">#ch_introduction_mqtt_example</a>, we described the Motions application (<a data-type="xref" href="img_mobile_mqtt_1"></a>). In this chapter, we will write the iOS application that broadcasts the device motion data and receives alert messages.</p>

<figure id="img_mobile_mqtt_1">
<img src="images/mawm_0601.png" alt="Diagram of the Motions+ iOS application"/>
<figcaption>Diagram of the Motions iOS application</figcaption>
</figure>
<div data-type="note">
<p>Throughout the chapter, we will show all the code required to run the application.</p>

<p>The whole application code can be retrieved from the <a href="https://github.com/mobile-web-messaging/code">GitHub repository</a> in the <em>mqtt/ios/</em> directory.</p>

</div>






<section data-type="sect1" id="__code_mqttkit_code">
<h1>MQTTKit</h1>

<p>This book uses the MQTTKit library for iOS (and Mac OS X) applications. It is a modern Objective-C library that uses ARC and blocks to write messaging clients in a simple fashion. It is based on the <a href="http://mosquitto.org">Mosquitto</a> project that provides a lower-level C implementation of MQTT.</p>

<p>The source code of this library project is hosted on <a href="https://github.com/mobile-web-messaging/MQTTKit">GitHub</a>.</p>
</section>













<section data-type="sect1" id="_create_the_code_motions_code_project_with_xcode">
<h1>Create the Motions Project with Xcode</h1>

<p>We will use <a href="https://developer.apple.com/xcode/">Xcode</a> to create the Locations iOS application.</p>

<p>Once Xcode is installed and started, we select "Create a new Xcode project" from its launch screen. The application will be composed of a single view, so we select the Single View Application template in iOS &#x2192; Application from the template screen, as illustrated in <a data-type="xref" href="img_mobile_mqtt_125"></a>.</p>

<figure id="img_mobile_mqtt_125">
<img src="images/mawm_0602.png" alt="XCode template screen"/>
<figcaption>Select Single View Application from the template screen</figcaption>
</figure>

<p>We will call the project Motions and select to build it only for iPhone devices, as illustrated in <a data-type="xref" href="img_mobile_mqtt_2"></a>.</p>

<figure id="img_mobile_mqtt_2">
<img src="images/mawm_0603.png" alt="XCode project options screen"/>
<figcaption>XCode project options screen</figcaption>
</figure>

<p>Finally, we will save it in a folder on our machine.</p>
</section>













<section data-type="sect1" id="_create_the_podfile">
<h1>Create the Podfile</h1>

<p>We will again use CocoaPods to manage the project dependencies (as explained in <a data-type="xref" href="#ch_mobile_stomp_cocoapods">#ch_mobile_stomp_cocoapods</a> for the STOMP example).</p>

<p>We close Xcode because CocoaPods will modify the project settings to import the dependencies.</p>

<p>We create a file named <em>Podfile</em> at the root of the project (in the same directory as <em>Motions.xcodeproj</em>). See <a data-type="xref" href="ex_mobile_mqtt_1"></a>.</p>
<div id="ex_mobile_mqtt_1" data-type="example">
<h5>The Motions's application</h5>


<pre data-type="programlisting">xcodeproj 'Motions.xcodeproj'

pod 'MQTTKit', :git =&gt; 'https://github.com/mobile-web-messaging/MQTTKit.git'

platform :ios, '5.0'</pre>
</div>

<p>After saving this file, run the <strong><code>pod install</code></strong> command, shown in <a data-type="xref" href="ex_mobile_mqtt_2"></a>.</p>
<div id="ex_mobile_mqtt_2" data-type="example">
<h5>Install Motions dependencies</h5>


<pre data-type="programlisting">$ pod install
Analyzing dependencies
Pre-downloading: `MQTTKit` from `https://github.com/mobile-web-messaging/MQTTKit.git`
Downloading dependencies
Installing MQTTKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `Motions.xcworkspace`.</pre>
</div>

<p>We can now open Xcode again, but we must do it using the <em>workspace</em> file named <em>Motions.xcworkspace</em>, and not the <em>project</em> file named <em>Motions.xcodeproj</em> (<a data-type="xref" href="img_mobile_mqtt_3"></a>).</p>

<figure id="img_mobile_mqtt_3">
<img src="images/mawm_0604.png" alt="Open the workspace file"/>
<figcaption>Open the workspace file</figcaption>
</figure>

<p>First, we will verify that the project is set up correctly and that the application can run in the iOS simulator.</p>

<p>We will simulate the latest iPhone devices by selecting Product &#x2192; Destination &#x2192; iPhone Retina (4-inch 64-bit) from Xcode menubar.</p>
<!--
Command symbol is not displayed in PDF.
-->

<p>If we run the application by selecting Product &#x2192; Run (or pressing   <code>⌘+R</code>), the iOS simulator starts and opens the application, which is composed of a blank view. This confirms that the project and its dependencies are  successfully compiled and launched.</p>
</section>













<section data-type="sect1" id="_identify_the_device">
<h1>Identify the Device</h1>

<p>This step is similar to the Locations iOS application described in <a data-type="xref" href="#ch_mobile_stomp_deviceID">#ch_mobile_stomp_deviceID</a>.</p>

<p>We will generate a unique identifier for the iOS device and display it in the view.</p>

<p>Click on <em>Main.storyboard</em> to open it. From the Object library, drag a Label on the View's window. Place it at the top of the view and change the text to "Device ID," as shown in <a data-type="xref" href="img_mobile_mqtt_4"></a>.</p>

<figure id="img_mobile_mqtt_4">
<img src="images/mawm_0605.png" alt="Add the Device ID label"/>
<figcaption>Add the Device ID label</figcaption>
</figure>

<p>We will again change its Font to System 13.0 and its Alignment to centered to fit the screen.</p>

<p>This label will be connected to a <code>deviceIDLabel</code> outlet property defined in the <code>MWMViewController</code> private interface in the <em>MWMViewController.m</em> file.
We also add a <code>deviceID</code> string to store the device identifier:</p>


<pre data-type="programlisting" data-code-language="objc">@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (strong, nonatomic) NSString *deviceID;

@end</pre>


<p>Open the <em>Main.storyboard</em> and control-click on View Controller to see its connection panel. Drag from deviceIDLabel to the UILabel to connect it. See <a data-type="xref" href="img_mobile_mqtt_5"></a>.</p>

<figure id="img_mobile_mqtt_5">
<img src="images/mawm_0606.png" alt="Connect the deviceIDLabel outlet property to the device ID UILabel"/>
<figcaption>Connect the deviceIDLabel outlet property to the device ID UILabel</figcaption>
</figure>

<p>The device identifier is generated in the <code>MWMViewController</code> implementation when the view is loaded and stored in the <code>deviceID</code> property. We also set the <code>deviceIDLabel</code>'s <code>text</code> to this identifier:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;
}</pre>

</section>













<section data-type="sect1" id="_display_the_device_motions_values">
<h1>Display the Device Motions Values</h1>

<p>The device motion will be identified using the pitch, roll, and yaw values.
To have some graphical feedback as we move the device, we will add three <code>UILabel</code>s that show these three values.</p>

<p>Click on <em>Main.storyboard</em> to open it. From the Object library, drag three Labels on the View's window below the Device ID label. Change their respective text to "pitch," "roll," and "yaw," as illustrated in <a data-type="xref" href="img_mobile_mqtt_6"></a>.</p>

<figure id="img_mobile_mqtt_6">
<img src="images/mawm_0607.png" alt="Add three labels to display the device's pitch, roll and yaw values."/>
<figcaption>Add three labels to display the device’s pitch, roll, and yaw values</figcaption>
</figure>

<p>We create three outlet properties in the <code>MWMViewController</code> private interface for these labels:</p>


<pre data-type="programlisting" data-code-language="objc">@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;
@property (weak, nonatomic) IBOutlet UILabel *pitchLabel;
@property (weak, nonatomic) IBOutlet UILabel *rollLabel;
@property (weak, nonatomic) IBOutlet UILabel *yawLabel;

@property (strong, nonatomic) NSString *deviceID;

@end</pre>


<p>The next step is to connect the three labels in the <em>Main.storyboard</em> to these three outlet properties:</p>

<p>Open the <em>Main.storyboard</em> and control-click on View Controller to see its connection panel. Drag from its pitchLabel property to the corresponding pitch UILabel to connect it (see <a data-type="xref" href="img_mobile_mqtt_7"></a>).</p>

<figure id="img_mobile_mqtt_7">
<img src="images/mawm_0608.png" alt="Connect the pitchLabel outlet property to the pitch UILabel"/>
<figcaption>Connect the pitchLabel outlet property to the pitch UILabel</figcaption>
</figure>

<p>Repeat this operation for the <code>rollLabel</code> and <code>yawLabel</code> to connect them.</p>

<p>At this stage, the graphical objects are connected and we can capture the device motion to update these labels and then broadcast the motion data using MQTT.</p>
</section>













<section data-type="sect1" id="_capture_the_device_motions_with_code_coremotion_code_framework">
<h1>Capture the Device Motions with CoreMotion Framework</h1>

<p>iOS provides the <code>CoreMotion</code> framework to capture the motion of the devices.</p>

<p>We need to add it to the libraries linked by the application. Click on the Motions project and then the Motions target. In the General tab, under the Linked Frameworks and Libraries section, click on the <code>+</code> button. In the selection window, type "CoreMotion," select the CoreMotion.framework, and click on the Add button.</p>

<figure>
<img src="images/mawm_0609.png" alt="Add the CoreMotion framework"/>
<figcaption>Add the CoreMotion framework</figcaption>
</figure>

<p>We can now use the CoreMotion framework by importing <em>CoreMotion/CoreMotion.h</em> at the top of the <em>MWMViewController.m</em> file.</p>

<p>We will also define a <code>motionManager</code> property in <code>MWMViewController</code> private interface to use <code>CoreMotion</code>:</p>


<pre data-type="programlisting" data-code-language="objc">#import &lt;CoreMotion/CoreMotion.h&gt;

@interface MWMViewController ()

@property (strong, nonatomic) CMMotionManager *motionManager;

@end</pre>


<p>This <code>motionManager</code> is used to capture the device motions. We must create a new <code>CMMotionManager</code>, specify the interval of update and call its <code>startDeviceMotionUpdatesToQueue:withHandler:</code> method to get the device motion
periodically in a block. We create a new <code>NSOperationQueue</code> to receive these updates on this queue.</p>

<p>The device motion is represented by a <code>CMDeviceMotion</code> object. In our example, we are interested only by its <code>attitude</code> property that contains the pitch, roll, and yaw value we want to broadcast. Their values are expressed in radians, so we will convert them in degrees to display them.</p>

<p>The block to receive motion update is executed on the <code>NSOperationQueue</code> we have created, so we cannot update the <code>UILabel</code> from it. We must instead create another block and call <code>dispatch_async</code> to execute the graphical changes on the UI main queue (that is retrieved by calling <code>dispatch_get_main_queue()</code>).</p>

<p>All this logic can be written in <code>viewDidLoad</code> so that the motion manager will start receiving updates when the view is loaded:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // get the device motion updates every second.
    self.motionManager.deviceMotionUpdateInterval = 1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue
                                            withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                // convert values from radians to degrees
                double pitch = attitude.pitch * 180 / M_PI;
                double roll = attitude.roll * 180 / M_PI;
                double yaw = attitude.yaw * 180 / M_PI;
                self.pitchLabel.text = 
                [NSString stringWithFormat:@"pitch: %.0f°", pitch];
                self.rollLabel.text = 
                [NSString stringWithFormat:@"roll: %.0f°", roll];
                self.yawLabel.text = 
                [NSString stringWithFormat:@"yaw: %.0f°", yaw];
            });
        }
    }];
}</pre>


<p>We also need to notify the <code>motionManager</code> that we no longer want to receive updates when the view is no longer used. We need to call its <code>stopDeviceMotionUpdates</code> method inside the view controller’s <code>dealloc</code> method:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
}</pre>


<p>At this stage, if you run the Motions application on your iPhone and move it, the pitch, roll, and yaw labels will be updated to reflect the changes in the device motions (<a data-type="xref" href="img_mobile_mqtt_8"></a>).</p>

<figure id="img_mobile_mqtt_8">
<img src="images/mawm_0610.png" alt="The motion values change when the device moves."/>
<figcaption>The motion values change when the device moves</figcaption>
</figure>
<div data-type="note">


<p>The iOS Simulator is not able to simulate device motions. If you run the Motions application in the simulator, the <code>motionManager</code> will not send any device motions updates. At the time of writing this book, the only way to test this code is to run the application on a real iOS device.</p>

</div>

<p>We now capture the device motions and display them. The next step is to broadcast them by sending MQTT messages.</p>
</section>













<section data-type="sect1" id="ch_mobile_mqtt_client">
<h1>Create an MQTT Client with MQTTKit</h1>

<p>To send and receive message with MQTT, we must first import the MQTTKit library that was added to the project using CocoaPods at the beginning of this chapter.</p>

<p>We must import its header file <em>MQTTKit.h</em> at the top of the <em>MWMViewController.m</em> file and add an <code>MQTTClient</code> property named <code>client</code> to the <code>MWMViewController</code> private interface.</p>

<p>We also define a constant to represent the hostname of the MQTT broker we are using <em>iot.eclipse.org</em>:</p>


<pre data-type="programlisting" data-code-language="objc">#import &lt;MQTTKit/MQTTKit.h&gt;

#define kMqttHost @"iot.eclipse.org"

@interface MWMViewController ()

@property (strong, nonatomic) MQTTClient *client;

@end</pre>


<p>We will create a new <code>MQTTClient</code> object in the <code>MWMViewController</code>'s <code>viewDidLoad</code> method.
An <code>MQTTClient</code> must be uniquely identified for the MQTT brokers it connects to.
We can use the <code>deviceID</code> as its client identifier:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
}</pre>

</section>













<section data-type="sect1" id="_connect_to_a_mqtt_broker">
<h1>Connect to an MQTT Broker</h1>

<p>An MQTTKit client will connect to the MQTT Broker when its <code>connectToHost:completionHandler:</code> method is called. MQTTKit is event-driven, so the client will be <em>effectively</em> connected when its <code>completionHandler</code> block is called and the return code <code>MQTTConnectionReturnCode</code> is equal to <code>ConnectionAccepted</code>.</p>

<p>You cannot assume that the client is connected when the <code>connectToHost:completionHandler:</code> method returns. Any actions that require the client to be connected must happen inside the <code>completionHandler</code> block.</p>

<p>We will encapsulate this code in a <code>connect</code> method:</p>


<pre data-type="programlisting" data-code-language="objc">#pragma mark - MQTTKit Actions

- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}</pre>


<p>We will call this method from <code>viewDidLoad</code> to connect to the MQTT broker as soon as the view is loaded:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    [self connect];
}</pre>

</section>













<section data-type="sect1" id="_disconnect_from_a_mqtt_broker">
<h1>Disconnect from an MQTT Broker</h1>

<p>The <code>client</code> can disconnect from the MQTT broker by calling its <code>disconnectWithCompletionHandler:</code> method.</p>

<p>The <code>completionHandler</code> block as a <code>code</code> parameter that will be <code>0</code> if the disconnection was successful:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)disconnect
{
    [self.client disconnectWithCompletionHandler:^(NSUInteger code) {
        if (code == 0) {
            NSLog(@"disconnected from the MQTT broker");
        } else {
            NSLog(@"disconnected unexpectedly...");
        }
    }];
}</pre>


<p>We want to disconnect from the MQTT broker when the <code>MWMViewController</code> is no longer used. We will call the <code>disconnect</code> method from <code>dealloc</code>:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self disconnect];
}</pre>

</section>













<section data-type="sect1" id="_send_mqtt_messages">
<h1>Send MQTT Messages</h1>

<p>The <code>MWMViewController</code> automatically connects to the MQTT broker when its view is loaded and disconnects when it is deallocated. The next step is to send messages every time the device motion values are updated.</p>

<p>The MQTT protocol is a binary protocol. The message payload must be encoded as binary data to be sent.
The MQTTKit library provides two methods to send messages:</p>
<ul>
<li>
<p>The <code>publishData:toTopic:withQos:retain:</code> method expects an <code>NSData</code> object as the message payload and its <code>bytes</code> will be used.</p>
</li>
<li>
<p>The <code>publishString:toTopic:withQos:retain:</code> method can also be used for the common case of sending a text message. Internally, the <code>NSString</code> that is passed in parameter is encoded as an <code>NSData</code> using the UTF-8 encoding.</p>
</li>
</ul>

<p>In the Motions iOS application, we send a message with a binary payload composed of three 64-bit floats for the pitch, roll, and yaw values contained in a <code>CMAttitude</code> object. We will build the payload’s <code>NSData</code> by converting the double values to a platform-independent format using the <code>CFConvertDoubleHostToSwapped</code> function.</p>

<p>The other three parameters to the <code>publish…</code> methods are the same for both the binary and text payload version.</p>

<p>The <code>topic</code> parameter is the name of the topic to send the message.
According to <a data-type="xref" href="#ch_introduction_mqtt_example_topology">#ch_introduction_mqtt_example_topology</a>, the name of the topic is <code>/mwm/XXX/motion</code> where "XXX" is the device identifier.</p>

<p>The <code>qos</code> parameter corresponds to the <em>Quality of Service</em> (or QoS) to use to deliver the messages to the consumers.</p>








<section data-type="sect2" id="mqtt_qos">
<h2>Quality of Service</h2>

<p>The MQTT protocol defines three levels of Quality of Service:</p>
<ul>
<li>
<p>At Most Once (with the value <code>0</code> represented by <code>AtMostOnce</code> in MQTTKit)</p>
</li>
<li>
<p>At Least Once (with the value <code>1</code> represented by <code>AtLeastOnce</code> in MQTTKit)</p>
</li>
<li>
<p>Exactly Once (with the value <code>2</code> represented by <code>ExactlyOnce</code> in MQTTKit)</p>
</li>
</ul>

<p>These levels of QoS determine the guarantee that the MQTT broker will accept to deliver a message.
With <code>At Most Once</code>, the MQTT broker guarantees that the published message will be delivered at most once to its consumers. This means that the consumers may not receive the message at all. If an error (such as a network failure or a crash) occurs while the message is sent to the broker, it is possible that it will be lost and the consumers will never receive it.</p>

<p>With <code>At Least Once</code>, the MQTT broker guarantees that the published message will be delivered at least once to the consumers. This also means that a consumer may receive the same message twice. If there is an error when the producer sends the message to the broker and a message acknowledgment has not been received, it will resend it a second time as a <em>duplicate</em> (the MQTT message will have a <code>DUP</code> bit set). When the broker receives this duplicate message it will redeliver it to the consumer, but it is possible that they in fact received the original message. The consumer may need to check if the <code>DUP</code> bit is set on the delivered message to know whether it is an original message (and it must process it) or a duplicate (and it can discard it).</p>

<p>The <code>At Least Once</code> QoS offers the guarantee that no published message will be lost, but at the cost of performance and additional code on the consumer side.
The performance cost is caused by the additional message (a <code>PUBACK</code> message) sent from the broker to the client to acknowledge that it has received the published message. That means that using this QoS level to publish <code>N</code> messages will involve exchanging <code>2*N</code> messages between the producer and the broker.</p>

<p>The highest level of delivery is provided using the <code>Exactly Once</code> QoS. With that level, the MQTT broker guarantees that the published message will be delivered <em>exactly</em> once by the consumers. There will be no lost messages or duplicate messages. This is guaranteed by additional exchange of messages between the producer and broker (<code>PUBREC</code>, <code>PUBREL</code>, <code>PUBCOMP</code> messages).
That means that using this QoS level to publish <code>N</code> messages will involve exchanging <code>4*N</code> messages, requires four times more network trips than the lowest level of QoS of <code>At Most Once</code> and twice more than the <code>At Least Once</code> level.</p>

<p>Choosing the correct QoS depends on the type of message exchanged and the <em>importance</em> of its payload.
In the Motions iOS application, the published message contains device motion that is updated every second. It is acceptable if a published message is <em>lost</em> because a new message with updated content will be sent just one second after. Using the <code>AtMostOnce</code> QoS is the best choice for this type of message.</p>

<p>All the complexities of using a higher level of QoS is transparent from the application using MQTT, as it is the responsibility of the client library to handle it. However, you need to be aware of the cost associated with using these QoS, as they can have significant impact on your application performance and the device in general (as the additional network trips will drain the battery life).</p>
</section>













<section data-type="sect2" id="_retained_message">
<h2>Retained Message</h2>

<p>The final parameter of the <code>publish…</code> methods is a boolean to specify whether the published message must be <em>retained</em> by the topic.</p>

<p>If this flag is set on the message, the broker will deliver the message to its subscribers and keep holding the message. If a new consumer subscribes to this topic, the broker will deliver the retained message to it. This is useful, as the new subscriber will not have to wait for a publisher to send a message to receive new data. The retained message contains the <em>Last Known Good</em> value.</p>

<p>In our case, we will publish messages with <code>retain</code> set to <code>YES</code>. If consumers subscribe to the device motion topic <em>after</em> the device stops updated its motion values, they will still be able to use the last known device motion value.
This example is a bit of a stretch. A more interesting example would be an application broadcasting its location (similar to the <code>Locations</code> application). Using retained message would allow the consumers to know the last known position of the device before it stops broadcasting its position.</p>

<p>To sum up, the <code>Motions</code> application will send a message:</p>
<ul>
<li>
<p>With a binary payload composed of three 64-bit floats for the device’s pitch, roll, and yaw values</p>
</li>
<li>
<p>To the device motion topic <code>/mwm/XXX/motion</code> where <code>XXX</code> is the device identifier</p>
</li>
<li>
<p>With a QoS of <code>AtMostOnce</code>, because we accept that a published message may not be delivered</p>
</li>
<li>
<p>With <code>retain</code> set to <code>YES</code> so that the broker will retain the Last Known Good message to deliver it to new subscribers.</p>
</li>
</ul>

<p>We will encapsulate this code in a <code>send:</code> method taking a <code>CMAttitude</code> parameter:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)send:(CMAttitude *)attitude
{
    uint64_t values[3] = {
        CFConvertDoubleHostToSwapped(attitude.pitch).v,
        CFConvertDoubleHostToSwapped(attitude.roll).v,
        CFConvertDoubleHostToSwapped(attitude.yaw).v
    };
    NSData *data = [NSData dataWithBytes:&amp;values length:sizeof(values)];
    NSString *topic =[NSString stringWithFormat:@"/mwm/%@/motion", 
    self.deviceID];
    [self.client publishData:data
                     toTopic:topic
                     withQos:AtMostOnce
                      retain:YES
           completionHandler:nil];
}</pre>


<p>The message will contain the motion values in radians. It will be up to the consumers to convert them in degrees if necessary.</p>

<p>Finally, the last step is to call this method every time a device motion value is updated by the <code>motionManger</code>. This occurs in the <code>viewDidLoad</code> method inside the <code>handler</code> block passed to the <code>motionManger</code>'s <code>startDeviceMotionUpdatesToQueue:withHandler:</code> method:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    self.motionManager = [[CMMotionManager alloc] init];
    // get the device motion updates every second.
    self.motionManager.deviceMotionUpdateInterval = 1;
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [self.motionManager startDeviceMotionUpdatesToQueue:queue
                                            withHandler:^(CMDeviceMotion *motion, NSError *error) {
        if(!error) {
            CMAttitude *attitude = motion.attitude;
            dispatch_async(dispatch_get_main_queue(), ^{
                // convert values from radians to degrees
                double pitch = attitude.pitch * 180 / M_PI;
                double roll = attitude.roll * 180 / M_PI;
                double yaw = attitude.yaw * 180 / M_PI;
                self.pitchLabel.text = 
                [NSString stringWithFormat:@"pitch: %.0f°", pitch];
                self.rollLabel.text = 
                [NSString stringWithFormat:@"roll: %.0f°", roll];
                self.yawLabel.text = 
                [NSString stringWithFormat:@"yaw: %.0f°", yaw];
            });
            [self send:attitude];
        }
    }];


    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
}</pre>


<p>We now have the <code>Motions</code> iOS application that is sending MQTT messages. How can we check that this is working as expected?</p>

<p>Conversely to <code>STOMP</code>, <code>MQTT</code> is a binary protocol and we cannot use a simple telnet client to create a consumer and receive messages sent by the application.</p>

<p>However, the <a href="http://mosquitto.org">Mosquitto broker</a> provides a simple command-line tool to send and receive message from an MQTT broker. <a data-type="xref" href="#appendix_mosquitto">#appendix_mosquitto</a> explains how to download and install the Mosquitto broker. After it is done, we can use its <code>mosquitto_sub</code> command-line tool to connect to an MQTT broker (hosted at <em>iot.eclipse.org</em>) and subscribe to the device motion topic (in my case, <code>/mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/motion</code>, you will have to replace it using your own device identifier).</p>

<p>This tool will display the message payload. We are sending binary payload, so we will pipe the command into the <code>hexdump</code> tool to display the hexadecimal representation of the binary payload:</p>


<pre data-type="programlisting" data-code-language="bash">$ mosquitto_sub -h iot.eclipse.org -t /mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/motion | hexdump
...
0000050 aa b0 4c 3f 9b 41 0c 6b 08 35 d3 3f d2 4b 23 f2
0000060 71 1e 47 0a 3f d5 05 6a c4 37 52 16 3f d8 f7 b5
0000070 34 f6 19 ea bf d2 97 6f 1a 65 86 af 0a 3f af 23
0000080 78 91 85 1c 8d bf df b9 12 c4 78 64 1c 3f cb 3c
0000090 50 fd 05 26 5b 0a 3f d1 60 87 16 0b 12 9e bf c2
...</pre>


<p>This confirms that the Motions application is effectively publishing MQTT messages.</p>
</section>





</section>













<section data-type="sect1" id="ch_mobile_mqtt_receive">
<h1>Receive MQTT Messages</h1>

<p>As described in <a data-type="xref" href="#ch_introduction_mqtt_example">#ch_introduction_mqtt_example</a>, the Motions iOS application is also a consumer from the topic <code>/mwm/XXX/alert</code>. When it receives a message from this topic, it must change its background color to "alert" the user.</p>

<p>Let’s write the method that alert the user by changing the background color first. This <code>warnUser:</code> method takes an <code>NSString</code> parameter that should correspond to a color. Using <code>UIKit</code> animations, we will:</p>
<ol>
<li>
<p>Animate the controller’s view to change its background color from its original color to the one created from the <code>NSString</code> parameter.</p>
</li>
<li>
<p>Wait two seconds after the first animation is completed to revert back to the original background color:</p>
</li>

</ol>


<pre data-type="programlisting" data-code-language="objc"># pragma mark - UI Actions

// Warn the user by changing the view's background color to the specified color during 2 seconds
- (void)warnUser:(NSString *)colorStr
{
    // keep a reference to the original color
    UIColor *originalColor = self.view.backgroundColor;

    [UIView animateWithDuration:0.5
                          delay:0.0
                        options:0
                     animations:^{
                         // change it to the color passed in parameter
                         SEL sel = NSSelectorFromString([NSString stringWithFormat:@"%@Color", colorStr]);
                         UIColor* color = nil;
                         if ([UIColor respondsToSelector:sel]) {
                             color  = [UIColor performSelector:sel];
                         } else {
                             color = [UIColor redColor];
                         }
                         self.view.backgroundColor = color;
                     }
                completion:^(BOOL finished) {
                         // after a delay of 2 seconds, revert it to 
                         // the original color
                         [UIView animateWithDuration:0.5
                                               delay:2
                                             options:0
                                          animations:^{
                                              self.view.backgroundColor = originalColor;
                                          }
                                          completion:nil];
                     }];
}</pre>


<p>To consume messages from an MQTT broker, the <code>client</code> must do the following:</p>
<ol>
<li>
<p>Subscribe to its topic of interest.</p>
</li>
<li>
<p>Set its <code>messageHandler</code> property, which will be called every time a message is delivered.</p>
</li>

</ol>

<p>Note that you can subscribe to many topics from the client but it has only one <code>messageHandler</code> property. If the client is subscribed to different topics, its <code>messageHandler</code> must determine which topic the message is consumed from.</p>








<section data-type="sect2" id="_subscription">
<h2>Subscription</h2>

<p>The Motions application will subscribe to its device alert topic <code>/mwm/XXX/alert</code> by calling the method <code>subscribe:withQos:completionHandler:</code> on its <code>client</code> property.</p>

<p>The first parameter is the device alert topic. We will define it at the top of the <em>MWMViewController.m</em> file:</p>


<pre data-type="programlisting" data-code-language="objc">#define kAlertTopic @"/mwm/%@/alert"</pre>


<p>The <code>subscribe:withQos:completionHandler:</code> method takes a <code>qos</code> parameter that corresponds to the level of quality of service at which the consumer wants to recieve messages from the topic. </p>

<p>The completion handler will be called when the client is effectively subscribed to the topic. The handler has a <code>grantedQos</code> parameter that corresponds to the effective quality of service. The producer is responsible for determining the maximum quality of service that a message can be delivered at, but the consumer can decide to <em>downgrade</em> the quality of service according to its usage.
For example, a producer may publish a message with a QoS of <code>ExactlyOnce</code>, but a consumer may decide that it is acceptable for it if there are message duplicates and downgrade its QoS to <code>At Least Once</code>.</p>

<p>In our case, we will request to have messages delivered with a <code>qos</code> set to <code>AtLeastOnce</code>, as we do not want to lose messages but can accept duplicate messages:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)subscribe
{
    NSString *topic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.client subscribe:topic 
                   withQos:AtLeastOnce 
         completionHandler:^(NSArray *grantedQos) {
        NSLog(@"subscribed to %@ with QoS %@", topic, grantedQos);
    }];
}</pre>


<p>We will subscribe to the alert topic as soon as the <code>client</code> is connected to the MQTT broker by calling this <code>subscribe</code> method from inside the <code>completionHandler</code> in the <code>connect</code> method:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)connect
{
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
            [self subscribe];
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", code);
        }
    }];
}</pre>

</section>













<section data-type="sect2" id="_unsubscription">
<h2>Unsubscription</h2>

<p>To unsubscribe from a topic and stop receiving messages from it, we will call the <code>unsubscribe:withCompletionHandler:</code> method of the <code>client</code> where the first parameter is the topic to unsubscribe from (the alert topic in our case).
The second parameter is a completion handler that is called back when the client has been acknowledged by the server that it is effectively unsubscribed.
We do not have any need for this information so we just pass <code>nil</code> as the handler:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)unsubscribe
{
    NSString *topic = [NSString stringWithFormat:kAlertTopic, self.deviceID];
    [self.client unsubscribe:topic withCompletionHandler:nil];
}</pre>


<p>We will call this <code>unsubscribe</code> method just before disconnecting from the MQTT broker from the <code>dealloc</code> method:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)dealloc
{
    [self.motionManager stopDeviceMotionUpdates];
    [self unsubscribe];
    [self disconnect];
}</pre>


<p>Because we disconnect just after unsubscribing, we could skip that step and just disconnect from the MQTT broker. At that moment, the MQTT broker will automatically unsubscribe the client from any topic. However, it is a good practice to explicitly unsubscribe from the subscribed topic. There are also many cases where unsubscribing may occur at a different time than the disconnection. In these cases, we cannot rely on the client disconnection to perfom the unsubscription.</p>
</section>













<section data-type="sect2" id="_define_a_mqttmessage_handler">
<h2>Define an MQTTMessage Handler</h2>

<p>Subscribing to a topic is the first step to receive messages with MQTTKit. The second step is to define a block that will be called every time a message is received from a subscribed topic.</p>

<p>The <code>client</code>'s <code>messageHandler</code> property defines an <code>MQTTMessageHandler</code> block. This block has an <code>MQTTMessage</code> parameter representing the MQTT message that is deliver to the client.</p>

<p>The <code>MQTTMessage</code> interface defines four properties corresponding to the message data:</p>
<ul>
<li>
<p><code>mid</code> is a <code>unsigned short</code> corresponding to the <em>message ID</em>.</p>
</li>
<li>
<p><code>topic</code> is the name of the topic that this message is coming from. If the client is subscribed to many topics, we must use this property to determine which topic the received message is coming from.</p>
</li>
<li>
<p><code>retained</code> is a <code>BOOL</code> to check whether the message was retained (and contains the last known good value) or not (it is a <em>fresh</em> message).</p>
</li>
<li>
<p><code>payload</code> is an <code>NSData</code> object containing the binary content of the message payload.</p>
</li>
</ul>

<p>Because sending and receiving text message is very common, the <code>MQTTMessage</code> interface also defines a <code>payloadString</code> method that returns an <code>NSString</code> decoded from the message binary payload using UTF-8.</p>

<p>In the <code>Motions</code> application, we expect to receive a text payload and will use this <code>payloadString</code> to extract the color string from the received message.</p>

<p>We need to set the <code>client</code>'s <code>messageHandler</code> <em>before</em> subscribing to the alert topic so that we do not miss any alert message sent after we subscribe but <em>before</em> the <code>messageHandler</code> is defined.
We will do that in the <code>viewDidLoad</code> method just after creating the <code>client</code> instance:</p>


<pre data-type="programlisting" data-code-language="objc">- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
    self.deviceIDLabel.text = self.deviceID;

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];
    // use a weak reference to avoid a retain/release cycle in the block
    __weak MWMViewController *weakSelf = self;
    self.client.messageHandler = ^(MQTTMessage *message) {
        NSString *alertTopic = [NSString stringWithFormat:kAlertTopic, weakSelf.deviceID];
        if ([alertTopic isEqualToString:message.topic]) {
            NSString *color = message.payloadString;
            dispatch_async(dispatch_get_main_queue(), ^{
                [weakSelf warnUser:color];
            });
        }
    };

    [self connect];
}</pre>


<p>We extracted the color using the message <code>payloadString</code> method after checking that it was indeed coming from the device alert topic.
We then call the <code>warnUser:</code> method in a block that is run on the main queue, because it contains code related to <code>UIKit</code>.</p>

<p>To avoid a retain/release cycle between <code>self</code> and the <code>messageHandler</code> block, we need to create a <em>weak</em> reference of <code>self</code> to use it inside the block.</p>

<p>How can we verify that the Motions application is effectively receiving alert messages? To verify that the application was sending messages, we used the <code>mosquitto_sub</code> tool. We will now use the opposite tool, <code>mosquitto_pub</code>, to publish a message on the alert topic and verify that the application background color changes.</p>

<p>The <code>mosquitto_pub</code> can send a text payload using the <code>-m</code> option. We will use this option to pass the background color (in this case, <code>green</code>):</p>


<pre data-type="programlisting" data-code-language="bash">$ mosquitto_pub -h iot.eclipse.org -t /mwm/C0962483-7DD9-43CC-B1A0-2E7FBFC05060/alert -m green</pre>


<p>After this message is sent, the device will receive it and change its background color to green (<a data-type="xref" href="img_mobile_mqtt_225"></a>).</p>

<figure id="img_mobile_mqtt_225">
<img src="images/mawm_0611.png" alt="Alert message is received by the Motions iOS application"/>
<figcaption>Alert message is received by the Motions iOS application</figcaption>
</figure>
</section>





</section>













<section data-type="sect1" id="_summary_6">
<h1>Summary</h1>

<p>In this chapter, we learned to use MQTTKit to send and receive MQTT messages from an iOS application.</p>

<p>To send a message, the application must do the following:</p>
<ol>
<li>
<p>Connect to the MQTT broker.</p>
</li>
<li>
<p>Send the message to the topic.</p>
</li>

</ol>

<p>To consume a message, the application must do the following:</p>
<ol>
<li>
<p>Connect to the MQTT broker.</p>
</li>
<li>
<p>Subscribe to the topic.</p>
</li>
<li>
<p>Define a message handler block that is called every time a message is received. This block is executed on a dispatch queue. If there is any code that changes the user interface, it must be wrapped in a block executed on the main queue.</p>
</li>

</ol>

<p>We used two different types of message payloads:</p>
<ul>
<li>
<p>A binary payload to send the device motions values as three 64-bit floats.</p>
</li>
<li>
<p>A text payload to extract a background color from the messages received on the alert topic.</p>
</li>
</ul>
</section>







</section>
