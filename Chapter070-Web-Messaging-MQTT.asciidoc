[[ch_web_mqtt]]
== Web Messaging With MQTT

[role="lead"]
In this chapter, we will write a Web application that sends and receives messages using the MQTT protocol over HTML5 Web Sockets.

[[img_web_mqtt_1]]
.Diagram of the +Motions+ Web application that displays data for two devices
image::images/Chapter070/mqtt_web_app.png["The +Motions+ Web application that displays data for two devices."]

=== Paho JavaScript client

In <<ch_mobile_mqtt_paho>>, we mentioned http://eclipse.org/paho[Eclipe Paho] as our MQTT applications use the broker hosted by it.
Eclipse Paho provides a variety of MQTT clients for different languages and platforms. In particular, they offer a JavaScript client for Web browser that uses HTML5 Web Sockets.

The source code of the project is hosted in this  http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.javascript.git/[Git repository].

=== About the Code

All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +mqtt/web/+ directory.

=== Bootstrap the Motions Web Application

As we explained in <<ch_introduction_mqtt_example>>, this Web application will display on a Web page the motion data sent by the devices using the +Motions+ iOS application written in the previous chapter.
Additionnally, the Web application will also be able to send alert messages to the devices.

It will be a very simple one-page Web application that can be run from a Web server serving static pages. It does not require
any server-side runtime as all the code will be executed inside the Web browser using JavaScript.

To display the device motions data, we will use http://en.wikipedia.org/wiki/Sparkline[Sparklines]. The Web application use jQuery and a library named http://omnipotent.net/jquery.sparkline(jQuery Sparklines) for this.

Note however that we use jQuery for convenience but the MQTT JavaScript client does not require it at all and can be used with any JavaScript frameworks or libraries.
 
Let's bootstrap the Web application by creating a *motions.html__* page.

[[ex_web_mqtt_1]]
====
[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <meta content="width=device-width" name="viewport">
  <meta charset="utf-8">
  <title>Motions - MQTT Example</title>
  <link rel="stylesheet" type="text/css" href="http://bgrins.github.com/spectrum/spectrum.css">
</head>
<body>
  <h1>Motions - MQTT Example</h1>
  
  <h2>Devices</h2>
  <ul id="devices">
  </ul>

  <footer>&copy; 2014 <a href="http://mobile-web-messaging.net">Mobile &amp; Web Messaging</a></footer>

  <script src='mqttws31.js'></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
  <script src="http://omnipotent.net/jquery.sparkline/2.1.2/jquery.sparkline.min.js"></script>
  <script>
$(document).ready(function() {

// We will put all the JavaScript code in this block that is called
// when the document is ready

});
  </script>
</body>
</html>
----
====

=== Create a MQTT Client with mqttws31.js

When the browser loads this page, we will cerate a MQTT client using the JavaScript library.

To create the client we must pass the MQTT broker host and port. In our case, it is respectively +iot.eclipse.org+ and +80+. Note than in <<ch_mobile_mqtt_client>>, the +Motions+ iOS application was connecting to +iot.eclipse.org+ on its default port +1883+. This default port expects a TCP socket connection. Since the Web application uses HTML5 Web Sockets, it must connect to the +80+ port that will handle the HTTP Upgrade process from the initial HTTP connection.

We also need to configure a +clientID+ that identifies the MQTT client.
In our case, we will just use a random String.

[source,js]
----
$(document).ready(function() {

  var host = "iot.eclipse.org";
  var port = 80;
  var clientID = Math.random().toString(12);

  var devices = {};

  var client = new Messaging.Client(host, Number(port), clientID);
}
----

=== Connect to the MQTT Broker

Once the +client+ is created, the next step is to connect to the MQTT broker.
There are four steps to achieve that in a proper fashion:

. define a +onConnectionLost+ handler that will be called back if the connection is lost _after the client has been successfully connected_.
. define a +onSuccess+ handler that will be called if the client is successfully connected
. define a +onFailure+ handler that will be called if the client fails to connect to the broker.
. call +client.connect()+ and pass the +onSuccess+ and +onFailure+ handlers in an object parameter.

[source,js]
----
  client.onConnectionLost = function(response) {
    if (response.errorCode !== 0) {
      alert(response.errorMessage + "\nclientID = " + client.clientID + " [" + response.errorCode + "]\n");
    }
  };            
  client.connect({onSuccess: function(frame) {
    // this function is executed after a successful connection to the MQTT broker.
  },
    onFailure: function(failure) {
      alert(failure.errorMessage);
    }
  }); 
----

All these handlers are optional and you may omit them. However without them, the Web application may fail to connect or lose connection without any way to let the user be aware of it.

=== Receive MQTT Messages

Once the client is successfully connected to the MQTT broker (that is to say when the +onSuccess+ handler is called), we can then subscribe to a topic to receive all the device motions.

Since MQTT client does not know the whole list of devices that send their motion data, it can not subscribe to specific MQTT topics.

Fortunately MQTT defines wildcards for topic that is useful for this case.
There are three characters that have a special meaning when they are used in a MQTT topic.

Topic level separator +/+::
The forward slash (/) is used to separate each level within a topic tree and provide a hierarchical structure to the topic space. The use of the topic level separator is significant when the two wildcard characters are encountered in topics specified by subscribers.

Multi-level wildcard +#+::
The number sign (#) is a wildcard character that matches any number of levels within a topic.

Single-level wildcard +$$+$$+::
The plus sign (+) is a wildcard character that matches only one topic level. 

The Web application is interested to receive any messages sent to topics of the form +/mwm/XXX/motion+ where +XXX+ is the device identifier. It maps to the MQTT wildcard topic +/mwm/$$+$$/motion+.

Note that it would not have been a good idea to use the more general wildcard +/mwm/#+ (using the multi-level wildcard) as it would have matched both +/mwm/XXX/motion+ _and_ +/mwm/XXX/alert+. The Web application is not interested by the alert sent to the devices. It is better to subscribe to the most specific wildcard topic instead of being too general and filters out message later. This also preserve network bandwith and CPU usage that the broker will not deliver messages to the client that would have to process them before discarding them anyhow.

[source,js]
----
  client.connect({onSuccess: function(frame) {
    // once the client is successfully connected,
    // subscribe to all the motions topics
    client.subscribe("/mwm/+/motion");
  },
    onFailure: function(failure) {
      alert(failure.errorMessage);
    }
  });
----

We have subscribed to the +/mwm/$$+$$/motion+ wildcard topic but how do we handle messages that will be delivered by the broker for all the topics that matches?

The +client+ object has a +onMessageArrived+ property that will be called every time a message is delivered to the client. This property must be a function that takes a single +message+ parameter corresponding to the MQTT message that is delivered to the client.

This +message+ object defines several properties representing the MQTT message data. The +destinationName+ property contains the actual name of the topic that
delivered this message. Since we have chosen to use a meaningful topic names of the form +/mwm/XXX/motion+, we can extract the +deviceID+ from the +destinationName+.

The +message+ object defines two properties to receive its payload content:

* +payloadBytes+ corresponds to a +ArrayBuffer+ representation of the message payload
* +payloadString+ corresponds to a UTF-8 string representation of the message payload. This property can only be used if the payload is composed of valid UTF-8 characters.

In <<ch_introduction_mqtt_example_message>>, we decided to send the device motions data as an array of 3 64-bit floats corresponding to the motions pitch, yaw and roll values.

To be able to get these values, we must use the +payloadBytes+ property and use a +DataView+ to retrieve the three values for this array.

Once we got these +pitch+, +roll+, and +yaw+ values, we call the +updateSparklines()+ method to udpate the sparkline for the given +deviceID+

[source,js]
----
// subscription callback
client.onMessageArrived = function(message) {
  // get the device's id from the message's destination
  var deviceID = message.destinationName.split("/")[2];

  // get the device data from the message payload as a byte array
  var data = message.payloadBytes;
  // use a DataView on the data buffer to get the 3 motions values as double (aka Float64)
  var values = new DataView(data.buffer);
  var pitch = values.getFloat64(data.byteOffset);
  var roll = values.getFloat64(data.byteOffset + Float64Array.BYTES_PER_ELEMENT);
  var yaw = values.getFloat64(data.byteOffset + 2 * Float64Array.BYTES_PER_ELEMENT );

  updateSparklines(deviceID, pitch, roll, yaw);
};
----

=== Draw Sparklines

TODO

[source,js]
----
function updateSparklines(deviceID, pitch, yaw, roll) {
  var values = devices[deviceID];
  // if the device is not known, create the UI for it
  if (!values) {
    var item = $('#devices').append(
      $('<li>').attr("id", deviceID).append(
        $('<label>').text(deviceID),
        $('<button>').text("Alert!").click(function() { sendAlert(deviceID); }),
        $('<br>'),
        $('<div>').attr('class', 'rate')
      )
    );
    // create an empty array to hold its values
    values = {
      "pitch" : [],
      "roll" : [],
      "yaw" : [],        
    };
  }    
  // add the new value at the end of the array
  values.pitch.push(pitch);
  values.roll.push(roll);
  values.yaw.push(yaw);
  // keep only the 50 more recent values
  if (values.pitch.length > 50) {
    values.pitch.splice(0,1); 
    values.roll.splice(0,1); 
    values.yaw.splice(0,1); 
  }
  // put back the updated values in the clients map
  devices[deviceID] = values;
  // display the values as a sparkline
  $('#'+ deviceID + ' .rate').sparkline(values.pitch, {
    width: values.pitch.length * 5,
    tooltipPrefix: "pitch:",
    lineColor: 'red',
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3,
    height: '36px'
  });
  $('#'+ deviceID + ' .rate').sparkline(values.roll, {
    tooltipPrefix: "roll:",
    lineColor: 'green',
    composite: true,
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3
  });
  $('#'+ deviceID + ' .rate').sparkline(values.yaw, {
    tooltipPrefix: "yaw:",
    lineColor: 'blue',
    composite: true,
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3
  });
}
----

TODO

[[img_web_mqtt_2]]
.Two +Motions+ app are publishing their device motions.
image::images/Chapter070/motions_web_app.png["Two +Motions+ app are publishing their device motions."]


=== Send MQTT Messages

[source,js]
----
function sendAlert(deviceID) {
  // create a message with an empty payload
  var message = new Messaging.Message("red");
  message.destinationName = "/mwm/" + deviceID + "/alert";
  client.send(message);
}
----

TODO

[[img_web_mqtt_3]]
.The +Motions+ application backgrounds becomes red when an alert is sent to its alert topic.
image::images/Chapter070/app_red.png["The +Motions+ application backgrounds becomes red when an alert is sent to its alert topic."]


=== Summary

TODO