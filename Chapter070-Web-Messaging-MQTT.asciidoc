[[ch_web_mqtt]]
== Web Messaging With MQTT

[role="lead"]
In this chapter, we will write a Web application that sends and receives messages using the MQTT protocol over HTML5 Web Sockets.

[[img_web_mqtt_1]]
.Diagram of the +Motions+ Web application that displays data for two devices
image::images/Chapter070/mqtt_web_app.png["The +Motions+ Web application that displays data for two devices."]

=== About the Code

All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +mqtt/web/+ directory.

=== Paho JavaScript client

In <<ch_mobile_mqtt_paho>>, we mentioned http://eclipse.org/paho[Eclipe Paho] as our MQTT applications use the broker hosted by it.
Eclipse Paho provides a variety of MQTT clients for different languages and platforms. In particular, they offer a JavaScript client for Web browser that uses HTML5 Web Sockets.

The source code of the project is hosted in this  http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.javascript.git/[Git repository].

=== Bootstrap the Motions Web Application

As we explained in <<ch_introduction_mqtt_example>>, this Web application will display on a Web page the motion data sent by the devices using the +Motions+ iOS application written in the previous chapter.
Additionnally, the Web application will also be able to send alert messages to the devices.

It will be a very simple one-page Web application that can be run from a Web server serving static pages. It does not require
any server-side runtime as all the code will be executed inside the Web browser using JavaScript.

To display the device motions data, we will use http://en.wikipedia.org/wiki/Sparkline[Sparklines]. The Web application use jQuery and a library named http://omnipotent.net/jquery.sparkline(jQuery Sparklines) for this.

Note however that we use jQuery for convenience but the MQTT JavaScript client does not require it at all and can be used with any JavaScript frameworks or libraries.
 
Let's bootstrap the Web application by creating a *motions.html__* page.

[[ex_web_mqtt_1]]
====
[source,html]
----
<!DOCTYPE html>
<html>
<head>
  <meta content="width=device-width" name="viewport">
  <meta charset="utf-8">
  <title>Motions - MQTT Example</title>
  <link rel="stylesheet" type="text/css" href="http://bgrins.github.com/spectrum/spectrum.css">
</head>
<body>
  <h1>Motions - MQTT Example</h1>
  
  <h2>Devices</h2>
  <ul id="devices">
  </ul>

  <footer>&copy; 2014 <a href="http://mobile-web-messaging.net">Mobile &amp; Web Messaging</a></footer>

  <script src='mqttws31.js'></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>
  <script src="http://omnipotent.net/jquery.sparkline/2.1.2/jquery.sparkline.min.js"></script>
  <script>
$(document).ready(function() {

// We will put all the JavaScript code in this block that is called
// when the document is ready

});
  </script>
</body>
</html>
----
====

=== Create a MQTT Client with mqttws31.js

When the browser loads this page, we will cerate a MQTT client using the JavaScript library.

To create the client we must pass the MQTT broker host and port. In our case, it is respectively +iot.eclipse.org+ and +80+. Note than in <<ch_mobile_mqtt_client>>, the +Motions+ iOS application was connecting to +iot.eclipse.org+ on its default port +1883+. This default port expects a TCP socket connection. Since the Web application uses HTML5 Web Sockets, it must connect to the +80+ port that will handle the HTTP Upgrade process from the initial HTTP connection.

We also need to configure a +clientID+ that identifies the MQTT client.
In our case, we will just use a random String.

[source,js]
----
$(document).ready(function() {

  var host = "iot.eclipse.org";
  var port = 80;
  var clientID = Math.random().toString(12);

  var devices = {};

  var client = new Messaging.Client(host, Number(port), clientID);
}
----

=== Connect to the MQTT Broker

Once the +client+ is created, the next step is to connect to the MQTT broker.
There are four steps to achieve that in a proper fashion:

. define a +onConnectionLost+ handler that will be called back if the connection is lost _after the client has been successfully connected_.
. define a +onSuccess+ handler that will be called if the client is successfully connected
. define a +onFailure+ handler that will be called if the client fails to connect to the broker.
. call +client.connect()+ and pass the +onSuccess+ and +onFailure+ handlers in an object parameter.

[source,js]
----
  client.onConnectionLost = function(response) {
    if (response.errorCode !== 0) {
      alert(response.errorMessage + "\nclientID = " + client.clientID + " [" + response.errorCode + "]\n");
    }
  };            
  client.connect({onSuccess: function(frame) {
    // this function is executed after a successful connection to the MQTT broker.
  },
    onFailure: function(failure) {
      alert(failure.errorMessage);
    }
  }); 
----

All these handlers are optional and you may omit them. However without them, the Web application may fail to connect or lose connection without any way to let the user be aware of it.

=== Receive MQTT Messages

Once the client is successfully connected to the MQTT broker (that is to say when the +onSuccess+ handler is called), we can then subscribe to a topic to receive all the device motions.

Since MQTT client does not know the whole list of devices that send their motion data, it can not subscribe to specific MQTT topics.

Fortunately MQTT defines wildcards for topic that is useful for this case.
There are three characters that have a special meaning when they are used in a MQTT topic.

Topic level separator +/+::
The forward slash (/) is used to separate each level within a topic tree and provide a hierarchical structure to the topic space. The use of the topic level separator is significant when the two wildcard characters are encountered in topics specified by subscribers.

Multi-level wildcard +#+::
The number sign (#) is a wildcard character that matches any number of levels within a topic.

Single-level wildcard +$$+$$+::
The plus sign (+) is a wildcard character that matches only one topic level. 

The Web application is interested to receive any messages sent to topics of the form +/mwm/XXX/motion+ where +XXX+ is the device identifier. It maps to the MQTT wildcard topic +/mwm/$$+$$/motion+.

Note that it would not have been a good idea to use the more general wildcard +/mwm/#+ (using the multi-level wildcard) as it would have matched both +/mwm/XXX/motion+ _and_ +/mwm/XXX/alert+. The Web application is not interested by the alert sent to the devices. It is better to subscribe to the most specific wildcard topic instead of being too general and filters out message later. This also preserve network bandwith and CPU usage that the broker will not deliver messages to the client that would have to process them before discarding them anyhow.

[source,js]
----
  client.connect({onSuccess: function(frame) {
    // once the client is successfully connected,
    // subscribe to all the motions topics
    client.subscribe("/mwm/+/motion");
  },
    ...
  });
----

We have subscribed to the +/mwm/$$+$$/motion+ wildcard topic but how do we handle messages that will be delivered by the broker for all the topics that matches?

The +client+ object has a +onMessageArrived+ property that will be called every time a message is delivered to the client. This property must be a function that takes a single +message+ parameter corresponding to the MQTT message that is delivered to the client.

This +message+ object defines several properties representing the MQTT message data. The +destinationName+ property contains the actual name of the topic that
delivered this message. Since we have chosen to use a meaningful topic names of the form +/mwm/XXX/motion+, we can extract the +deviceID+ from the +destinationName+.

The +message+ object defines two properties to receive its payload content:

* +payloadBytes+ corresponds to a +ArrayBuffer+ representation of the message payload
* +payloadString+ corresponds to a UTF-8 string representation of the message payload. This property can only be used if the payload is composed of valid UTF-8 characters.

In <<ch_introduction_mqtt_example_message>>, we decided to send the device motions data as an array of 3 64-bit floats corresponding to the motions pitch, roll, and yaw values.

To be able to get these values, we must use the +payloadBytes+ property and use a +DataView+ to retrieve the three values for this array.

Once we got these +pitch+, +roll+, and +yaw+ values, we call the +updateSparklines()+ method to udpate the sparkline for the given +deviceID+

[source,js]
----
// subscription callback
client.onMessageArrived = function(message) {
  // get the device's id from the message's destination
  var deviceID = message.destinationName.split("/")[2];

  // get the device data from the message payload as a byte array
  var data = message.payloadBytes;
  // use a DataView on the data buffer to get the 3 motions values as double (aka Float64)
  var values = new DataView(data.buffer);
  var pitch = values.getFloat64(data.byteOffset);
  var roll = values.getFloat64(data.byteOffset + Float64Array.BYTES_PER_ELEMENT);
  var yaw = values.getFloat64(data.byteOffset + 2 * Float64Array.BYTES_PER_ELEMENT );

  updateSparklines(deviceID, pitch, roll, yaw);
};
----

=== Draw Sparklines

The +updateSparklines()+ method will store the motions values in the +devices+ object that was created when the page is loaded.
It will create the HTML elements to display the data and use jQuery Sparklines to display them in a graphic.

The +devices+ object is a map whose keys will the +deviceID+s of the device that are sending the motion data. The values will be composed of three arrays to store the received value for +pitch+, +roll+, +yaw+. We will only keep the 50 most recent values.

We will create three separate sparklines for:

* +pitch+ (displayed in red)
* +roll+ (diplayed in green)
* +yaw+ (displayed in blue)

These three sparkline will be composited in a single canvas that is drawn in the +<div class="data">+ elment created inside the +<div>+ element identified by the +deviceID+.

[source,js]
----
function updateSparklines(deviceID, pitch, yaw, roll) {
  var values = devices[deviceID];
  // if the device is not known, create the UI for it
  if (!values) {
    var item = $('#devices').append(
      $('<li>').attr("id", deviceID).append(
        $('<label>').text(deviceID),
        $('<button>').text("Alert!").click(function() { sendAlert(deviceID); }),
        $('<br>'),
        $('<div>').attr('class', 'data')
      )
    );
    // create an empty array to hold its values
    values = {
      "pitch" : [],
      "roll" : [],
      "yaw" : [],        
    };
  }    
  // add the new value at the end of the array
  values.pitch.push(pitch);
  values.roll.push(roll);
  values.yaw.push(yaw);
  // keep only the 50 more recent values
  if (values.pitch.length > 50) {
    values.pitch.splice(0,1); 
    values.roll.splice(0,1); 
    values.yaw.splice(0,1); 
  }
  // put back the updated values in the clients map
  devices[deviceID] = values;
  // display the values as a sparkline
  $('#'+ deviceID + ' .data').sparkline(values.pitch, {
    width: values.pitch.length * 5,
    tooltipPrefix: "pitch:",
    lineColor: 'red',
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3,
    height: '36px'
  });
  $('#'+ deviceID + ' .data').sparkline(values.roll, {
    tooltipPrefix: "roll:",
    lineColor: 'green',
    composite: true,
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3
  });
  $('#'+ deviceID + ' .data').sparkline(values.yaw, {
    tooltipPrefix: "yaw:",
    lineColor: 'blue',
    composite: true,
    fillColor: false,
    chartRangeMin: -3,
    chartRangeMax: 3
  });
}
----

Note that we also create a button "Alert!" for each devices that calls the +sendAlert()+ method with the +deviceID+ when the button is clicked. We will implement this method in the next section.

At this stage, we can alreay load the application in a Web browser. If there are devices that are running the +Motions+ iOS applications, we will see them appear automatically on the page.

[[img_web_mqtt_2]]
.Two +Motions+ app are publishing their device motions.
image::images/Chapter070/motions_web_app.png["Two +Motions+ app are publishing their device motions."]

=== Send MQTT Messages

We have now create a Web application that receives MQTT messages.

The other feature of this Web application is to _send_ a MQTT message to an alert topic so that the device that subscribes to this topic will change its background color using the message payload.

When the HTML elements for a device were created, we added a +<button>+ that calls +sendAlert(deviceID)+ when the user clicks on it.

In this method, we will create a MQTT message object using the +new Messaging.Message()+ constructor and pass a +"red"+ to it to set its payload.

The message object has a +destinationName+ property that must be set prior to sending the message. We use the +deviceID+ to build the name of the topic corresponding to this device alert: +"/mwm/" $$+$$ deviceID $$+$$ "/alert"+.

Finally last step is to call +client.send()+ and pass it the +message+ to send it to the topic. Note that the +client+ is already connected when the page was loaded.

[source,js]
----
function sendAlert(deviceID) {
  // create a message with an empty payload
  var message = new Messaging.Message("red");
  message.destinationName = "/mwm/" + deviceID + "/alert";
  client.send(message);
}
----

If we reload the web application and clicks on an "Alert!" button, the corresponding device will receive the message from its alert topic and the code that we wrote in <<ch_mobile_mqtt_receive>> will be executed to change temporarily the background color of the device.

[[img_web_mqtt_3]]
.The +Motions+ application background becomes red when an alert is received from its alert topic.
image::images/Chapter070/app_red.png["The +Motions+ application background becomes red when an alert is received from its alert topic."]

=== Summary

In this chapter, we learn to use MQTT over Web Socket to send and receive MQTT messages from a Web application.

We dealts with two type of message payload:

* a binary payload composed of 3 64-bit floats
* a String payload

To send a message, the application must:

. connect to the MQTT broker
. send the message to a topic

To consume a message, the application must

. connect to the STOMP broker
. subscribe to a (potentially wildcard) topic and set a handler that is called every time a message is received.

In the next chapter, we will learn about more advanced features of MQTT that were not required to write this simple application. However, it is likely that you may need some of these features if your applications are more complex.

