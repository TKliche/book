[[ch_advanced_stomp]]
== Advanced STOMP

[role="lead"]
In the two previous chapters, we have used STOMP to send and receive messages from a native iOS application and from a Web application.
STOMP provides additional features that we did not use to write these applications. In this chapter, we will make a tour of all the features provided by STOMP.

This chapter covers the latest version of the protocol when this book was written:
http://stomp.github.io/stomp-specification-1.2.html[STOMP 1.2] that was released on 2012, October 22^nd^.

As we present these features, we will show how to use them from either +StompKit+ or +stomp.js+. The API may vary depending on the platform and language but the concept remains the same. If you have ever to use STOMP from another language or platform, you will have to adapt to the library API but the underlying concept will still apply.

[[ch_adv_stomp_frame]]
=== Frame representation

STOMP is modelled on HTTP and based on _frames_.
Each frame is composed of 3 elements:

* a _command_
* an (optional) set of _headers_
* an (optional) _payload_

[[ex_stomp_frame]]
.STOMP Frame Structure
====
----
COMMAND<1>
header1:value1<2>
header2:value2
<3>
payload^@<4>
----
<1> A frame starts with a command string followed by an end-of-line (EOL)
<2> Header entries followed the format +<key>:<value>+ and is ended by EOL
<3> A blank line separates the set of headers from the payload
<4> A frame is ended by a NULL octet (represented by +^@+ in ASCII)
====

STOMP is based on text (using UTF-8 for its default encoding)
but it can also transmit binary data in its payload by specifying an alternative encoding.

In the two previous chapters, we were sending JSON data in the messages. We were setting the string representation of the JSON structure in the message body and setting the `content-type` header to `application/json; charset=utf-8`.

STOMP uses frames not only to send messages (with the +SEND+ command) and receive them (with the +MESSAGE+ command) but also for all its operation comands (such as +CONNECT+, +DISCONNECT+, +SUBSCRIBE+, etc.)

==== Headers

STOMP defines only a handful of headers for its different frames.

It is also possible to add other headers when sending a frame as long as it does not collide with the headers already specified in the STOMP protocol.

Why would we use headers to pass information instead of putting it in the message payload? The fundamental difference between headers and payload is that  headers can be read (and modified) by the STOMP brokers. Payload is treated a  a black box and the broker never reads or modifies it.

We will cover some use cases for adding headers in the next chapter.

=== Authentication

TODO

=== Message Acknowledgement

Message acknowledgement is a feature available to STOMP _consumers_.

When the broker delivers a message to a consumer, there is an change of responsibility between the broker and the consumer to determine which is the _owner_ of the message. The consumer becomes responsible of the message by _ackonwledging_ the message.

By default, the STOMP broker will consider that the consumer automatically acknowledge the message when it is delivered to the consumer.

However there are cases where the consumer may prefer to acknowledge explicity the message. It leaves it a window of opportunity to determine whether it can handle the message or not.
For example, the client needs to write the message payload in a data store.
There may be issues with opening a connection to the data store and the client could chose to acknowledge the message only after having successfully written its body to the data store. In case of failure, it will instead _nack_ the message (explicitly refuse to take ownership of it). When the STOMP broker is informed of this negatively acknowledgement, it may then decide to deliver the message to another consumer subscribed to the destination or try again some time later depending on its configuration.

The consumer specifies its type of acknowledgement when it subscribes to a destination.
STOMP supports 3 types of acknowledgements:

* +auto+ (by default)
* +client+
* +client-individual+

If the client does not specify any type of acknowledgement or use +default+, it does not need to send any acknowledgement, the STOMP broker will consider the message acknowledged as soon as it is delivered to the client.

If +client+ or +client-individual+ is used, the consumer must send acknowledgements to the server with the +message-id+ that is acknowledged. The difference between +client+ and +client-individual+ is that +client+ will acknowledged the message *and all other messages delivered to the consumer before*. Using +client-individual+ will only acknowledge the message and no other messages. The consumer acknowledge a message by sending a +ACK+ frame to the STOMP broker.

If +client+ and +client-individual+ is used, the consumer may explicitly refuse to handle the message by sending a +NACK+ frame, a negative acknowledgement.

==== +StompKit+ Example

The message acknowledgement is specified when the +STOMPClient+ subscribes to a destination by calling its +subscribeTo:headers:messageHandler:+ method.
To specify a +client+ or +client-individual+ acknowledgement, you must set a +ack+ header. +StompKit.h+ defines constants to represent the header name, +kHeaderAck+ and its accepted values, +kAckAuto+, +kAckClient+, and ++kAckClientIndividual).

The +STOMPMessage+ parameter of the +messageHandler+ has two methods +ack+ and +nack+ to respectively acknowledge or nack the message.

If the +ack+ header is not set or if it set to +auto+, message acknowledgement is performed by the broker and calling the +STOMPMessage+'s +ack+ and +nack+ methods will do nothing.

[source,objc]
----
// use client acknowledgement
[self.client subscribeTo:destination
                 headers:@{kHeaderAck: kAckClient}
          messageHandler:^(STOMPMessage *message) {
              // process the message
              // ...
              
              // acknowledge it
              [message ack];
              // or nack it with
              // [message nack]
          }];
----

====  +stomp.js+ Example

The +client+ can specify the type of acknowledgement by passing a dictionary with the +ack+ header as the last parameter of its +subscribe+ message.

The +message+ parameter of the +subscribe+ callback has two methods, +ack+ and +nack+ to respectively acknowledge or nack the message.
If the acknowledgement type is +auto+ (or if it is not specified at all), these +ack+ and +nack+ methods will do nothing.

[source,js]
----
client.subscribe(destination, 
  function(message) {
    // process the message
    ...

    // acknowledge it
    message.ack();
    // or you can nack it by calling message.nack() instead.
  },
  {"ack": "client"}
);
----

There are many use cases where it is not necessary to use explicit acknowledgement.

For example, in the +Locations+ Web application, we do not need to acknowledge every message that we receive from the devices with their GPS position. At worst, there may be a problem to display the position but we know there are other messages that will come later to update the device's position.

Besides, acknowledging every message would have a performance cost. Sending the acknowledgement back to the broker would involve an additional network trip for every message.

The +Locations+ iOS application is also consuming messages from the truck's text queue.
These messages may be more important to acknowledge them explicitly. We could enhance the application by letting the user confirms that it has read the message's text and the message would be acknowledged after this confirmation only.

We could also let the user reject it by negatively acknowledged the message.
In that case, these _nacked_ messages would be handled back by the STOMP broker. Depending on the broker you use, it may provide additional features to handle these messages. A common feature is to use a "dead letter queue" where messages that are nacked multiple times from a destination are sent to a dead letter queue. An administrator can then inspect this dead letter queue to determine what to do with these messages. For example, it can send them to another device, send alerts about the device that rejected them, etc.

=== Transactions

STOMP has basic support for transactions.

Sending a message or acknowledging the consumption of messages can be performed inside a transaction.
This means that the messages and acknowledgements are not processed by the broker when it receives the corresponding frames but when the transaction completes. If the client does not complete the transaction or aborts it, the broker will not process the frames that it received inside  the transaction and will just discard them. Transactions ensure that messages and acknowledgement processing is _atomic_. _All_ transacted messages and acknowledgements will be processed by the broker when the transaction is committed or _none_ will be if the transaction is aborted.

A transaction is started by the client by sending a +BEGIN+ frame to the broker. This frame must have a +transaction+ header whose value is a transaction identifier that must be unique within a STOMP connection.

Sending a message can then be part of this transaction by adding a +transaction+ header to its +SEND+ frames set to the same transaction identifier.
If a consumer is subscribed to a STOMP destination with +client+ or +client-individual+ acknowledgement modes, it can also make the message acknowledgement (or nack) inside a transaction by setting the +transaction+ header on the +ACK+ (or +NACK+) frame.

[NOTE]
====
By default, STOMP consumers use +auto+ acknowledgement. In that case, the message acknowledgement is performed automatically by the STOMP broker when the message is delivered to the client and the acknowledgement can *not* be put inside a transaction.
====

To complete this active transaction and allows the broker to process it, the client must send a +COMMIT+ frame with the same +transaction+ header than in the corresponding +BEGIN+ frame that started the transaction.
To abort (or roll back) a transaction and discard any messages or acknowledgements sent inside it, the client must send instead an +ABORT+ frame with this +transaction+ header.

[WARNING]
====
Beginning a transaction is not sufficient to send subsequent messages inside it. If a transaction is begun, the message to send must have its +transaction header+ set to the transaction identifier. Otherwise, the STOMP broker will not consider that the message is part of the transaction and will process it when it receives it instead of waiting for the transaction completion. If the client decides to abort the transaction, the message will have already been processed by the broker and will not be discarded.
====

STOMP does not provide a transaction timeout that would abort the transaction if it is not completed in a timely fashion.
The transaction lifecycle (controlled by +BEGIN+ and +COMMIT+/+ABORT+ frames) is the responsibility of the client.
However the broker will automatically abort any active transaction if the client send a +DISCONNECT+ frame or if the underlying TCP connection fails.

==== +StompKit+ Example

The +STOMPClient+ can begin a transaction by calling its +begin:+ method and passing a +NSString+ that will be used to identify the transaction. Alternatively, you can call its +begin+ method (without any parameter) and a transaction identifier will be automatically generated. Both +begin:+ and +begin+ methods returns a +STOMPTransaction+ object.
This object as a +identifier+ property that contains the transaction identifier.

Sending a message, acknowledging, or nacking it can then be part of a transaction by adding a +transaction+ header set to the transaction identifier (+StompKit.h+ defines a +kHeaderTransaction+ to represent this +transaction+ header).

Finally the +STOMPTransaction+ object has two methods +commit+ and +abort+ to respectively commit or rollback the transaction.

[source,objc]
----
// begin a transaction
STOMPTransaction *transaction = [self.client begin];
// or STOMPTransaction *transaction = [self.client begin:mytxid];
NSLog(@"started transaction %@", transaction.identifier);

// send message inside a transaction
[self.client sendTo:destination
            headers:@{kHeaderTransaction: transaction.identifier}
               body:body];

// acknowledge a message inside a transaction
[message ack:@{kHeaderTransaction: transaction.identifier}];
// or nack a message inside a transaction with
// [message nack:@{kHeaderTransaction: transaction.identifier}];

// commit the transaction
[transaction commit];
// or abort it
[transaction abort];
----

==== +stomp.js+ Example

The API is very similar to +StompKit+. The +client+ object has a +begin+ method that can takes a parameter corresponding to the transaction identifier. If there is no parameter, an identifier is automatically generated. The +begin+ method returns a +transaction+ object that has an +id+ property corresponding to the transaction identifier.

Sending a message, acknowledging, or nacking it can be part of a transaction by passing a +transaction+ header set to the transaction identifier to these methods.

Finally, committing or aborting a transaction is performed by calling respectively the +commit+ and +abort+ method on the +transaction+ object.

[source,js]
----

// begin a transaction
var tx = client.begin();
// or var tx = client.begin(mytxid);
console.log("started transaction " + tx.id);

// send a message inside a transaction
client.send(destination, {transaction: tx.id}, body);

// acknowledge a message inside a transaction
var subscription = client.subscribe(destination,
    function(message) {
      // do something with the message
      ...
      // and acknowledge it inside the transaction
      message.ack({ transaction: tx.id});
      // or nack it inside the transaction
      // message.nack({ transaction: tx.id});
    },
    {ack: 'client'}
  );

// commit the transaction
tx.commit();
// or abort it
tx.abort();
----

=== Receipts

TODO

=== Error handling

TODO

=== Heart-beating

STOMP offers a mechanism to test the healthiness of a connection between a STOMP client and a broker

==== +StompKit+ Example

[source,objc]
----
- (void)connect
{
    NSLog(@"Connecting...");
    self.client.errorHandler = ^(NSError* error) {
        NSLog(@"got error from STOMP: %@", error);
    };
    // will send a heartbeat at most every minute.
    // expect broker's heartbeat at least every 10 seconds.
    NSString *heartbeat = @"60000,10000";
    [self.client connectWithHeaders:@{ @"client-id": self.deviceID,
                                       kHeaderHeartBeat: heartbeat }
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      ...
                  }];
}
----

==== +stomp.js+ Example

[source,js]
----
// create the STOMP client
client = Stomp.client(url);
// will send a heartbeat at most every 20 seconds
client.heartbeat.outgoing = 20000;
// expects broker's heartbeat at least every 30 seconds
client.heartbeat.incoming = 30000;
client.connect({}, function(frame) {
  ...
});
----

=== Summary

TODO

