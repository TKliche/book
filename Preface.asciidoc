[preface]
== Preface

=== What This Book is About

This is a book about messaging protocols and how software developers can use them to build more responsive, resilient applications running on mobile devices and Web browsers.

Messaging protocols are nothing new. They have been used with success in enterprise software for many years. They have been one of the building blocks that let different services and platforms communicate with each other.
Their designs make them well suited to build applications for mobile devices and the Web.

Nowadays, HTTP has emerged as the mainstream transport protocol and is extensively used to communicate between any clients (from web browsers of course but also from desktop and mobile applications, backend services, etc.) and web servers. It has replaced almost all proprietary or non standard protocols and is likely to be the de facto choice if your application needs to communicate with any remote endpoint.

Messaging protocols complement HTTP and this book will show cases where a messaging protocol is better suited than HTTP (or any other request/reply transport protocol) to build mobile or web applications.

=== What This Book is _Not_ About

_Messaging_ is an overloaded term that can mean many different things in software development. In this book, we will only talk about _application messaging protocols_.

This book is not about _messaging applications_ like Apple's `Messages` or `WhatsApp`. These applications can be built on top of messaging protocols and this book may be a good introduction if you intend to build one. However there are many other features expected in messaging applications that will not be covered in this book.

This book is also not about _programming language or framework messaging_ (as used in Objective-C to invoke methods on a object or in Erlang to communicate between processes).

In the rest of this book, we will use the term _messaging_ in the context of application messaging protocol.

=== Messaging is Simple

At its core, the concept of a messaging protocol is simple:

* An application _produces_ a _message_ to a _destination_ on a _broker_.
* An application subscribes to this same destination to _consume_ the message.

In these two sentences, I introduced the five concepts that are (almost) all there is to know about messaging.

A messaging protocol is a simple idea. Most of the complexity of using one is figuring out the best suited _model_ for your applications (how the producers and consumers will exchanges messages). This book will show the two models that are most commonly used: _point-to-point_ and _publish/subscribe_.

=== Enterprise Messaging Is Not So Simple

When companies are acquired or merged, they need a way to enable communication between their systems. Messaging is one approach to achieve this integration in a unobstrusive way (as much as it is possible).
The systems must agree on the data representation (transmitted in the _message_) and the _destination_ (or the topic of interest shared by the different systems).

With its use in enterprise software, messaging protocols became increasingly complex to meet enterprise requirements (high-availability, failover, load-balancing, etc.).

Besides, the integrated applications must often agree on a messaging system to use throughout the company. In the Java world, the specification that deals with messaging is called Java Message Service <<jms>>. It defines a set of interfaces that a Java application can use to send and receive messages. However, JMS does not define any protocol (how the bytes are sent over the wire) and leave this implementation detail to the JMS brokers that implement the API. This means that JMS implementations are not interoperable: one must use the broker's client implementation to send a message to the broker. If applications were using different JMS brokers, they had interoperability issues and must use _bridges_ to transfer messages from one JMS broker to another. This lack of interoperability brings complexity as you need to add servers to host the bridges, make them redundant for high-availability, etc.

Over time, we have seen the appearances of enterprise messaging protocols such as the Advanced Message Queuing Protocol <<amqp>> that handles enterprise features and interoperability. This leads to complex protocols that are difficult to implement and whose interoperability is subjective (backwards compatibility is not guaranteed, different implementations may not implement the whole specification leading to interoperability issues).

=== Mobile Messaging Is Simple Again

The increasing complexity of messaging protocols used in enterprise software makes them difficult to implement and they are not best suited for constrained environments such as mobile devices.

Mobile devices requires messaging protocols with more constrained goals that turns out to be simpler and more efficient to use without draining battery or requiring always-on network connections.

While these simpler protocols do not provide all the features offered by enterprise-class messaging protocols, they are a good fit for mobile and Web platforms.

In this book, I will talk about two of them, STOMP and MQTT.

STOMP really shines for its simplicity if you need to send one text message from any system (operating system, virtual machines, web browsers) to another.
It is simple enough that a network client such as +telnet+ _is_ a STOMP client.

MQTT was created to broadcast data from small devices with low power usage and constrained memory resources. It is well suited for mobile devices as it preserves battery life and memory.

These protocols are simple to understand and implement. Messaging brokers often provide both of them. For example, a desktop application can use STOMP to send a message and another mobile application can consume the same message using MQTT. The applications are free to use the most appropriate messaging protocol for their needs and rely on the broker implementations for interoperability.

With the advent of mobile devices, we can use these simple messaging protocols to build more reactive, efficient applications. Since these protocols are available both for mobile and web platformss, choosing between these two plaftorms is not constrained by using a messaging protocol.

At the same time, we can leverage these messaging protocols to integrate with legacy systems too. If the messaging broker also supports an enterprise-class messaging API (such as JMS) or protocols (such as AMQP), we can build mobile and Web applications that can consume messages sent from legacy systems.

=== What's in This Book

In this book, I will introduce messaging protocols for mobile devices and Web applications.

Chapter 1, Introduction::
In this chapter, I introduce the concepts of messaging protocols, their models and message representation.
To illustrate the use of messaging protocols on mobile and Web platforms, we will build two applications, one using STOMP and the other MQTT.
Both applications will come in two parts: one will run on mobile devices, the other inside a Web browser and they will communicate using messages. This chapter explains the overall design of these two example applications.

Chapter 2, Mobile Messaging With STOMP::
In this chapter, I present STOMP, a simple text-based messaging protocol. I use StompKit, an iOS library for STOMP, to build the +Locations+ application that sends GPS data from the device and receives text messages.

Chapter 3, Web Messaging With STOMP::
In this chapter, I introduce stomp.js, a JavaScript library for STOMP, and write a Web application that receives messages with the GPS datat from the +Locations+ application on iOS devices and display them on a map. This Web application will also send text messages to the iOS application.

Chapter 4, Advanced STOMP::
In this chapter, I present the advanced features of STOMP that we did not use in the previous chapters to build our applications. These advanced features are not always used by messaging applications but they may prove useful as the applications grow in complexity.

Chapter 5, Beyond STOMP::
In this chapter, I present features that are not part of STOMP but available from some STOMP brokers. These features often help solve common issues and reduce code complexity by leveraging the brokers.

Chapter 6, Mobile Messaging With MQTT::
In this chapter, I introduce MQTT, a binary messaging protocol well suited to broadcast data from mobile or embedded devices and write a mobile application, +Motions+, on iOS that uses MQTT to broadcast data about the device motion using the MQTTKit libary and listen for alerts to change the color of the application.

Chapter 7, Web Messaging With MQTT::
In this chapter, I use MQTT over Web Socket to write a Web application that
receives the device motion data sent by the +Motions+ application to display them and sends alerts to the devices to change their color.

Chapter 8, Advanced MQTT::
In this chapter, I present the advanced features of MQTT that were not used in the previous chapters.

Appendix A, ActiveMQ::
In this appendix, we explain how to install and configure the messaging broker, Apache ActiveMQ, that is used in the book to run the STOMP examples.

Appendix B, Mosquitto::
In this appendix, we explain how to install and configure the Mosquitto broker and its command-line tools that are used in the book to send and receive MQTT messages.

.What Should I Read?
[NOTE]
====
The book is organized to be read in order but some chapters can be skipped depending on your experience.
The Chapter 1 introduces all the concepts discussed throughout the book.

If you are interested in mobile applications, you can focus on Chapters 2 and 6 that present two different messaging protocols for mobile devices.
If you are writing Web applications, Chapters 3 and 7 are the most relevant.

If you are interested by the STOMP protocol, Chapters 2, 3, 4, and 5 and the most relevant. If you are interested by MQTT, you can read Chapters 6, 7, and 8 instead.
====

=== Target Audience

This book is an introduction to the STOMP and MQTT messaging protocols and assumes no prior experience with them.
This book explains in detail the messaging protocols. Each platform's clients may provide a different API to deal with the protocols but the underlying concepts remain the same.
For both protocols, we will see two different libraries: an Objective-C library for iOS and a JavaScript library for Web applications.

Basic programming skills are required. The examples in the book runs on different platforms and we used the programming language that made the most sense for each of them.

The mobile applications on iOS will be written in Objective-C.
The graphical application requires minimal knowledge of Xcode and Interface Builder but all the changes are described step by step in the book.

The Web applications use the JavaScript language. We leverage http://jquery.com[jQuery] to make the Web applications interactive and manipulate the page elements but the messaging code is independent of any JavaScript frameworks.

=== Conventions Used in This Book

The following typographical conventions are used in this book:

_Italic_:: Indicates new terms, URLs, email addresses, filenames, and file extensions.

+Constant width+:: Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.

**`Constant width bold`**:: Shows commands or other text that should be typed literally by the user.

_++Constant width italic++_:: Shows text that should be replaced with user-supplied values or by values determined by context.

[TIP]
====
This icon signifies a tip, suggestion, or general note.
====

[WARNING]
====
This icon indicates a warning or caution.
====

=== Using Code Examples

Supplemental material (code examples, exercises, etc.) is available for download at link:$$https://github.com/mobile-web-messaging/code/$$[].

The book contains all the code required to run the examples and the general instructions to setup the user interface of the iOS applications.

This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.

We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “_Book Title_ by Some Author (O’Reilly). Copyright 2012 Some Copyright Holder, 978-0-596-xxxx-x.”

If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at pass:[<email>permissions@oreilly.com</email>].

=== Safari® Books Online

[role = "safarienabled"]
[NOTE]
====
pass:[<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">Safari Books Online</ulink>] is an on-demand digital library that delivers expert pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/content">content</ulink>] in both book and video form from the world&#8217;s leading authors in technology and business.
====

Technology professionals, software developers, web designers, and business and creative professionals use Safari Books Online as their primary resource for research, problem solving, learning, and certification training.

Safari Books Online offers a range of pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/subscriptions">product mixes</ulink>] and pricing programs for pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/organizations-teams">organizations</ulink>], pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/government">government agencies</ulink>], and pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/individuals">individuals</ulink>]. Subscribers have access to thousands of books, training videos, and prepublication manuscripts in one fully searchable database from publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley & Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones & Bartlett, Course Technology, and dozens pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/publishers">more</ulink>]. For more information about Safari Books Online, please visit us pass:[<ulink role="orm:hideurl" url="http://www.safaribooksonline.com/">online</ulink>].

=== How to Contact Us

Please address comments and questions concerning this book to the publisher:

++++
<simplelist>
<member>O’Reilly Media, Inc.</member>
<member>1005 Gravenstein Highway North</member>
<member>Sebastopol, CA 95472</member>
<member>800-998-9938 (in the United States or Canada)</member>
<member>707-829-0515 (international or local)</member>
<member>707-829-0104 (fax)</member>
</simplelist>
++++

We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at link:$$http://www.oreilly.com/catalog/<catalog page>$$[].

++++
<remark>Don't forget to update the link above.</remark>
++++

To comment or ask technical questions about this book, send email to pass:[<email>bookquestions@oreilly.com</email>].

For more information about our books, courses, conferences, and news, see our website at link:$$http://www.oreilly.com$$[].

Find us on Facebook: link:$$http://facebook.com/oreilly$$[]

Follow us on Twitter: link:$$http://twitter.com/oreillymedia$$[]

Watch us on YouTube: link:$$http://www.youtube.com/oreillymedia$$[]

=== Acknowledgments

I’d like to thank the many people who contributed to this book. I hope I have not forgotten anyone, but I probably have.

My colleagues at Red Hat provided help and support in innumerable ways. This list of people is necessarily very incomplete: Bill Burke (I should have listened to you: writing a book is a tiring experience!), Clebert Suconic and Andy Taylor for their messaging expertise, Mark Little for his support. A special thanks to Dimitris Andreadis for his trust and letting me spend a part of my work time on this book. Thanks to my teammates in the WildFly and EAP teams (Jason Greene, David M. Lloyd, Brian Stansberry, Kabir Khan, Tomaz Cerar, Emanuel Muckenhuber and all those I have pleasure to work with daily) that helped me lessen my workload so that I could focus on writing this book.

Andy Piper, Clebert Suconic, and Dejan Bosanac helped tremendously by reviewing this book. It is much better thanks to their comments and critics.

The people at O’Reilly were extremely helpful. It was a pleasure working with Allyson McDonald, Rebecca Demarest, and Simon St.Laurent.

Thanks to all developers that reported issues on this book and the code examples.
