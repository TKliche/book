[[ch_advanced_mqtt]]
== Advanced MQTT

[role="lead"]
In the two previous chapters, we have used MQTT to send and receive messages from a native iOS application and a Web application.
MQTT provides additional features that we did not use to write these applications. In this chapter, we will make a tour of all these advanced features provided by MQTT.

This chapter covers the latest version of the protocol when this book was written:
http://www.ibm.com/developerworks/webservices/library/ws-mqtt/index.html[MQTT v3.1] that was released on 2010, August 19^th^.

=== Authentication

In the two previous chapters, we connected to the Eclipse public MQTT broker that accepts _unauthenticated_ connections. We did not need to pass any user credentials as they would not be checked by the broker anyawy.

If you are using a MQTT broker that is configured to accept secured connections, the client needs to pass a _user name_ and _password_ when it connects to the broker.

==== +MQTTKit+ Example

The +MQTTClient+ has two +NSString+ properties that must be set to authenticate the client, +username+ and +password+. They must be set _prior_ to calling the client's +connect+ methods to take effect.

If the MQTT broker requires authentication, the client can check if the connection was refused due to invalid user credentials using the +ConnectionRefusedBadUserNameOrPassword+ error code from the +completionHandler+.

[source,objc]
----
- (void)connect
{
    NSString *username = @"...";
    NSString *password = @"...";

    self.client.username = username;
    self.client.password = password;
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        if (code == ConnectionAccepted) {
            NSLog(@"connected to the MQTT broker");
            [self subscribe];
        } else if (code == ConnectionRefusedBadUserNameOrPassword) {
            NSLog(@"Failed to authenticate the user");
        } else {
            NSLog(@"Failed to connect to the MQTT broker: code=%lu", (unsigned long)code);
        }
    }];
}
----

==== +mqttws31.js+ Example

To authenticate using the +mqttws31.js+ library, you must set the +userName+ and +password+ properties to the object passed to the client's +connect+ method.

If the MQTT broker requires authentication and the client passes invalid user credentials, the client will be notified by having its +onFailure+ handler called with a failure's code set to +4+ (the value specified in the MQTT protocol for the error +Connection Refused: bad user name or password+).

[source,js]
----
var userName = "...";
var password = "...";

client.connect({onSuccess: function(frame) {
    ...
  },
  onFailure: function(failure) {
   if (failure.code === 4) {
      alert("invalid user credentials");
      return;
   }
    ...
  },
  userName: userName;
  password: password;
});
----

=== Error Handling

The MQTT protocol does not specify any error handling. A MQTT broker has no possible way to inform a client that an error occured. The only action that the MQTT broker can take is to close the underlying network connection so that the client is no longer connected to the broker.

MQTT libraries provides callback or handlers for these cases so that they can act when such an error occurs.

==== +MQTTKit+ Example

The +MQTTClient+ class has a +disconnectionHandler+ property that can be set to handle any unexpected error leading to a disconnection. The disconnection can be the consequence of the MQTT broker closing the network exception (in case of abnormal errors or an administrative operation) or the network connection can be directly broken (for example if a mobile device is no longer able to receive any signal).

The +disconnectionHandler+ is a block that takes a +NSUinteger code+ parameter.
There are no standard values for the code and you will have to consult your MQTT broker documentation if you need to act differently depending on the type of errors.

We can modify the +Motions+ iOS application to handle such disconnection failures and aggressively try to reconnect the MQTT broker (assuming the root cause of the disconnection failures are transient).

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    ...

    self.client = [[MQTTClient alloc] initWithClientId:self.deviceID];

    // use a weak reference to avoid a retain/release cycle in the block
    __weak MWMViewController *weakSelf = self;
    self.client.disconnectionHandler = ^(NSUInteger code) {
        NSLog(@"client disconnected with code %lu", (unsigned long)code);
        NSLog(@"trying to reconnect...");
        // trying to reconnect;
        [weakSelf connect];
    };

    ...

    [self connect];
}
----

==== +mqttws31.js+ Example

In <<ch_mobile_mqtt_connect>>, we already set a +onConnectionLost+ callback on the +client+ to be notified in case of connection error. The callback has a single +response+ parameter object. This parameter is composed of two properties:

* +errorCode+, a numerical representation of the type of connection error
* +errorMessage+, a textual description of the error

[source,js]
----
client.onConnectionLost = function(response) {
  alert(response.errorMessage + "\nclientID = " + client.clientID + " [" + response.errorCode + "]\n");
};
----

=== Heart-beating

MQTT offers a simple mechanism to test the healthiness of the network connection betwee a client and a broker using heart-beating.

Heart-beating is enabled by specifying a _keep alive timer_ when the client initially connects to the broker. This timer, measured in seconds, defines the maximum time interval between messages received from a client. It allows the client and broker to detect whether the network connection is broken without waiting for the long TCP/IP timeout. A timer value of +0+ disables heart-beating.

In the absence of regular messages exchanged between them, the client and the broker automaticall send respective heart-beats (+PINGREQ+ for the clien and +PINGRESP+ for the broker) based on the keep alive timer to check the healthiness of the network connection.

If the client does not receive heart-beats from the broker, it will close the underlying network connection and report an error.

If the broker does not receive heart-beats from the client, it will consider that the client is disconnected.

[CAUTION]
====
Setting a good value for the keep alive timer is highly dependent on the application use cases and the platform it runs on.

For mobile devices that are subject to frequent intermittent network failures, using a value too small will report false failures and increase the instability of the application. It will also increase the bandwith and battery usage as heart-beats would have to be sent over the network more frequently.
====

==== +MQTTKit+ Example

By default, +MQTTKit+ defines a keep alive timer of 60 seconds.

It is possible to change this value using the +keepAlive+ property on the +MQTTClient+ object. The property type is a +short+ and its value must be changed prior to calling the client's +connect+ methods to take effect.

[source,objc]
----
MQTTClient *client = [[MQTTClient alloc] initWithClientId:clientID];
client.keepAlive = 10; // seconds
[client connectToHost:host
    completionHandler:^(MQTTConnectionReturnCode code) {
        //...
}];
----

==== +mqttws31.js+ Example

+mqttws31.js+ also defines a keep aliver timer of 60 seconds by default.

The +client+'s +connect+ method can take an optional +keepAliveInterval+ integer to specify another value (or +0+ to disable heart-beating).

[source,js]
----
client.connect({onSuccess: function(frame) {
    ...
  },
  onFailure: function(failure) {
    ...
  },
  keepAliveInterval: 10 // seconds
});
----

=== Last Will

One strength of messaging protocols is that producers and consumers are loosely coupled. They do not have to be online at the same time to exchange messages. The producer can send a message to a destination and be terminated. The messaging broker will then deliver the message to a consumer when it subscribes to this destination.

However there are cases where an application may require more information on the liveness of messaging clients.

Let's take the example of the +Motions+ application that broadcasts the device position when it moves. A consumer of the device position topic will consume these messages.
However, how could the consumer distinguish between receiving the messages because the device does not move or because the device is offline and has stopped broadcasting its position?

If the device is offline, the consumer may want to be notified to discard the device position from the map or show it differently from other _live_ devices.

MQTT provides a _last will_ feature that we could use to handle this use case.

When a MQTT client connects to the broker, it can specify a last will message that will be published to a last will topic by the broker _on behalf_ of the client in case of unexpected disconnection. If the client disconnects normally, its last will message is not published.
If the client uses heart-beating and the broker fails to receive its heart-beat in a timely fashion, this is considered as an unexpected disconnection and the last will message will be published.

We could use this last will to let consumers know that the +Motions+ iOS application has been terminated abnormally or its device is no longer reachable (in case of network disconnection).

==== +MQTTKit+ Example

The +STOMPClient+ object has +setWill:toTopic:withQos:retain+ and +setWillData:toTopic:withQos:retain+ methods to specify the client's last will. The differences between the two methods is that the first one takes a +NSString+ for the will message payload and the second takes a +NSData+. These methods must be called before the client connects to the MQTT broker to take effect.

We could improve the +Motions+ iOS application by specifying a last will to its +client+ object in +MWMViewController.m+ before it connects.

The last will topic can be any MQTT topic. We will use the +/mwm/lastWill+ topic so that a consumer would have to subscribe to this topic to be notified of any device's abnormal disconnection.
The payload of the last will message is a simple JSON object with a +deviceID+ property.
We will encapsulate the setup of the last will in a +setWill+ method.

[source,objc]
----
- (void)setLastWill
{
    NSString *willTopic = @"/mwm/lastWill";
    NSDictionary *dict = @{ @"deviceID": self.deviceID};
    NSData *willData = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];

    [self.client setWillData:willData
                 toTopic:willTopic
                 withQos:ExactlyOnce
                  retain:NO];
}
----

We just need to call this method before connecting to the MQTT broker in +connect+.

[source,objc]
----
- (void)connect
{
    [self setLastWill];
    NSLog(@"Connecting to %@...", kMqttHost);
    [self.client connectToHost:kMqttHost
             completionHandler:^(MQTTConnectionReturnCode code) {
        ...
    }];
}
----

Similarly to regular message, the last will message can specify its QoS and whether it must be retained. Last Will message may be important but infrequent. Using a QoS of exactly-once will ensure that a consumer of the last will topic will not receive false positives on the device's disconnection.
We will also not retain the last will message. If it would be retained, a newly subscribed consumer would receive it and could assume that a device has been disconnecting while it reconnected in the mean time.

Before we configure the web application's own last will, we can first update it to discard data when it receives the last will message from a device.

To achieve this, we need to:

. subscribe to the last will topic +/mwm/lastWill+
. update the subscription callback to handle last will messages

The first step is done in the +onSuccess+ callback passed to +client+'s +connect+ method when we were already subscribing to the devices' motion topics.

[source,js]
----
var lastWillTopic = "/mwm/lastWill";

client.connect({onSuccess: function(frame) {
  // once the client is successfully connected,
  // subscribe to all the motions topics
  client.subscribe("/mwm/+/motion");
  // subscribe to the last will topic too:
  client.subscribe(lastWillTopic);
},
----

The second step requires to modify the +client+'s +onMessageArrived+ callback to check whether the message is coming from the last will topic and discard the device data if that the case. Since the last will message representation is a JSON object, we must first parse it by calling +JSON.parse+ on the message's +payloadString+

[source,js]
----
client.onMessageArrived = function(message) {
  if (message.destinationName === lastWillTopic) {
    var payload = JSON.parse(message.payloadString);
    discard(payload.deviceID);
    return;
  }
  // the rest of the function is unchanged
  ...
};
----

The +discard+ function will delete the data from the +devices+ dictionary and remove the HTML elements that were created to display the device.

[source,js]
----
function discard(deviceID) {
  console.log("discard data for " + deviceID);
  delete devices[deviceID];
  $('#'+ deviceID).remove();
}
----

==== +mqttws31.js+ Example

It is also possible to set a client's last will using +mqttws31.js+.
The +client+'s +connect+ method can take an optional +willMessage+ object that represents the last will message to send if it disconnects unexpectedly.
The value is a regular MQTT message created by calling +new Messaging.Message+ constructor and specifying its +destinationName+ (the last will topic), and optionally its +qos+ and +retained+ value.

[source,js]
----
var willMessage = new Messaging.Message("Web client " + clientID + " has unexpectedly died");
willMessage.destinationName = "/mwm/lastWill/web";
willMessage.qos = 2; // exactly once
willMessage.retained = false;

// specify the last will when the client connects to the broker
client.connect({onSuccess: function(frame) {
    ...
  },
  onFailure: function(failure) {
    ...
  },
  willMessage: willMessage
});
----

Often, applications may not need to be notified of the last will of another MQTT client. However, we may still want to monitor the unexpected disconnection to be informed of the liveness of the whole system.
If all MQTT clients have configured their last will, we can have a crude monitoring application by subscribing to their last will topics.

[source,bash]
----
$ mosquitto_sub -h iot.eclipse.org -t /mwm/lastWill/# -v
...
/mwm/lastWill {"deviceID":"C0962483-7DD9-43CC-B1A0-2E7FBFC05060"}
/mwm/lastWill/web Web client 0.90778b769105b876 has unexpectedly died
----

[NOTE]
====
We have subscribed to the wildcard topic +/mwm/lastWill/#+ to receive messages from both +/mwm/lastWill+ (that is used by the +Motions+ iOS application) and any of its child including +/mwmw/lastWill/web+ (that is used by the web application).
====

=== Clean Session

When a MQTT client connects to the broker, it can specify whether the broker must store its state after it disconnects and until it reconnects. The client state that is store includes its subscriptions and any in-flight message with a QoS greater or equals to +1+. Messages with a QoS of +0+ (+At Most Once+) are not stored since they are delivered on a best effort basis.

The client uses a "Clean Session" flag for this. If the flag is set, the broker will not store any state and the connection opened by the client will be _clean_. If the flag is not set, the broker will store the client state.

A client with the "Clean Session" flag set will have to subscribe again to consume messages.

A client does not set the "Clean Session" flag will consume memory on the broker side (to store its state) and the broker may also perform administrative operations to remove such state.
Unless there is a strong incentive to use such a client, it is better practice to use a "Clean session" client and subscribes again after it reconnects.

==== +MQTTKit+ Example

By default, MQTT clients created using +MQTTKit+ have the "Clean Session" flag set (their state is not stored by the broker after they disconnect).
It is also possible to change this behaviour by using the +MQTTClient+'s +initWithClientID:cleanSession:+ initializer and passing +NO+ to its +cleanSession+ parameter.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    ...

    // do not clean the session in the broker when the client disconnects
    self.client = [[MQTTClient alloc] initWithClientID:self.deviceID
                                          cleanSession:NO];

    ...

    [self connect];
}
----

If the +Motions+ iOS application is modified this way, we can test it by connecting to the broker (so that the broker knows that it must store its state) and closing the application.

While the application is closed, we will modify the +motions.html+ Web application to send an alert message to the device alert topic with a QoS of +1+ (+At Least Once+).

[source,js]
----
function sendAlert(deviceID) {
  var message = new Messaging.Message("red");
  message.destinationName = "/mwm/" + deviceID + "/alert";
  // send the alert with a QoS of at-least-once
  message.qos = 1;
  client.send(message);
}
----

The client will not be available to receive the message so the broker must store it to deliver when the client reconnects.

If we open the +Motions+ iOS application again, the broker will then deliver the message to the client.

==== +mqttws31.js+ Example

The clients created by the +mqttws31.js+ library also connects by default with the "Clean Session" flag set. It is possible to change this behaviour by adding a +cleanSession+ property set to +false+ in the properties passed to the client's +connect+ method.

[source,js]
----
// specify that the session must not be cleaned when the client connects to the broker
client.connect({onSuccess: function(frame) {
    ...
  },
  onFailure: function(failure) {
    ...
  },
  cleanSession: false
});
----

=== Beyond MQTT?

MQTT is a simple protocol well suited for a limited set of applications that can be modeled using Publish/Subscribe. 

Its small set of features makes it simple to understand and use but it lacks some flexibility and you have to consider carefully if it meets your requirements.

One missing feature of MQTT is the lack of headers in the message representation.

MQTT defines a fixed set of headers for its command messages (used to connect to the broker, send a message, create a subscription, etc.) but there is no general notion of a header that the application or the broker could add to the messages.

This impacts the expressiveness of the messages that are delivered using MQTT. As a simple example, the absence of headers mean that there is no way to know what type of data to expect from the payload. HTTP and STOMP defines a +content-type+ header that can be queried to know the MIME type of the payload and extract it accordingly. MQTT does not allow this and the consumer must have _a priori_ knowledge of the payload type for a message before being able to read it.

The absence of headers also imply that the MQTT broker can not provide additional features not covered by the protocol in an unobtrusive way. As we saw in <<ch_beyond_stomp>>, STOMP brokers can provide additional features such as persistence, priority, expiration, etc. and the client can use them by adding headers to the messages. There is no such mechanism for MQTT in its current version. There are some ongoing discussion to add application-specific headers in a future version of the protocol but no agreement has been reached at the time of this writing.

If you plan to use MQTT in your applications, you should consider carefully whether its features match your requirements.

If you require features that are not provided by the protocol (or another messaging model than _Publish/Subscribe_), you may lose all the benefits of using this simple protocol and write brittle code that puts all the complexity in your applications instead of relying on the broker's set of features.
But if your requirements are fullfilled by MQTT features (as is the case for a lot of applications), you will be all set to use messaging in your applications.

=== Summary

MQTT is a simple protocol that provides few advanced features. However these features can be handy to solve common issues encountered by messaging applications.

In this chapter, we learn to use:

* _authentication_ to ensure that only authenticated clients can communicate with the MQTT broker
* _error handling_ to face unexpected connection issues and eventually reconnect to the broker
* _heart-beating_ to ensure that the network connection between the client and broker is healthy and kill the connection if that is not the case
* _last will_ to let the broker sent a message on behalf of the client in case of unexpected disconnection
* _clean session_ to preserve client state on the broker between connections
