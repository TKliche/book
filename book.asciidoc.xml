<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en" role="animal">
<title>Mobile and Web Messaging</title>
<bookinfo>
    <title>Mobile and Web Messaging</title>
</bookinfo>
<preface id="_preface" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>Preface</title>
<sect1 id="_conventions_used_in_this_book" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>Conventions Used in This Book</title>
<simpara>The following typographical conventions are used in this book:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis>Italic</emphasis>
</term>
<listitem>
<simpara>
Indicates new terms, URLs, email addresses, filenames, and file extensions.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>Constant width</literal>
</term>
<listitem>
<simpara>
Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>Constant width bold</literal></emphasis>
</term>
<listitem>
<simpara>
Shows commands or other text that should be typed literally by the user.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis><literal>Constant width italic</literal></emphasis>
</term>
<listitem>
<simpara>
Shows text that should be replaced with user-supplied values or by values determined by context.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<tip>
<simpara>This icon signifies a tip, suggestion, or general note.</simpara>
</tip>
<warning>
<simpara>This icon indicates a warning or caution.</simpara>
</warning>
</sect1>
<sect1 id="_using_code_examples" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>Using Code Examples</title>
<remark>PROD: Please reach out to author to find out if they will be uploading code examples to oreilly.com or their own site (e.g., GitHub). If there is no code download, delete this whole section.</remark>
<simpara>Supplemental material (code examples, exercises, etc.) is available for download at <ulink url="http://examples.oreilly.com/&lt;ISBN&gt;-files/">http://examples.oreilly.com/&lt;ISBN&gt;-files/</ulink>.</simpara>
<simpara>This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.</simpara>
<simpara>We appreciate, but do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “<emphasis>Book Title</emphasis> by Some Author (O’Reilly). Copyright 2012 Some Copyright Holder, 978-0-596-xxxx-x.”</simpara>
<simpara>If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <email>permissions@oreilly.com</email>.</simpara>
</sect1>
<sect1 id="_safari_books_online" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>Safari® Books Online</title>
<note role="safarienabled">
<simpara><ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">Safari Books Online</ulink> is an on-demand digital library that delivers expert <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/content">content</ulink> in both book and video form from the world&#8217;s leading authors in technology and business.</simpara>
</note>
<simpara>Technology professionals, software developers, web designers, and business and creative professionals use Safari Books Online as their primary resource for research, problem solving, learning, and certification training.</simpara>
<simpara>Safari Books Online offers a range of <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/subscriptions">product mixes</ulink> and pricing programs for <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/organizations-teams">organizations</ulink>, <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/government">government agencies</ulink>, and <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/individuals">individuals</ulink>. Subscribers have access to thousands of books, training videos, and prepublication manuscripts in one fully searchable database from publishers like O’Reilly Media, Prentice Hall Professional, Addison-Wesley Professional, Microsoft Press, Sams, Que, Peachpit Press, Focal Press, Cisco Press, John Wiley &amp; Sons, Syngress, Morgan Kaufmann, IBM Redbooks, Packt, Adobe Press, FT Press, Apress, Manning, New Riders, McGraw-Hill, Jones &amp; Bartlett, Course Technology, and dozens <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/publishers">more</ulink>. For more information about Safari Books Online, please visit us <ulink role="orm:hideurl" url="http://www.safaribooksonline.com/">online</ulink>.</simpara>
</sect1>
<sect1 id="_how_to_contact_us" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>How to Contact Us</title>
<simpara>Please address comments and questions concerning this book to the publisher:</simpara>
<simplelist>
<member>O’Reilly Media, Inc.</member>
<member>1005 Gravenstein Highway North</member>
<member>Sebastopol, CA 95472</member>
<member>800-998-9938 (in the United States or Canada)</member>
<member>707-829-0515 (international or local)</member>
<member>707-829-0104 (fax)</member>
</simplelist>
<simpara>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <ulink url="http://www.oreilly.com/catalog/&lt;catalog page&gt;">http://www.oreilly.com/catalog/&lt;catalog page&gt;</ulink>.</simpara>
<remark>Don't forget to update the link above.</remark>
<simpara>To comment or ask technical questions about this book, send email to <email>bookquestions@oreilly.com</email>.</simpara>
<simpara>For more information about our books, courses, conferences, and news, see our website at <ulink url="http://www.oreilly.com">http://www.oreilly.com</ulink>.</simpara>
<simpara>Find us on Facebook: <ulink url="http://facebook.com/oreilly">http://facebook.com/oreilly</ulink></simpara>
<simpara>Follow us on Twitter: <ulink url="http://twitter.com/oreillymedia">http://twitter.com/oreillymedia</ulink></simpara>
<simpara>Watch us on YouTube: <ulink url="http://www.youtube.com/oreillymedia">http://www.youtube.com/oreillymedia</ulink></simpara>
</sect1>
<sect1 id="_acknowledgments" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Preface.asciidoc">
<title>Acknowledgments</title>
<remark>Fill in...</remark>
</sect1>
</preface>
<chapter id="ch_prelude" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter000-Prelude.asciidoc">
<title>Prelude</title>
<simpara>TODO</simpara>
</chapter>
<chapter id="ch_messaging_concepts" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter010-Messaging-Concepts.asciidoc">
<title>Messaging Concepts</title>
<simpara role="lead">In this chapter, we describe what a messaging protocol means, how it compares to
request/reply protocols such as HTTP.</simpara>
<sect1 id="_the_advantages_of_messaging" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter010-Messaging-Concepts.asciidoc">
<title>The Advantages of Messaging</title>
<simpara>TODO</simpara>
</sect1>
<sect1 id="_messaging_models" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter010-Messaging-Concepts.asciidoc">
<title>Messaging Models</title>
<simpara>Messaging protocols provides differents <emphasis role="strong">models</emphasis> (or domains) of interaction between participants.
The models define which can receive a message sent to a given destination.</simpara>
<sect2 id="_destination">
<title>Destination</title>
<simpara>The destination is the core concept of messaging. It is the main entity clients interact with.
Depending on the messaging models, the destination can be a queue or a topic (or something else if the protocol allows to defined specific models).</simpara>
<simpara>A messaging client can have two different roles. If is is <emphasis>sending</emphasis> a message to a destion, it is a <emphasis role="strong">producer</emphasis>.
If it is receiving messages from the destination, it is a <emphasis role="strong">consumer</emphasis>.
Producers and consumers are not aware of each other and don&#8217;t need to be connected at the same time to exchange messages.
In most messaging protocols, it&#8217;s not even possible for the producer to know which consumer received its messsage, and conversely,
a consumer does not know which producer sent its message.
They only need to agree on the destinations they use and the message they will respectively send and receive.</simpara>
</sect2>
<sect2 id="_publish_subscribe">
<title>Publish/Subscribe</title>
<simpara>For each message sent to the destination, every client interested by the destination will receive it: <emphasis>One to Many</emphasis>.</simpara>
<sect3 id="_topics">
<title>Topics</title>
<simpara>When the model is publish/subscribe, the destination is called a <emphasis role="strong">topic</emphasis>.</simpara>
</sect3>
<sect3 id="_topics_hierarchy">
<title>Topics Hierarchy</title>
<simpara>Topic often allows to build a <emphasis role="strong">hierarchy</emphasis> of topics.</simpara>
<simpara>A consumer can subscribe to any node in the topic hierarchy and decide if it is also interested by the descendants of the node</simpara>
</sect3>
</sect2>
<sect2 id="_point_to_point">
<title>Point-to-Point</title>
<simpara>For each message sent to the destination, only one consumer will receive it: <emphasis>One to One</emphasis>.</simpara>
<sect3 id="_queues">
<title>Queues</title>
<simpara>When the model is point-to-point, the destination is called a <emphasis role="strong">queue</emphasis>.</simpara>
</sect3>
</sect2>
<sect2 id="_message">
<title>Message</title>
<simpara>A Message is the information that is sent by a producer to the destination and received by a consumer from the destination.
It is the only shared piece of data between the producer and the consumer.</simpara>
<simpara>A message is composed of three different parts:</simpara>
<itemizedlist>
<listitem>
<simpara>
destination
</simpara>
</listitem>
<listitem>
<simpara>
headers
</simpara>
</listitem>
<listitem>
<simpara>
payload
</simpara>
</listitem>
</itemizedlist>
</sect2>
<sect2 id="_destination_2">
<title>Destination</title>
<simpara>A message defines which destination is helding it.
It is set when the destination takes it from the producer.
This allows a consumer to receive messages from multiple destinations and know for each message the destination is coming from.</simpara>
</sect2>
<sect2 id="_headers">
<title>Headers</title>
<simpara>Protoco headers
User headers</simpara>
</sect2>
<sect2 id="_payload">
<title>Payload</title>
<simpara>Opaque content</simpara>
</sect2>
</sect1>
<sect1 id="_messages_vs_notifications" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter010-Messaging-Concepts.asciidoc">
<title>Messages Vs. Notifications</title>
<simpara>TODO</simpara>
</sect1>
<sect1 id="_messaging_vs_request_reply" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter010-Messaging-Concepts.asciidoc">
<title>Messaging Vs. Request/Reply</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="ch_example_app" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter020-Example-Application.asciidoc">
<title>Example Application</title>
<simpara role="lead">In this chapter, we present the application that will be built all along the book, the <emphasis>Truck Tracker</emphasis>.
To illustrate the use of messaging protocols on mobile and Web platforms, we will build an application with 2 parts: one will
run in mobile devices, the other inside a Web browser and they will communicate using messages.</simpara>
<simpara>Let&#8217;s take the example of a delivery company like UPS that manages a fleet of trucks.
Each truck is responsible for the delivery of packages.
They receive orders from their headquarter to:</simpara>
<itemizedlist>
<listitem>
<simpara>
fetch packages at the company&#8217;s warehouses
</simpara>
</listitem>
<listitem>
<simpara>
deliver packages to the customer&#8217;s addresses
</simpara>
</listitem>
</itemizedlist>
<simpara>To manage efficiently all the trucks, the company head quarters want to monitor the truck&#8217;s positions and be able to send them orders on-the-go.</simpara>
<simpara>Each truck will use a mobile application, the <emphasis>Truck App</emphasis>, to broadcast its geolocation data (using the GPS sensor of the mobile device runnig the application).
This application will also let them receive orders from the headquarter.</simpara>
<simpara>The company&#8217;s headquarter will use a Web application, the <emphasis>Control Center</emphasis>, that displays the position of all the trucks on a map.
This Web application will also be used to send orders to a given truck.
There will be many <emphasis>Control Center</emphasis> applications running at the same time: one for each administrator managing the fleets.</simpara>
<simpara>This application will be composed all along the book after each chapter that introduces the required information to write the application.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
In <xref linkend="ch_stomp_example"/>, we will write the <emphasis>Truck App</emphasis> as an iOS application using the STOMP protocol to send GPS data and receive orders from an iOS device.
</simpara>
</listitem>
<listitem>
<simpara>
In <xref linkend="ch_stomp_ws_example"/>, we will write the Web <emphasis>Control Center</emphasis> using STOMP protocol over Web Sockets to receive GPS data
in a Web browser and send orders to the trucks.
</simpara>
</listitem>
</orderedlist>
<figure id="img_example_app_1"><title>The <literal>Truck Tracker</literal> application with two trucks, <literal>AAA</literal> and <literal>BBB</literal> and one <literal>Control Center</literal>.</title>
<mediaobject>
  <imageobject role="web">
  <imagedata fileref="images/mobilewebmsg_app_diagram_1.png"/>
  </imageobject>
<textobject><phrase>Diagram of the Truck Tracker application</phrase></textobject>
</mediaobject>
</figure>
<simpara>Before introducing the messaging protocols that will be used by the application, we can already define
the application&#8217;s messaging topology and how the different parts of the application will exchange messages.</simpara>
<sect1 id="ch_example_app_topology" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter020-Example-Application.asciidoc">
<title>Messaging Topology</title>
<simpara>Each truck will be associated to 2 destinations:</simpara>
<itemizedlist>
<listitem>
<simpara>
a topic to broadcast its GPS data: <literal>truck.XXX.data</literal> where <literal>XXX</literal> is the truck identifier
</simpara>
</listitem>
<listitem>
<simpara>
a queue to receive orders (where to go, which package to pick, etc.): <literal>truck.XXX.orders</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>A topic is used to send the GPS data as this allows potentially many consumers to receive the information.</simpara>
<simpara>However a queue is used to handle the truck&#8217;s orders as only one single truck will consume messages from this destination.
It does not make sense for any other consumers to receive it.</simpara>
<simpara>Each <literal>Truck App</literal> will be:</simpara>
<itemizedlist>
<listitem>
<simpara>
a <emphasis>producer</emphasis> of messages to the topic <literal>truck.XXX.data</literal>
</simpara>
</listitem>
<listitem>
<simpara>
a <emphasis>consumer</emphasis> of messages from the queue <literal>truck.XXX.orders</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>Conversely, the <literal>Control Center</literal> Web application will be:</simpara>
<itemizedlist>
<listitem>
<simpara>
a <emphasis>consumer</emphasis> of messages from all the topics <literal>truck.XXX.data</literal>
</simpara>
</listitem>
<listitem>
<simpara>
a <emphasis>producer</emphasis> of message from the queues <literal>truck.XXX.orders</literal>
</simpara>
</listitem>
</itemizedlist>
</sect1>
<sect1 id="_message_representation" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter020-Example-Application.asciidoc">
<title>Message Representation</title>
<simpara>There will be two types of exchanged messages:</simpara>
<itemizedlist>
<listitem>
<simpara>
one to represent GPS data (sent to the topics <literal>truck.XXX.data</literal>)
</simpara>
</listitem>
<listitem>
<simpara>
one to represent orders (sent to the queues <literal>truck.XXX.orders</literal>)
</simpara>
</listitem>
</itemizedlist>
<sect2 id="_geolocation_messages">
<title>Geolocation messages</title>
<simpara>The Truck app will send the GPS data using a JSON representation:</simpara>
<example id="ex_example_gps_data">
<title>Geolocation data representation</title>
<screen>{
  "truck": "BBB",<co id="CO1-1"/>
  "lat": 48.8581,<co id="CO1-2"/>
  "lng": 2.2946,<co id="CO1-3"/>
  "ts": "2013-09-23T08:43Z"<co id="CO1-4"/>
}</screen>
<calloutlist>
<callout arearefs="CO1-1">
<para>
<literal>truck</literal> is the identifier of the truck that sends its position
</para>
</callout>
<callout arearefs="CO1-2">
<para>
<literal>lat</literal> is a number representing the position&#8217;s <emphasis>latitude</emphasis>
</para>
</callout>
<callout arearefs="CO1-3">
<para>
<literal>lng</literal> is a number representing the position&#8217;s <emphasis>longitude</emphasis>
</para>
</callout>
<callout arearefs="CO1-4">
<para>
<literal>ts</literal> is a string representing the time when the position was taken (using the <ulink url="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</ulink> format)
</para>
</callout>
</calloutlist>
</example>
</sect2>
<sect2 id="_order_messages">
<title>Order messages</title>
<simpara>The order messages will be also be represented using JSON with a single <literal>order</literal> attribute:</simpara>
<example id="ex_example_order">
<title>Order data representation</title>
<screen>{
  "order": "Go to warehouse #1"<co id="CO2-1"/>
}</screen>
</example>
<simpara>A more realistic representation of this message would also contain the position of the destination address but this
format is enough to provide a first version.</simpara>
<simpara>With the messaging topology and data representation known, we can already refine the application diagram.</simpara>
<figure id="img_example_app_1"><title>The <literal>Truck Tracker</literal> application&#8217;s data workflow.</title>
<mediaobject>
  <imageobject role="web">
  <imagedata fileref="images/mobilewebmsg_app_diagram_2.png"/>
  </imageobject>
<textobject><phrase>Diagram of the Truck Tracker application data worflow</phrase></textobject>
</mediaobject>
</figure>
</sect2>
</sect1>
</chapter>
<chapter id="_mobile_messaging" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter030-Mobile-Messaging.asciidoc">
<title>Mobile Messaging</title>
<simpara role="lead">In this chapter, we present some challenges offered by mobile devices and their
specific constraints. We highlight how messaging protocols can alleviate these
constraints and are well suited for mobile applications.</simpara>
</chapter>
<chapter id="ch_stomp" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>STOMP</title>
<simpara role="lead">In this chapter, we present the STOMP protocol, a simple text-based messaging
protocol that is well suited to build lightweight messaging applications on any platforms.</simpara>
<simpara>STOMP provides an interoperable wire format so that clients can communicate with any message broker.
The simplicity of the protocol ensures that it&#8217;s straightforward to have interoperability between any client and brokers.</simpara>
<simpara>This chapter covers the latest released version of the protocol:
<ulink url="http://stomp.github.io/stomp-specification-1.2.html">STOMP 1.2</ulink></simpara>
<note>
<simpara>TODO: add section about STOMP development model (no organization/company, OSS&#8230;)</simpara>
</note>
<sect1 id="_anatomy_of_a_stomp_frame" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Anatomy of a STOMP Frame</title>
<simpara>STOMP is modelled on HTTP and based on <emphasis>frames</emphasis>.
Each frame is composed of 3 elements:</simpara>
<itemizedlist>
<listitem>
<simpara>
a <emphasis>command</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
an (optional) set of <emphasis>headers</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
an (optional) <emphasis>payload</emphasis>
</simpara>
</listitem>
</itemizedlist>
<example id="ex_stomp_frame">
<title>STOMP Frame Structure</title>
<screen>COMMAND<co id="CO2-2"/>
header1:value1<co id="CO2-3"/>
header2:value2
<co id="CO2-4"/>
payload^@<co id="CO2-5"/></screen>
<calloutlist>
<callout arearefs="CO2-1 CO2-2">
<para>
A frame starts with a command string followed by an end-of-line (EOL)
</para>
</callout>
<callout arearefs="CO2-3">
<para>
Header entries followed the format <literal>&lt;key&gt;:&lt;value&gt;</literal> and is ended by EOL
</para>
</callout>
<callout arearefs="CO2-4">
<para>
A blank line separates the set of headers from the payload
</para>
</callout>
<callout arearefs="CO2-5">
<para>
A frame is ended by a NULL octet (represented by <literal>^@</literal> in ASCII)
</para>
</callout>
</calloutlist>
</example>
<simpara>STOMP is based on text (using UTF-8 for its default encoding)
but it can also transmit binary data in its payload by specifying an alternative encoding.</simpara>
<simpara>A STOMP client can serve two messaging roles:</simpara>
<note>
<simpara>TODO: cross-reference with the messaging concepts of producer and consumer</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>
It can be a <emphasis>producer</emphasis> and send messages with <literal>SEND</literal> frames
(i.e. frames with the <literal>SEND</literal> command)
</simpara>
</listitem>
<listitem>
<simpara>
It can be a <emphasis>consumer</emphasis> and subscribe to receive messages using a <literal>SUBSCRIBE</literal> frame. Each received messages will be delivered by the broker to the client as <literal>MESSAGE</literal> frames.
</simpara>
</listitem>
</orderedlist>
<simpara>Messages are <emphasis role="strong">pushed</emphasis> to STOMP clients. The protocol does not offer any command to pull messages from the broker.</simpara>
<sect2 id="_command">
<title>Command</title>
<simpara>A STOMP frame starts with a command string terminated by an end-of-line (EOL).</simpara>
<simpara><literal>SEND</literal>, <literal>SUBSCRIBE</literal>, <literal>MESSAGE</literal>, along with <literal>CONNECT</literal> (resp. <literal>DISCONNECT</literal>) used to connect (resp. disconnect) to the broker, are the principal commands.</simpara>
<simpara>Other commands correspond to additional features (message acknowledgement, transaction, receiption and error handling).</simpara>
<simpara>This chapter describes all the commands supported by STOMP 1.2.</simpara>
</sect2>
<sect2 id="_headers_2">
<title>Headers</title>
<simpara>Following the command string, a STOMP frame accepts an optional set of headers.
A header follows the format <literal>&lt;key&gt;:&lt;value&gt;</literal> and is terminated by an EOL.</simpara>
<simpara>The end of the headers is indicated by an empty blank line.</simpara>
<simpara>Some headers are defined in the specification and are mandatory for a given frame.
For example, a <literal>SEND</literal> frame must have a <literal>destination</literal> header to indicate the destination of the messages.</simpara>
<simpara>Other headers are optional.
For example, a <literal>SEND</literal> frame can be sent inside a transaction by addin a <literal>transaction</literal> header.</simpara>
</sect2>
<sect2 id="_payload_2">
<title>Payload</title>
<simpara>After the headers, a STOMP frame may contain a payload.</simpara>
<simpara>Only <literal>SEND</literal>, <literal>MESSAGE</literal> and <literal>ERROR</literal> frames can contain payload.</simpara>
<simpara>The payload in <literal>SEND</literal> and <literal>MESSAGE</literal> are the user data that are exchanged between the client and the broker.</simpara>
<simpara>A messaging broker may send <literal>ERROR</literal> frames to the client if something went wrong.
The <literal>ERROR</literal> frame may contain a payload with detailed information about the problem (in addition to a short description in a <literal>message</literal> header).</simpara>
<simpara>Finally, a STOMP frame is always terminated by a NULL octet (<literal>^@</literal>).</simpara>
<sect3 id="_payload_content">
<title>Payload content</title>
<simpara>If a frame contains a payload, it should have a <literal>content-length</literal> header corresponding to the size of the payload (its number of octets).</simpara>
<simpara>It is also advised to set a <literal>content-type</literal> with the MIME type of the payload. Otherwise, it is considered as a binary blob.</simpara>
<simpara>For example, we want to send a message with a JSON string:</simpara>
<screen>{"name":"foo","value":"bar"}{</screen>
<simpara>The corresponding <literal>SEND</literal> frame should have both the <literal>content-length</literal> and <literal>content-type</literal> headers set:</simpara>
<example id="ex_stomp_payload">
<title>Payload with a JSON string</title>
<screen>SEND
destination:/queue/myqueue<co id="CO3-1"/>
content-length:28<co id="CO3-2"/>
content-type:application/json<co id="CO3-3"/>

{"name":"foo","value":"bar"}^@<co id="CO3-4"/></screen>
<calloutlist>
<callout arearefs="CO3-1">
<para>
A <literal>SEND</literal> frame must contain a <literal>destination</literal> header.
</para>
</callout>
<callout arearefs="CO3-2">
<para>
The length of the JSON string is 28 octets.
</para>
</callout>
<callout arearefs="CO3-3">
<para>
The MIME type for JSON is <literal>application/json</literal>.
</para>
</callout>
<callout arearefs="CO3-4">
<para>
The frame must be ended by a NULL octet (represented by <literal>^@</literal> in ASCII) even when the <literal>content-length</literal> header is set.
</para>
</callout>
</calloutlist>
</example>
</sect3>
</sect2>
</sect1>
<sect1 id="_connection" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Connection</title>
<note>
<title>Install and configure a messaging broker</title>
<simpara>Before using a STOMP client, a messaging broker must be installed and
configured to be able to exchange messages.</simpara>
<simpara>In the book, we use Apache ActiveMQ as the messaging broker. The <xref linkend="appendix_activemq"/>
 shows how to install and configure ActiveMQ.</simpara>
<simpara>This chapter expects that ActiveMQ is configured with STOMP (as explained in <xref linkend="app_activemq_stomp"/>) and the security is enabled
(as explained in <xref linkend="app_activemq_security"/>).</simpara>
<simpara>Once ActiveMQ is started, it accepts STOMP connections on <literal>localhost:61613</literal>.</simpara>
</note>
<simpara>Since STOMP is text-based, we can send and receive message from the command
line using a <literal>telnet</literal> client.</simpara>
<example id="ex_stomp_telnet">
<title>Connection with a telnet client</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</screen>
</example>
<simpara>The telnet client is now connected to the broker using a TCP connection.
It must also establish a STOMP connection by sending a <literal>CONNECT</literal> frame:</simpara>
<example id="ex_stomp_connect">
<title>Connect to a STOMP broker</title>
<screen>
<userinput>CONNECT
accept-version:1.2<co xml:id="co.ex_stomp_connect_1"/>
login:user<co xml:id="co.ex_stomp_connect_2"/>
passcode:password<co xml:id="co.ex_stomp_connect_3"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connect_1">
    <para>The <literal>accept-version</literal> indicates the client wants to communicate
with the broker using the version 1.2 of the protocol.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connect_2 co.ex_stomp_connect_3">
    <para>The client authenticates by passing the username and password with the <literal>login</literal>
and <literal>passcode</literal> headers.</para>
  </callout>
</calloutlist>
</example>
<caution>
<simpara>A STOMP frame must be ended by a NULL octet.</simpara>
<simpara>The <literal>^@</literal> is the ASCII character for NULL octet. Type <literal>ctrl + @</literal> to enter it.</simpara>
</caution>
<simpara>Note also that there is a blank line between the <literal>accept-version</literal> header and the NULL octet.
The blank line is mandatory to determine the end of the headers and the beginning
of the optional payload (that is not present in the <literal>CONNECT</literal> frame).</simpara>
<simpara>Once you type <literal>ctrl + @</literal>, the messaging broker will process the <literal>CONNECT</literal> frame
and reply with a <literal>CONNECTED</literal> frame:</simpara>
<example id="ex_stomp_connected">
<title>Receive a connection confirmation</title>
<screen>
CONNECTED<co xml:id="co.ex_stomp_connected_1"/>
heart-beat:0,0<co xml:id="co.ex_stomp_connected_2"/>
session:ID:retsina.local-64904-1378366884467-2:1<co xml:id="co.ex_stomp_connected_3"/>
server:ActiveMQ/5.8.0<co xml:id="co.ex_stomp_connected_4"/>
version:1.2<co xml:id="co.ex_stomp_connected_5"/>
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_connected_1">
    <para>The <literal>CONNECTED</literal> frame means the connection was successful.
 If there were any problem during the connection, an <literal>ERROR</literal> frame would have been returned.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_2">
    <para>The <literal>heart-beat</literal> header is explained below in <xref linkend="ch_stomp_heartbeat"/>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_3">
    <para>The <literal>session</literal> header uniquely identifies the session between the client and the broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_4">
    <para>The <literal>server</literal> header contains information about the STOMP broker. In that example, we are connected to Apache ActiveMQ 5.8.0.</para>
  </callout>
  <callout arearefs="co.ex_stomp_connected_5">
    <para>The <literal>version</literal> header is the version of the STOMP protocol that will be used during the session.</para>
  </callout>
</calloutlist>
</example>
<simpara>The STOMP connection is now established and the telnet client can now exchange messages with the broker.</simpara>
<simpara>If the authentication credentials provided by the client are not correct, the broker will return an <literal>ERROR</literal> frame instead of the
<literal>CONNECTED</literal> frame (as described in <xref linkend="ch_stomp_error"/>).</simpara>
</sect1>
<sect1 id="ch_stomp_send_message" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Send a Message</title>
<simpara>Now that the telnet client is connected to the messaging broker, it can send a message to a <emphasis>destination</emphasis> on the broker.</simpara>
<simpara><emphasis>Destinations</emphasis> are opaque strings specific to each messaging broker implementation.</simpara>
<simpara>STOMP itself has no notion of delivery semantics (whether a destination is a queue, a topic or another exchange type) and you have to consult the messaging broker documentation to check how to name the destination for STOMP.</simpara>
<note>
<simpara>ActiveMQ convention is to prefix the destination by <literal>/queue/</literal> to send to a queue.
To send to a topic, we would prefix the destination by <literal>/topic/</literal> instead.</simpara>
<simpara>ActiveMQ will automatically create a destination based on the <literal>destination</literal> header so we do not have to create it beforehands.
Other brokers may behave differently and require to create the destination before sending any messages to it.</simpara>
</note>
<example id="ex_stomp_send">
<title>Send a message</title>
<screen>
<userinput>SEND
destination:/queue/myqueue<co xml:id="co.ex_stomp_send_1"/>
content-type:text/plain
content-length:13

Hello, STOMP!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_1">
    <para>The message must be sent to the <literal>/queue/myqueue</literal> destination.</para>
  </callout>
</calloutlist>
</example>
<note>
<simpara>TODO: cross-reference to the queue concept (one-to-one)</simpara>
</note>
<simpara>By following ActiveMQ convention, the message was sent to a queue. This message can only be received by a single consumer.</simpara>
<simpara>The <literal>destination</literal> header indicates the destination of the message.</simpara>
<simpara>It also contains payload with the text <literal>Hello, STOMP!</literal>.
The payload is immediately followed by the NULL octet (represented by <literal>^@</literal>) to end the frame.</simpara>
<simpara>Once you <literal>ctrl + @</literal> to enter the NULL octet, the message is processed by the broker.</simpara>
<sect2 id="ch_stomp_receipt">
<title>Frame Receiption</title>
<simpara>The STOMP broker can sent some feedback to let the client know that a frame has been received. This is a general mechanism available on any frame sent by a client to a broker (and not only on the <literal>SEND</literal> frame).</simpara>
<simpara>To receive a confirmation that a message is handled by the STOMP broker, a frame sent by the client must indicate a <literal>receipt</literal> header.</simpara>
<example id="ex_stomp_send_with_receipt">
<title>Send a message with a receipt</title>
<screen>
<userinput>SEND
destination:/queue/myqueue
receipt:123<co xml:id="co.ex_stomp_send_with_receipt_1"/>
content-type:text/plain
content-length:28

Hello, STOMP with a receipt!</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_send_with_receipt_1">
    <para>The <literal>receipt</literal> header will serve to identify the receipt sent by the broker
when it will have successfully handled this frame.</para>
  </callout>
</calloutlist>
</example>
<simpara>When this <literal>SEND</literal> frame is received by the broker and succesfully handled, the broker replies with a <literal>RECEIPT</literal> frame containing the corresponding receipt ID in a <literal>receipt-id</literal> header:</simpara>
<example id="ex_stomp_receipt">
<title>Receive the receipt</title>
<screen>
RECEIPT
receipt-id:123<co xml:id="co.ex_stomp_receipt_1"/>

</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receipt_1">
    <para>The <literal>receipt-id</literal> header corresponds to the <literal>receipt</literal> header set on the frame successfully handled by the broker.</para>
  </callout>
</calloutlist>
</example>
<simpara>This <literal>RECEIPT</literal> lets the client know that the broker has <emphasis>received</emphasis> the message but it does not mean that the message has been processed yet (or will be processed at all).</simpara>
</sect2>
<sect2 id="ch_stomp_error">
<title>Error frame</title>
<simpara>If a message is sent with an invalid format, the messaging broker will reply immediately with an <literal>ERROR</literal> frame.</simpara>
<simpara>For example, it is not valid to send a message without a <literal>destination</literal> header (where would the message go?):</simpara>
<example id="ex_stomp_invalid_send">
<title>Send an invalid message</title>
<screen>
<userinput>SEND
<co xml:id="co.ex_stomp_invalid_send_1"/>

A SEND frame witout a destination is not allowed</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_invalid_send_1">
    <para>The <literal>destination</literal> header is missing.</para>
  </callout>
</calloutlist>
</example>
<simpara>Once the message is sent, the client receives an <literal>ERROR</literal> frame:</simpara>
<example id="ex_stomp_error">
<title>Receive an error</title>
<screen>
ERROR
content-type:text/plain<co xml:id="ex_stomp_error_1"/>
message:SEND received without a Destination specified!<co xml:id="ex_stomp_error_2"/>

org.apache.activemq.transport.stomp.ProtocolException: SEND received without a Destination specified! <co xml:id="ex_stomp_error_3"/>
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:299)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:233)
        ...
</screen>
<calloutlist>
  <callout arearefs="ex_stomp_error_1">
    <para>This <literal>ERROR</literal> frame has a <literal>content-type</literal> header that let the client know the payload is in plain text (encoded in UTF-8 by default).</para>
  </callout>
  <callout arearefs="ex_stomp_error_2">
    <para>A <literal>ERROR</literal> frame contains a <literal>message</literal> header with a short description of the problem encountered by the broker.</para>
  </callout>
  <callout arearefs="ex_stomp_error_3">
    <para>It also contains a text payload with more information on the problem.</para>
    </callout>
</calloutlist>
</example>
</sect2>
</sect1>
<sect1 id="_receive_a_message" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Receive a Message</title>
<simpara>So far, the telnet client has acted as a STOMP <emphasis>producer</emphasis> and sent messages.</simpara>
<simpara>It will now also become a STOMP <emphasis>consumer</emphasis> to receive messages.</simpara>
<simpara>To receive messages, a STOMP client must send a <literal>SUBSCRIBE</literal> frame with a <literal>destination</literal> header.</simpara>
<example id="ex_stomp_subscribe">
<title>Subscribe to a destination</title>
<screen>
<userinput>SUBSCRIBE
destination:/queue/myqueue<co xml:id="co.ex_stomp_subscribe_1"/>
id:mysub<co xml:id="co.ex_stomp_subscribe_2"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_subscribe_1">
    <para>The <literal>destination</literal> is the name of destination the client wants to consume messages from.</para>
  </callout>
  <callout arearefs="co.ex_stomp_subscribe_2">
    <para>The subscription will be identified by the <literal>mysub</literal> identifier indicated in the <literal>id</literal> header.</para>
  </callout>
</calloutlist>
</example>
<simpara>The <literal>id</literal> header corresponds to the subscription identifier and must be unique among all the subscriptions <emphasis>inside the same connection</emphasis>.
It is the responsibility of the client to choose this subscription identifier.</simpara>
<simpara>As soon as the messaging broker receives this <literal>SUBSCRIBE</literal> frame and handle it,
it starts to send to the client some <literal>MESSAGE</literal> frames corresponding to the messages sent to this destination.</simpara>
<example id="ex_stomp_receive2">
<title>Receive two messages</title>
<screen>
MESSAGE<co xml:id="co.ex_stomp_receive2_1"/>
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c1<co xml:id="co.ex_stomp_receive2_2"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_receive2_3"/>
subscription:mysub<co xml:id="co.ex_stomp_receive2_4"/>
timestamp:1378367602698<co xml:id="co.ex_stomp_receive2_5"/>
expires:0<co xml:id="co.ex_stomp_receive2_6"/>
content-length:13
priority:4<co xml:id="co.ex_stomp_receive2_7"/>

Hello, STOMP!
MESSAGE<co xml:id="co.ex_stomp_receive2_8"/>
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c1\c-1\c1\c2
destination:/queue/myqueue
timestamp:1378368275375
expires:0
subscription:mysub
content-length:28
priority:4
content-type:text/plain

Hello, STOMP with a receipt!
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_receive2_1 co.ex_stomp_receive2_8">
    <para>Each received message is contained in a <literal>MESSAGE</literal> frame.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_2">
    <para>A <literal>message-id</literal> header uniquely identifies the message.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_3">
    <para>The <literal>destination</literal> indicates the destination this message was consumed from.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_4">
    <para>The <literal>subscription</literal> indicates which consumer's subscription is receiving the message.</para>
  </callout>
  <callout arearefs="co.ex_stomp_receive2_5 co.ex_stomp_receive2_6 co.ex_stomp_receive2_7">
    <para>A <literal>MESSAGE</literal> frame may contain additional headers (<literal>timestamp</literal>, <literal>expires</literal>,
 <literal>priority</literal> in this case) not specified by the STOMP protocol corresponding to features provided by the broker
(as described below in <xref linkend="ch_stomp_ext" />).</para>
  </callout>
</calloutlist>
</example>
<simpara>We have received the 2 messages that we have previously sent in the two examples
above (<xref linkend="ex_stomp_send"/> and <xref linkend="ex_stomp_send_with_receipt"/>). They were sent in a queue and the telnet client is the only consumer that is subscribed to this destination.</simpara>
<simpara>The telnet client is now a consumer of the <literal>/queue/myqueue</literal> destination.
If another message is sent to this destination, it will receive this message immediately:</simpara>
<example id="ex_stomp_send_receive">
<title>Send a message and receive it</title>
<screen>
<userinput>SEND
destination:/queue/myqueue
content-type:text/plain
content-length:15

another message</userinput>^@

MESSAGE
content-type:text/plain
message-id:ID\cretsina.local-64904-1378366884467-2\c3\c-1\c1\c3
destination:/queue/myqueue
timestamp:1378369910799
expires:0
subscription:mysub
content-length:15
priority:4

another message
</screen>
</example>
</sect1>
<sect1 id="_unsubscription" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Unsubscription</title>
<simpara>To stop consuming messages from a destination, the client must send a <literal>UNSUBSCRIBE</literal> frame
with a <literal>id</literal> header corresponding to the subscription identifier indicated in the <literal>SUBSCRIBE</literal> frame (<literal>mysub</literal> in the example above).</simpara>
<example id="ex_stomp_unsubscribe">
<title>Unsubscribe a consumer</title>
<screen>
<userinput>UNSUBSCRIBE
id:mysub<co xml:id="co.ex_stomp_unsubscribe_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_unsubscribe_1">
    <para>The <literal>id</literal> is the subscription identifier set in the corresponding <literal>SUBSCRIBE</literal> frame.</para>
  </callout>
</calloutlist>
</example>
<simpara>The telnet client can still act as a producer and send messages but it will no longer receive any sent to the <literal>/queue/myqueue</literal> destination.</simpara>
</sect1>
<sect1 id="_disconnection" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Disconnection</title>
<simpara>To disconnect from the messaging broker, the client must send a <literal>DISCONNECT</literal> frame.</simpara>
<simpara>To ensure a graceful disconnection, the best practice is to send a <literal>DISCONNECT</literal> frame
with a <literal>receipt</literal> header and wait to receive the corresponding <literal>RECEIPT</literal> frame.
The client can then safely close the TCP connection to the  broker (if the broker does not close it from its side first).</simpara>
<example id="ex_stomp_disconnect">
<title>Grafecul disconnection</title>
<screen>
<userinput>DISCONNECT
receipt:456<co xml:id="co.ex_stomp_disconnect_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_disconnect_1">
    <para>The <literal>receipt</literal> value will be used to correlate this frame with the corresponding <literal>RECEIPT</literal> frame.</para>
  </callout>
</calloutlist>
</example>
<simpara>When the <literal>DISCONNECT</literal> frame is sent, the client receives the corresponding <literal>RECEIPT</literal> frame.</simpara>
<example id="ex_stomp_disconnect_receipt">
<title>Receive a receipt for the graceful disconnection</title>
<screen>
RECEIPT
receipt-id:456<co xml:id="co.ex_stomp_disconnect_receipt_1"/>
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_disconnect_1">
    <para>The <literal>receipt-id</literal> value is the same that the <literal>DISCONNECT</literal>'s <literal>receipt</literal> value.</para>
  </callout>
</calloutlist>
</example>
<simpara>The messaging broker then closes the underlying TCP connection and the telnet client is closed:</simpara>
<screen>
Connection closed by foreign host.
</screen>
</sect1>
<sect1 id="ch_stomp_heartbeat" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Heart-beat</title>
<simpara>STOMP offers a mechanism to test the healthiness of a connection between a STOMP client and a broker</simpara>
<note>
<simpara>TODO: better explanation on the necessity of heart-beating to circumvent TCP.</simpara>
</note>
<simpara>Heart-beat is negotiated between the client and the broker during the exchange of the <literal>CONNECT</literal> and <literal>CONNECTED</literal> frames.</simpara>
<simpara>When we connected previous in <xref linkend="ex_stomp_connect"/>, we received a <literal>CONNECTED</literal> (in <xref linkend="ex_stomp_connected"/> ) with a header <literal>heart-beat:0,0</literal>.</simpara>
<simpara>The <literal>heart-beat</literal> header&#8217;s value is composed of 2 positive integers:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
The smallest number of milliseconds between heart-beats that the sender of the frame guarantees (or <literal>0</literal> if it will not send heart-beats).
</simpara>
</listitem>
<listitem>
<simpara>
The desired number of milliseconds between heart-beats that the sender of the frame expects to receive from the other party (or <literal>0</literal> if it does not want to receive heart-beats).
</simpara>
</listitem>
</orderedlist>
<simpara>The sender of <literal>CONNECT</literal> frame is a STOMP <emphasis>client</emphasis>, the sender of a <literal>CONNECTED</literal> frame is a STOMP <emphasis>broker</emphasis>.</simpara>
<simpara>A <literal>CONNECTED</literal> frame with a <literal>heart-beat:0,0</literal> header indicates that:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
The broker will <emphasis role="strong">not</emphasis> send heart-beats to the client
</simpara>
</listitem>
<listitem>
<simpara>
The broker does <emphasis role="strong">not</emphasis> want to receive heart-beats from the client
</simpara>
</listitem>
</orderedlist>
<simpara>Heart-beating is optional. Sending a <literal>CONNECT</literal> frame without a <literal>heart-beat</literal> header is equivalent to setting it to <literal>0,0</literal>.</simpara>
<simpara>Let&#8217;s now activate heart-beating upon connection.</simpara>
<simpara>We will open a new telnet client for this example and send a <literal>CONNECT</literal> frame with a <literal>heart-beat</literal> header:</simpara>
<example id="ex_stomp_hb_connect">
<title>Connect to a STOMP broker with heart-beat</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
heart-beat:10000,2000<co xml:id="co.ex_stomp_hb_connect_1"/>
login:user
passcode:password

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connect_1">
    <para>The client guarantees to send a heart-beat every 10 seconds (10000ms) and expect to receive heart-beats from the broker every 2 seconds (2000ms).</para>
  </callout>
</calloutlist>
</example>
<simpara>The broker replies with a <literal>CONNECTED</literal> frame but the value of the <literal>heart-beat</literal> header is different from last time:</simpara>
<example id="ex_stomp_hb_connected_with_hb">
<title>Connect to a STOMP broker with heart-beat</title>
<screen>
<userinput>CONNECTED
heart-beat:2000,10000<co xml:id="co.ex_stomp_hb_connected_with_hb_1"/>
session:ID:retsina.local-60200-1378476149103-2:2
server:ActiveMQ/5.8.0
version:1.2

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_hb_connected_with_hb_1">
    <para>The broker replied that it guarantees to send heart-beats every 2 seconds and expect to receive heart-beats from the client every 10 seconds.</para>
  </callout>
</calloutlist>
</example>
<simpara>In this case, the heart-beating negotiation is straightforward since the broker replied with the same heart-beat expectation that we send.</simpara>
<note>
<simpara>TODO: Add some description of the heart-beating negotation when values differ <ulink url="http://stomp.github.io/stomp-specification-1.2.html#Heart-beating">http://stomp.github.io/stomp-specification-1.2.html#Heart-beating</ulink></simpara>
</note>
<simpara>If we wait more that 10 seconds, the telnet client is closed:</simpara>
<informalexample>
<screen>
Connection closed by foreign host.
</screen>
</informalexample>
<simpara>Indeed the telnet client did not fulfill its promises to send heart-beats at least every 10 seconds.</simpara>
<simpara>What is a heart-beat? A heart-beat is <emphasis role="strong">any data send over the network</emphasis>.
If the client does not send any STOMP frame, it must send an end-of-line (EOL) as a heart-beat.</simpara>
<simpara>To simulate this, open a new telnet client and send the same <literal>CONNECT</literal> frame than in <xref linkend="ex_stomp_hb_connect"/> and send a EOL every 10 seconds by typing <literal>Enter</literal>.
You will also notice that a new line appears every 2 seconds. This corresponds to the EOL sent by the broker as an heart-beat.</simpara>
<simpara>This client will remain open as long as you send EOL in the imparted time. Note that if you stop sending heart-beats, it may take more that 10 seconds for the broker to closed the connection.
It is considered good practice to leave an error of margin with the heart-beats because of timing inaccuracies (some broker may wait more than twice the heart-beat time before closing the connection).</simpara>
</sect1>
<sect1 id="_message_acknowledgement" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Message acknowledgement</title>
<simpara>When a broker delivers a message to a client for consumption, the client must <emphasis>acknowledge</emphasis> the message to inform the broker that it takes responsibility for the message.
With this acknowledgement, the broker can forget everything about the message, it is now under the client&#8217;s responsibility. As long as the broker has not received such an acknowledgement, it must keep the message
to be able to eventually redeliver it.</simpara>
<formalpara><title>When does this acknowledgement takes place?</title><para>The first step happens when the client sends a <literal>SUBSCRIBE</literal> frame to the broker. The <literal>SUBSCRIBE</literal> frame takes an optional <literal>ack</literal> header that accepts three valid values:</para></formalpara>
<itemizedlist>
<listitem>
<simpara>
<literal>auto</literal> (if the <literal>SUBSCRIBE</literal> frame does not contain a <literal>ack</literal> header, it defaults to <literal>auto</literal>)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>client</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>client-individual</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>When the <literal>ack</literal> header is set to <literal>auto</literal>, the broker will consider the message <emphasis>automatically</emphasis> acknowledged as soon as it is delivered to the client. The client does not need to acknowledge
the message at all. This mode may result in message loss if the client fails <emphasis role="strong">after</emphasis> the message was delivered but <emphasis role="strong">before</emphasis> it was processed.</simpara>
<simpara>When the client requires more control on the message acknowledgement, it can use either the <literal>client</literal> or <literal>client-individual</literal> values.
In both case, the client must send an <literal>ACK</literal> frame to the broker for the message that it processes.
The <literal>client</literal> value means the message acknowledgement is <emphasis>cumulative</emphasis>, it will acknowledge the specified message <emphasis>and all the messages received before</emphasis>. With <literal>client-individual</literal>, only the specified message is acknowledged.</simpara>
<simpara>If a client does not process a message it has received, it should send a <literal>NACK</literal> frame (a negative acknowledgement) to the let the broker know that it refused to take responsibility for the specified message.
The broker can then deliver the message to another consumer.</simpara>
<simpara>The <literal>ACK</literal> and <literal>NACK</literal> frames require a <literal>id</literal> header whose value must match the value of the <literal>ack</literal> header from the <literal>MESSAGE</literal> frame to acknowledge (or nack).
The <literal>MESSAGE</literal> frame contains the <literal>ack</literal> header only when the client specified explicit acknowledgement (<literal>client</literal> or <literal>client-individual</literal>) in the <literal>SUBSCRIBE</literal> frame.</simpara>
<simpara>We will open a telnet client and subscribe to the destination with an explicit <literal>client</literal> acknowledgement:</simpara>
<example id="ex_stomp_ack_subscribe_client">
<title>Subscribe to a STOMP broker with a <literal>client</literal> acknowledgement</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT<co xml:id="co.ex_stomp_ack_subscribe_client_1"/>
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED<co xml:id="co.ex_stomp_ack_subscribe_client_2"/>
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_ack_subscribe_client_3"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_ack_subscribe_client_4"/>
id:mysub<co xml:id="co.ex_stomp_ack_subscribe_client_5"/>
ack:client<co xml:id="co.ex_stomp_ack_subscribe_client_6"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_1">
    <para>The <literal>CONNECT</literal> frame is sent to connect to the STOMP broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2">
    <para>The <literal>CONNECTED</literal> frame sent by the broker confirms that the client is successfully connected.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_3 co.ex_stomp_ack_subscribe_client_4 co.ex_stomp_ack_subscribe_client_5">
    <para>The client subscribes to the <literal>/queue/myqueue</literal> destination with the subscription identifier <literal>mysub</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_6">
    <para>The client informs the broker that messages received by this subscription will be acknowledged explicitly (and cumulatively).</para>
  </callout>
</calloutlist>
</example>
<simpara>The client will now send a message to the destination and receives it through the subscription that has just been created:</simpara>
<example id="ex_stomp_ack_send">
<title>Send a message to the destination</title>
<screen>
<userinput>SEND<co xml:id="co.ex_stomp_ack_send_1"/>
destination: /queue/myqueue
content-type:text/plain
content-length:15

another message
</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_ack_send_2"/>
content-type:text/plain
ack:ID\cretsina.local-49965-1378989016784-4\c1<co xml:id="co.ex_stomp_ack_send_3"/>
message-id:ID\cretsina.local-49965-1378989016784-2\c2\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378989622992
expires:0
subscription:mysub
content-length:15
priority:4

another message
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_send_1">
    <para>The client sends a message to the broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_send_2 co.ex_stomp_ack_send_3">
    <para>The message is processed by the broker and delivered to the client. It contains a <literal>ack</literal> header whose value is an opaque identifier.</para>
  </callout>
</calloutlist>
</example>
<simpara>At this point, the client has received the message but has not acknowledged it. The broker will keep it as a reference until the client acknowledges it explicitly.</simpara>
<simpara>To illustrate that, the client will disconnect <emphasis>without acknowledging the message</emphasis>.</simpara>
<example id="ex_stomp_ack_disconnect">
<title>Disconnection of the client without acknowledging the message</title>
<screen>
<userinput>DISCONNECT

</userinput>^@
Connection closed by foreign host.
</screen>
</example>
<simpara>The broker will notice that the delivered message was not acknowledged by the client before it disconnected and will
take again responsibility for it and be ready to deliver it to any other subscribers on the destination.</simpara>
<simpara>A new telnet client will subscribe to the destination with a different subscription identifier to receive this message:</simpara>
<example id="ex_stomp_ack_subscribe_client_2">
<title>Subscribe to a STOMP broker with a <literal>client</literal> acknowledgement</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_ack_subscribe_client_2_1"/>
destination:/queue/myqueue
id:mynewsub<co xml:id="co.ex_stomp_ack_subscribe_client_2_2"/>
ack:client<co xml:id="co.ex_stomp_ack_subscribe_client_2_3"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_ack_subscribe_client_2_4"/>
content-type:text/plain
redelivered:true<co xml:id="co.ex_stomp_ack_subscribe_client_2_5"/>
ack:ID\cretsina.local-49965-1378989016784-5\c1
message-id:ID\cretsina.local-49965-1378989016784-2\c2\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378989622992
expires:0
subscription:mysub2<co xml:id="co.ex_stomp_ack_subscribe_client_2_6"/>
content-length:15
priority:4

another message
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_1 co.ex_stomp_ack_subscribe_client_2_2">
    <para>The client subscribes again with a new <literal>mynewsub</literal> subscription identifier.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_3">
    <para>This new subscription also require explicit <literal>client</literal> acknowledgement.</para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_4">
    <para>As soon as the client is subscribed, it receives the <literal>MESSAGE</literal> sent in <xref linkend="ex_stomp_ack_message"/></para>
  </callout>
  <callout arearefs="co.ex_stomp_ack_subscribe_client_2_5 co.ex_stomp_ack_subscribe_client_2_6">
    <para>The message is delivered to the <literal>mysub2</literal> subscription and contains an additional <literal>redelivered</literal>
header set to <literal>true</literal> that informs the client that this message was delivered at least once without success and is redelivered.</para>
  </callout>
</calloutlist>
</example>
<simpara>This time, the client will properly acknowledge the message:</simpara>
<example id="ex_stomp_ack_ack">
<title>Acknowledge a message</title>
<screen>
<userinput>ACK
id:ID\cretsina.local-49965-1378989016784-5\c1<co xml:id="co.ex_stomp_ack_ack_1"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ack_ack_1">
    <para>The value of the <literal>id</literal> must match the value of the <literal>ack</literal> header
from the <literal>MESSAGE</literal> received in <xref linkend="ex_stomp_ack_subscribe_client_2"/>.</para>
  </callout>
</calloutlist>
</example>
<note>
<title>Transactional Acknowlegement</title>
<simpara>Acknowledgements using <literal>ACK</literal> or <literal>NACK</literal> frame can be part of a transaction by adding a <literal>transaction</literal> header to
these frames as explained below in <xref linkend="ch_stomp_transaction"/>.</simpara>
</note>
</sect1>
<sect1 id="ch_stomp_transaction" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>Transaction</title>
<simpara>STOMP has basic support for transactions.</simpara>
<simpara>Sending (with <literal>SEND</literal> frames) or acknowledging (with <literal>ACK</literal> or <literal>NACK</literal> frames) messages can be performed inside a transaction.
This means that the messages and acknowledgements are not processed by the broker when it receives the corresponding frames but when the transaction completes.</simpara>
<simpara>If the client does not complete the transaction, the broker will not process the frames that it received during the transaction and will discard them.</simpara>
<simpara>To illustrate this, we will open a new telnet client and subscribe to the destination.</simpara>
<example id="ex_stomp_tx_subscribe">
<title>Connect to a STOMP broker and subscribe to a destination</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT<co xml:id="co.ex_stomp_tx_subscribe_1"/>
accept-version:1.2
login:user
passcode:password

</userinput>^@
CONNECTED<co xml:id="co.ex_stomp_tx_subscribe_2"/>
heart-beat:0,0
session:ID:retsina.local-49965-1378989016784-2:2
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE<co xml:id="co.ex_stomp_tx_subscribe_3"/>
destination:/queue/myqueue<co xml:id="co.ex_stomp_tx_subscribe_4"/>
id:mysub

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_subscribe_1">
    <para>The <literal>CONNECT</literal> frame is sent to connect to the STOMP broker.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_subscribe_2">
    <para>The <literal>CONNECTED</literal> frame sent by the broker confirms that the client is successfully connected.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_subscribe_3 co.ex_stomp_tx_subscribe_4">
    <para>The client subscribes to the <literal>/queue/myqueue</literal> destination with the subscription identifier <literal>mysub</literal>.</para>
  </callout>
</calloutlist>
</example>
<simpara>A transaction is started by the client by sending a <literal>BEGIN</literal> frame to the broker. This frame must have a <literal>transaction</literal> header whose value is a transaction identifier
<emphasis>that must be unique within a STOMP connection</emphasis>.</simpara>
<simpara>Sending and acknowledging messages can then be part of this transaction by adding a <literal>transaction</literal> header to their frames with the same transaction identifier.</simpara>
<example id="ex_stomp_tx_begin_send">
<title>Begin a transaction and send a message inside it</title>
<screen>
<userinput>BEGIN<co xml:id="co.ex_stomp_tx_begin_send_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_begin_send_2"/>

</userinput>^@

<userinput>SEND<co xml:id="co.ex_stomp_tx_begin_send_3"/>
destination:/queue/myqueue
content-type:text/plain
content-length:24
transaction:mytx1<co xml:id="co.ex_stomp_tx_begin_send_4"/>

Message in a transaction</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_begin_send_1 co.ex_stomp_tx_begin_send_2">
    <para>The client begins a transaction by sending a <literal>BEGIN</literal> frame with a <literal>transaction</literal> header
set to <literal>mytx1</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_begin_send_3 co.ex_stomp_tx_begin_send_4">
    <para>The client sends a <literal>SEND</literal> frame inside the transaction by adding a <literal>transaction</literal> header
with the same value than in the <literal>BEGIN</literal> frame.</para>
  </callout>
</calloutlist>
</example>
<simpara>At this point, the <literal>MESSAGE</literal> frame has been received by the broker. However the broker has not processed it and deliver the message to the client&#8217;s subcription created in <xref linkend="ex_stomp_tx_subscribe"/>.</simpara>
<simpara>To complete this active transaction and allows the broker to process it, the client must send a <literal>COMMIT</literal> frame with the same
<literal>transaction</literal> header.</simpara>
<example id="ex_stomp_tx_commit">
<title>Commit a transaction and receives the message after the transaction is completed</title>
<screen>
<userinput>COMMIT<co xml:id="co.ex_stomp_tx_commit_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_commit_2"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_tx_commit_3"/>
content-type:text/plain
message-id:ID\cretsina.local-49965-1378989016784-2\c4\c-1\c1\c1
destination:/queue/myqueue
timestamp:1378994631546
expires:0
subscription:mysub
content-length:24
priority:4

Message in a transaction
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_commit_1 co.ex_stomp_tx_commit_2">
    <para>The client completes the transaction by sending a <literal>COMMIT</literal> frame with the same <literal>transaction</literal> header
than  in the <literal>BEGIN</literal> frame.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_commit_3">
    <para>The client finally receives the message sent inside the transaction in <xref linkend="ex_stomp_tx_begin_send"/>.</para>
  </callout>
</calloutlist>
</example>
<simpara>To roll back a transaction and discard any messages or acknowledgements sent inside it, the client can send an <literal>ABORT</literal> frame with the same <literal>transaction</literal> header than in
the corresponding <literal>BEGIN</literal> frame that started the transaction:</simpara>
<example id="ex_stomp_tx_abort">
<title>Abort a transaction</title>
<screen>
<userinput>ABORT<co xml:id="co.ex_stomp_tx_abort_1"/>
transaction:mytx1<co xml:id="co.ex_stomp_tx_abort_2"/>

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_abort_1 co.ex_stomp_tx_abort_2">
    <para>The client rolls back the transaction by sending an <literal>ABORT</literal> frame with the same <literal>transaction</literal> header
than in the <literal>BEGIN</literal> frame.</para>
  </callout>
</calloutlist>
</example>
<simpara>STOMP does not provide a transaction timeout that would abort the transaction if it is not completed in a timely fashion.
The transaction lifecycle (controlled by <literal>BEGIN</literal> and <literal>COMMIT</literal>/<literal>ABORT</literal> frames) is the responsibility of the client.
However the broker will automatically abort any active transaction if the client send a <literal>DISCONNECT</literal> frame or if the underlying TCP
connection fails.</simpara>
<sect2 id="_transaction_and_receipt">
<title>Transaction and Receipt</title>
<simpara>In <xref linkend="ch_stomp_receipt"/>, we saw that the client can receive a <literal>RECEIPT</literal> frame when the broker has received the frame and pointed out it does mean that the broker <emphasis>processed</emphasis> it.</simpara>
<simpara>We can confirm this behaviour by sending a message inside a transaction and ask for a receipt:</simpara>
<example id="ex_stomp_tx_receipt">
<title>Ask a receipt for a message sent inside a transaction</title>
<screen>
<userinput>BEGIN<co xml:id="co.ex_stomp_tx_receipt_1"/>
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_2"/>

</userinput>
^@

<userinput>
SEND<co xml:id="co.ex_stomp_tx_receipt_3"/>
destination:/queue/myqueue
content-type:text/plain
content-length:32
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_4"/>
receipt:myreceipt1<co xml:id="co.ex_stomp_tx_receipt_5"/>

Another message in a transaction</userinput>^@
RECEIPT<co xml:id="co.ex_stomp_tx_receipt_6"/>
receipt-id:myreceipt1
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_receipt_1 co.ex_stomp_tx_receipt_2">
    <para>The client begins a transaction named <literal>mytx2</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_3 co.ex_stomp_tx_receipt_4 co.ex_stomp_tx_receipt_5">
    <para>The client sends a message inside this transaction and asks for a receipt.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_6">
    <para>As soon as the broker receives the <literal>MESSAGE</literal>, it sends a <literal>RECEIPT</literal> to the client
to confirm the message has been received. However the message has not be processed yet. It will be processed only when the transaction is commited.</para>
  </callout>
</calloutlist>
</example>
<simpara>We see above that the broker confirmed that it received the <literal>MESSAGE</literal> but it has not processed it.</simpara>
<simpara>Only when the client commits the transaction, the client will process the message and deliver it to the client&#8217;s subscription:</simpara>
<example id="ex_stomp_tx_receipt_commit">
<title>The message is processed by the broker only when the transaction is committed</title>
<screen>
<userinput>COMMIT<co xml:id="co.ex_stomp_tx_receipt_commit_1"/>
transaction:mytx2<co xml:id="co.ex_stomp_tx_receipt_commit_2"/>

</userinput>^@
MESSAGE<co xml:id="co.ex_stomp_tx_receipt_commit_3"/>
content-type:text/plain
message-id:ID\cretsina.local-49965-1378989016784-2\c4\c-1\c1\c2
destination:/queue/myqueue
timestamp:1378996600008
expires:0
subscription:mysub
content-length:32
priority:4

Another message in a transaction
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_tx_receipt_commit_1 co.ex_stomp_tx_receipt_commit_2">
    <para>The client commits the transaction named <literal>mytx2</literal>.</para>
  </callout>
  <callout arearefs="co.ex_stomp_tx_receipt_commit_3">
    <para>When the transaction is commited, the broker finally process the <literal>SEND</literal> frame sent in <xref linkend="ex_stomp_tx_receipt"/> and
deliver it to the client's subscription.</para>
  </callout>
</calloutlist>
</example>
</sect2>
</sect1>
<sect1 id="ch_stomp_ext" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter040-STOMP.asciidoc">
<title>STOMP Extensions</title>
<simpara>STOMP protocol is very simple with few commands to know to be able to use it.</simpara>
<simpara>The protocol does not define advanced features that are often provided by messaging brokers such as persistency or expiration.</simpara>
<simpara>However, it is possible to use them from STOMP thanks to the additional /non-standard/ headers.</simpara>
<simpara>In the <xref linkend="ex_stomp_receive2"/>, the two messages received by the consumers were containing headers that have not been described yet:
<literal>timestamp</literal>, <literal>expires</literal> and <literal>priority</literal>.</simpara>
<simpara>The headers are added by ActiveMQ to provide additional information on the messages.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>timestamp</literal> value corresponds to the time the message was handed off to the broker (it is an interval in milliseconds since the UNIX epoch).
</simpara>
</listitem>
<listitem>
<simpara>
<literal>expires</literal> value corresponds to the message expiration time. When a message exipration time is reached and it has not been consumed, the broker discards it.
  In the example, the <literal>expires</literal> value is <literal>0</literal> which mean that the messages <emphasis>never</emphasis> expires.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>priority</literal> value is the priority level of the message (<literal>0</literal> being the lowest priority and <literal>9</literal> being the highest). The broker tries
to deliver higher priority messages ahead of lower priority ones. In the example, the value is <literal>4</literal> which corresponds to a normal priority.
</simpara>
</listitem>
</itemizedlist>
<simpara>ActiveMQ defines other headers that can be add to the <literal>SEND</literal> frame when sending a message (as described in (<ulink url="http://activemq.apache.org/stomp.html">ActiveMQ STOMP page</ulink>).</simpara>
<note>
<simpara>TODO: Cross-reference with message persistence concept.</simpara>
</note>
<simpara>One of the most important is the <literal>persistent</literal> header. By default, STOMP does not define whether messages are <emphasis>persistent</emphasis> or not.
Most STOMP brokers (including ActiveMQ) defaults to <emphasis>non-persistent</emphasis> messages. To send a persistent message to an ActiveMQ broker,
the client must add a <literal>persistent</literal> header whose value is <literal>true</literal>.</simpara>
<example id="ex_stomp_ext_persistent">
<title>Send a peristent message</title>
<screen>
<userinput>SEND
destination:/queue/myqueue
content-type:text/plain
content-length:26
persistent:true<co xml:id="co.ex_stomp_ext_persistent_1"/>

This message is persisted!^@
</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_ext_persistent_1">
    <para>The message will be persisted by the broker and will be available if the server crashes or stops.</para>
  </callout>
</calloutlist>
</example>
<simpara>If the message is not consumed when the broker goes offline, the broker will load it when it restarts and consumers will be able to receive it.</simpara>
<simpara>Each STOMP brokers may define its own set of headers and you have to consult their documentation to know which additional features are supported.</simpara>
</sect1>
</chapter>
<chapter id="ch_stomp_example" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter050-STOMP-Example.asciidoc">
<title>STOMP Example</title>
<simpara role="lead">In this chapter, we develop a mobile app on iOS that will send the GPS data of
the device and displays orders.</simpara>
<sect1 id="_wildcard_subscription" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter050-STOMP-Example.asciidoc">
<title>Wildcard Subscription</title>
<simpara>Before we start writing the iOS app that will send the GPS data, we can create a simple message consumer using <literal>telnet</literal> that will
consume the message sent by the app.</simpara>
<simpara>As descibed in <xref linkend="ch_example_app_topology"/>, each app will sent its GPS data on a topic named <literal>truck.XXX.data</literal> where <literal>XXX</literal> is the truck identifier.</simpara>
<simpara>We want to write a client that consume messages for <emphasis>any</emphasis> truck without having to list all of them explicitly.</simpara>
<simpara>STOMP leaves the semantic of the destination to the STOMP broker implementations and it turns out that most of them
support <emphasis>wildcards</emphasis>.</simpara>
<simpara>For example, ActiveMQ supports  <ulink url="http://activemq.apache.org/wildcards.html">wildcards</ulink>:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>.</literal> is used to separate names in a path
</simpara>
</listitem>
<listitem>
<simpara>
<literal>*</literal> is used to match any name in a path
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&gt;</literal> is used to recursively match any destination starting from this name
</simpara>
</listitem>
</itemizedlist>
<simpara>With our example using ActiveMQ, we can use this notation to listen for any
truck GPS data by subscribing to the <literal>truck.*.data</literal> topic (where <literal>*</literal> stands for <emphasis>any truck identifier</emphasis>).
Note that using the wildcard <literal>truck.&gt;</literal> would have not been correct since it would subscribe to any destination starting
with <literal>truck.</literal> such as the queue used by the truck to receive orders (for example <literal>truck.AAA.orders</literal>).
This client is only interested by GPS data and not by any other destination related to the truck. Using the <literal>truck.*.data</literal> wildcard matches
exactly this constraint.</simpara>
<example id="ex_stomp_example_telnet">
<title>Subscribe to the widlcard destination <literal>/topic/truck.*.data</literal></title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
heart-beat:0,0<co xml:id="co.ex_stomp_example_telnet_1"/>
login:user
passcode:password

</userinput>^@

CONNECTED
heart-beat:0,0
session:ID:retsina.local-61690-1380810104254-2:4
server:ActiveMQ/5.8.0
version:1.2

<userinput>SUBSCRIBE
destination:/topic/truck.*.data<co xml:id="co.ex_stomp_example_telnet_2"/>
id:sub1

</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_example_telnet_1">
    <para>Heart-beat is disabled so that the telnet client can remain open without sending periodical heart-beats to the broker</para>
  </callout>
  <callout arearefs="co.ex_stomp_example_telnet_2">
    <para>We subscribe to the wildcard destination <literal>/topic/truck.*.data</literal>. Note that we must prefix the topic name
<literal>truck.*.data</literal> by <literal>/topic/</literal> to follow ActiveMQ convention (as described in the note in <xref linkend="ch_stomp_send_message" />)</para>
  </callout>
</calloutlist>
</example>
<simpara>The <literal>telnet</literal> client can now consume any messages sent to a destination of the form <literal>/topic/truck.*.data</literal>.</simpara>
<simpara>To verify this, let&#8217;s open a <emphasis>second</emphasis> telnet client that will send a message corresponding to the position of the
<literal>AAA</literal> truck.</simpara>
<simpara>As shown in <xref linkend="ex_example_gps_data"/>, the message payload will be a JSON string:</simpara>
<screen>{
  "truck":"AAA",
  "lat":48.8581,
  "lng":2.2946,
  "ts":"2013-09-23T08:43Z"
}</screen>
<example id="ex_stomp_example_telnet_sender">
<title>Send a message to the <literal>truck.AAA.data</literal> topic</title>
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<userinput>CONNECT
accept-version:1.2
heart-beat:0,0
login:user
passcode:password

</userinput>^@

CONNECTED
heart-beat:0,0
session:ID:retsina.local-61690-1380810104254-2:4
server:ActiveMQ/5.8.0
version:1.2

<userinput>SEND
content-type:application/json
destination:/topic/truck.AAA.data<co xml:id="co.ex_stomp_example_telnet_sender_1"/>
content-length:67

{"truck":"AAA","lat":48.8581,"lng":2.2946,"ts":"2013-09-23T08:43Z"}</userinput>^@
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_example_telnet_sender_1">
    <para>The message is sent to the topic <literal>truck.AAA.data</literal></para>
  </callout>
</calloutlist>
</example>
<simpara>Once this message is sent, we can see that the first <literal>telnet</literal> client has received it:</simpara>
<example id="ex_stomp_example_telnet_receiver">
<title>Receive a message from a wildcard subscription</title>
<screen>
MESSAGE
content-type:application/json
message-id:ID\cretsina.local-61690-1380810104254-2\c6\c-1\c1\c9
destination:/topic/truck.AAA.data<co xml:id="co.ex_stomp_example_telnet_receiver_1"/>
timestamp:1380815240205
expires:0
subscription:sub1
content-length:67
priority:4

{"truck":"AAA","lat":48.8581,"lng":2.2946,"ts":"2013-09-23T08:43Z"}
</screen>
<calloutlist>
  <callout arearefs="co.ex_stomp_example_telnet_receiver_1">
    <para>The <literal>destination</literal> header corresponds to the actual destination. It can be used to distinguish
the different destinations matching the wildcard subscription.</para>
  </callout>
</calloutlist>
</example>
<simpara>We can leave the first <literal>telnet</literal> client open to check that our iOS app will properly send the data messages.</simpara>
</sect1>
<sect1 id="_truck_tracker_ios_app" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter050-STOMP-Example.asciidoc">
<title>Truck Tracker iOS app</title>
<simpara>TODO</simpara>
<sect2 id="_create_xcode_project">
<title>create Xcode project</title>
<simpara>TODO</simpara>
</sect2>
<sect2 id="_project_template">
<title>Project template</title>
<simpara>TODO</simpara>
<simpara>view + controllers + UI</simpara>
</sect2>
<sect2 id="_add_stomp_library">
<title>add STOMP library</title>
<simpara>TODO</simpara>
</sect2>
<sect2 id="_write_stomp_connection">
<title>write STOMP connection</title>
<simpara>TODO</simpara>
</sect2>
<sect2 id="_send_gps_data">
<title>Send GPS data</title>
<simpara>TODO</simpara>
</sect2>
</sect1>
</chapter>
<chapter id="_mqtt" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter060-MQTT.asciidoc">
<title>MQTT</title>
<simpara role="lead">In this chapter, we present MQTT, a binary-based protocol develop for telemetry
communication. Its simplicity and compactness make it ideally suited for mobile devices.</simpara>
<simpara>TODO</simpara>
<sect1 id="_protocol_features" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter060-MQTT.asciidoc">
<title>Protocol Features</title>
<simpara>TODO</simpara>
</sect1>
<sect1 id="_protocol_clients" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter060-MQTT.asciidoc">
<title>Protocol clients</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="_mqtt_example" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter070-MQTT-Example.asciidoc">
<title>MQTT Example</title>
<simpara role="lead">In this chapter, we will write an Android app that uses MQTT to send the GPS data
of the device and display orders</simpara>
<sect1 id="_truck_tracker_android_app" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter070-MQTT-Example.asciidoc">
<title>Truck Tracker Android app</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="_web_messaging" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter080-Web-Messaging.asciidoc">
<title>Web Messaging</title>
<simpara role="lead">In this chapter, we present some challenges that the Web (and HTTP) present to
build Web applications that are updated dynamically. We highlight how new
features in HTML5 allows two-way communication between the Web client and the
server. These new features can be leveraged to use messaging protocols in Web
applications.</simpara>
<simpara>TODO</simpara>
<sect1 id="_http_constraints" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter080-Web-Messaging.asciidoc">
<title>HTTP Constraints</title>
<simpara>TODO</simpara>
</sect1>
<sect1 id="_web_browser_constraints" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter080-Web-Messaging.asciidoc">
<title>Web Browser Constraints</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="_html5_web_sockets" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter090-HTML5-Web-Sockets.asciidoc">
<title>HTML5 Web Sockets</title>
<simpara role="lead">In this chapter, we present the HTML5 Web Sockets that can allows two-way
communication between a Web browser and a server.</simpara>
<simpara>The HTML5 Web Sockets is composed of 2 parts:</simpara>
<itemizedlist>
<listitem>
<simpara>
The Web Sockets protocol, implemented by the Web browsers and servers
</simpara>
</listitem>
<listitem>
<simpara>
The Web Sockets JavaScript API that Web browsers provide to let Web application
communicate with servers.
</simpara>
</listitem>
</itemizedlist>
<sect1 id="_web_sockets_protocol" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter090-HTML5-Web-Sockets.asciidoc">
<title>Web Sockets Protocol</title>
<simpara>TODO</simpara>
</sect1>
<sect1 id="_web_sockets_javascript_api" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter090-HTML5-Web-Sockets.asciidoc">
<title>Web Sockets JavaScript API</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="_stomp_over_web_sockets" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter100-STOMP-over-Web-Sockets.asciidoc">
<title>STOMP Over Web Sockets</title>
<simpara role="lead">In this chapter, we describe how STOMP can be used over HTML5 Web Sockets
to let Web applications act as STOMP publishers and subscribers.</simpara>
</chapter>
<chapter id="ch_stomp_ws_example" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter110-STOMP-over-Web-Sockets-Example.asciidoc">
<title>STOMP Over Web Sockets Example</title>
<simpara role="lead">In this chapter, we built a Web application that uses STOMP over Web Sockets to
display truck GPS positions on a map and send them orders.</simpara>
<sect1 id="_truck_tracker_control_center" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter110-STOMP-over-Web-Sockets-Example.asciidoc">
<title>Truck Tracker Control Center</title>
<simpara>TODO</simpara>
</sect1>
</chapter>
<chapter id="_mqtt_over_web_sockets" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Chapter120-MQTT-over-Web-Sockets.asciidoc">
<title>MQTT Over Web Sockets</title>
<simpara role="lead">In this chapter, we describe how MQTT can be used over HTML5 Web Sockets
to let Web applications act as MQTT publishers and subscribers.</simpara>
</chapter>
<appendix id="appendix_activemq" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>Apache ActiveMQ</title>
<simpara role="lead">In this appendix, we describe how to install and configure Apache ActiveMQ to
support STOMP and MQTT protocols.</simpara>
<sect1 id="_download_and_installation" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>Download and Installation</title>
<simpara>Apache ActiveMQ latest release can be downloaded for its
<ulink url="http://activemq.apache.org/activemq-580-release.html">download page</ulink> and the
<ulink url="http://activemq.apache.org/getting-started.html">getting started page</ulink> contains all the information to install it.</simpara>
<simpara>For our setup, ActiveMQ will be installed in the directory <literal>~/mobilewebmsg/mybroker</literal>.</simpara>
<simpara>Once you have download the archive for ActiveMQ, it can be installed and started by running the commands:</simpara>
<programlisting language="sh">$ tar zxvf apache-activemq-5.8.0-bin.tar.gz
$ cd apache-activemq-5.8.0
$ mkdir ~/mobilewebmsg/
$ ./bin/activemq create ~/mobilewebmsg/mybroker
...
$ cd ~/mobilewebmsg/mybroker
$ ./bin/mybroker start
...
$ tail data/activemq.log
...
2013-06-14 19:44:52,801 | INFO  | Apache ActiveMQ 5.8.0 (mybroker, ID:retsina.local-53410-1371231892651-0:1) started | org.apache.activemq.broker.BrokerService | main
...</programlisting>
<simpara>To stop he broker, run the following command:</simpara>
<programlisting language="sh">$ ./bin/mybroker stop
...
Stopping broker: mybroker
.... FINISHED</programlisting>
</sect1>
<sect1 id="app_activemq_security" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>Security Configuration</title>
<simpara>Out of the box, ActiveMQ does not provide any security authentication on its connections. While it makes it simple to test it, this is not a good practice
and we will activate a very simple authentication mechanism.</simpara>
<simpara>Edit the <literal>conf/activemq.xml</literal> file to add a <literal>plugins</literal> element after the <literal>managemementContext</literal> element:</simpara>
<programlisting language="sh">$ cd ~/mobilewebmsg/mybroker
$ vim ./conf/activemq.xml
...
&lt;managementContext&gt;
   ...
&lt;/managementContext&gt;
&lt;plugins&gt;
    &lt;!-- Configure authentication; Username, passwords and groups --&gt;
    &lt;simpleAuthenticationPlugin&gt;
        &lt;users&gt;
            &lt;authenticationUser username="system"
                                password="${activemq.password}"
                                groups="users,admins"/&gt;
            &lt;authenticationUser username="user"
                                password="${guest.password}"
                                groups="users"/&gt;
            &lt;authenticationUser username="guest"
                                password="${guest.password}"
                                groups="guests"/&gt;
        &lt;/users&gt;
    &lt;/simpleAuthenticationPlugin&gt;

    &lt;!--  Lets configure a destination based authorization mechanism --&gt;
    &lt;authorizationPlugin&gt;
      &lt;map&gt;
        &lt;authorizationMap&gt;
          &lt;authorizationEntries&gt;
            &lt;authorizationEntry queue="&gt;"
                                read="users"
                                write="users"
                                admin="users" /&gt;
            &lt;authorizationEntry topic="&gt;"
                                read="users"
                                write="users"
                                admin="users" /&gt;
            &lt;authorizationEntry topic="ActiveMQ.Advisory.&gt;"
                                read="guests,users"
                                write="guests,users"
                                admin="guests,users"/&gt;
          &lt;/authorizationEntries&gt;
        &lt;/authorizationMap&gt;
      &lt;/map&gt;
    &lt;/authorizationPlugin&gt;

    &lt;!-- This plugin allows to use / as a destination path separator --&gt;
    &lt;destinationPathSeparatorPlugin /&gt;
&lt;/plugins&gt;
...</programlisting>
<simpara>We restart the broker to update its configuration</simpara>
<programlisting language="sh">$ ./bin/mybroker restart
...

ActiveMQ is running (pid '6664')</programlisting>
<simpara>With this setting, only authenticated user identified by the name <literal>user</literal> and the password <literal>password</literal> will be able to connect to ActiveMQ.</simpara>
</sect1>
<sect1 id="app_activemq_stomp" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>STOMP Configuration</title>
<simpara>STOMP protocol is enabled in ActiveMQ by adding a transport connector to its configuration (as explained in full details in its
<ulink url="http://activemq.apache.org/stomp.html">STOMP configuration</ulink>).</simpara>
<simpara>Edit the <literal>conf/activemq.xml</literal> file to add a <literal>transport</literal> connector for STOMP:</simpara>
<programlisting language="sh">$ cd ~/mobilewebmsg/mybroker
$ vim ./conf/activemq.xml
...
&lt;transportConnectors&gt;
   ...
   &lt;transportConnector name="stomp" uri="stomp://localhost:61613"/&gt;
   ...
&lt;/transportConnectors&gt;</programlisting>
<simpara>After ActiveMQ is restarted, it accepts STOMP connections at the URL <literal>stomp://localhost:61613</literal>.</simpara>
<programlisting language="sh">$ ./bin/mybroker restart
...
ActiveMQ is running (pid '6664')
$ tail data/activemq.log
...
2013-06-14 19:44:52,797 | INFO  | Listening for connections at: stomp://localhost:61613 | org.apache.activemq.transport.TransportServerThreadSupport | main
2013-06-14 19:44:52,797 | INFO  | Connector stomp Started | org.apache.activemq.broker.TransportConnector | main
...</programlisting>
</sect1>
<sect1 id="app_activemq_mqtt" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>MQTT Configuration</title>
<simpara>Like for STOMP, MQTT protocol can be added to ActiveMQ by adding a transport connector to its configuration (as explained in full details in its
<ulink url="http://activemq.apache.org/mqtt.html">MQTT configuration</ulink>).</simpara>
<programlisting language="sh">$ cd ~/mobilewebmsg/mybroker
$ vim ./conf/activemq.xml
...
&lt;transportConnectors&gt;
    ...
    &lt;transportConnector name="mqtt" uri="mqtt://localhost:1883"/&gt;
    ...
&lt;/transportConnectors&gt;
$ ./bin/mybroker restart
...
ActiveMQ is running (pid '6664')</programlisting>
<simpara>After ActiveMQ is restarted, it accepts MQTT connections at the URL <literal>mqtt://localhost:1883</literal>.</simpara>
<programlisting language="sh">2013-06-14 19:44:52,799 | INFO  | Listening for connections at: mqtt://localhost:1883 | org.apache.activemq.transport.TransportServerThreadSupport | main
2013-06-14 19:44:52,800 | INFO  | Connector mqtt Started | org.apache.activemq.broker.TransportConnector | main</programlisting>
</sect1>
<sect1 id="app_activemq_websockets" remap="/mnt/work/work/spaces/holly/checkouts/ally1/AppendixA-ActiveMQ.asciidoc">
<title>Web Sockets Configuration</title>
<simpara>The Web Sockets  protocol is enabled in ActiveMQ by adding a transport connector to its configuration (as explained in full details in its
<ulink url="http://activemq.apache.org/websockets.html">Web Sockets configuration page</ulink>).</simpara>
<programlisting language="sh">$ vim ./conf/activemq.xml
...
&lt;transportConnectors&gt;
   ...
   &lt;transportConnector name="websocket" uri="ws://0.0.0.0:61614"/&gt;
   ...
&lt;/transportConnectors&gt;</programlisting>
<simpara>After ActiveMQ is restarted, it accepts Web Sockets connection at the URL <literal>ws://0.0.0.0:61614</literal>.</simpara>
<programlisting language="sh">2013-06-14 19:55:01,490 | INFO  | Connector websocket Started | org.apache.activemq.broker.TransportConnector | main</programlisting>
</sect1>
</appendix>
<preface id="_afterword" role="afterword" remap="/mnt/work/work/spaces/holly/checkouts/ally1/Afterword.asciidoc">
<title>Afterword</title>
<simpara>Afterword text begins here.</simpara>
</preface>
</book>
